{
    "sport": {
        "prefix": "sport",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"../libra/misc/dbg.h\"",
            "#else",
            "#define debug(...)",
            "#define endl \"\\\\n\"",
            "#endif",
            "",
            "signed main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int t = 1;",
            "    cin >> t;",
            "    while(t --)",
            "    {",
            "        $0",
            "    }",
            "}"
        ],
        "description": "Snippet for Template"
    },
    "TemplateRandom": {
        "prefix": "TemplateRandom",
        "body": [
            "struct Random : std::mt19937",
            "{",
            "    using std::mt19937::mt19937;",
            "    using std::mt19937::operator();",
            "    static int64_t gen_seed()",
            "    {",
            "        return std::chrono::steady_clock::now().time_since_epoch().count();",
            "    }",
            "    Random() : std::mt19937(gen_seed()) {}",
            "    template <class Int>",
            "    auto operator()(Int a, Int b)",
            "        -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(a, b)(*this);",
            "    }",
            "    template <class Int>",
            "    auto operator()(Int a) -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(0, a - 1)(*this);",
            "    }",
            "    template <class Real>",
            "    auto operator()(Real a, Real b)",
            "        -> std::enable_if_t<std::is_floating_point_v<Real>, Real>",
            "    {",
            "        return std::uniform_real_distribution<Real>(a, b)(*this);",
            "    }",
            "};"
        ],
        "description": "Snippet for Random"
    },
    "TemplatePragma": {
        "prefix": "TemplatePragma",
        "body": [
            "#include <bits/allocator.h>",
            "#pragma GCC optimize(\"O3,unroll-loops\")",
            "#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")"
        ],
        "description": "Snippet for Pragma"
    },
    "TemplateAux": {
        "prefix": "TemplateAux",
        "body": [
            "namespace Aux",
            "{",
            "    namespace Bitwise",
            "    {",
            "        int64_t p(int i)",
            "        {",
            "            return 1LL << i;",
            "        }",
            "    }",
            "    namespace Math",
            "    {",
            "        int ceil_div(int x, int y)",
            "        {",
            "            return (x + y - 1)/y;",
            "        }",
            "        int64_t ceil_div(int64_t x, int64_t y)",
            "        {",
            "            return (x + y - 1)/y;",
            "        }",
            "    }",
            "    namespace String",
            "    {",
            "        vector<int> convert(string s, char base)",
            "        {",
            "            vector<int> a(s.length());",
            "            for(int i = 0; i < s.length(); i ++)",
            "                a[i] = s[i] - base;",
            "            return a;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Snippet for Aux"
    },
    "TemplateRandom64": {
        "prefix": "TemplateRandom64",
        "body": [
            "struct Random64 : std::mt19937_64",
            "{",
            "    using std::mt19937_64::mt19937_64;",
            "    using std::mt19937_64::operator();",
            "",
            "    static int64_t gen_seed()",
            "    {",
            "        return std::chrono::steady_clock::now().time_since_epoch().count();",
            "    }",
            "",
            "    Random64() : std::mt19937_64(gen_seed()) {}",
            "",
            "    template <class Int>",
            "    auto operator()(Int a, Int b)",
            "        -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(a, b)(*this);",
            "    }",
            "",
            "    template <class Int>",
            "    auto operator()(Int a)",
            "        -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(0, a - 1)(*this);",
            "    }",
            "",
            "    template <class Real>",
            "    auto operator()(Real a, Real b)",
            "        -> std::enable_if_t<std::is_floating_point_v<Real>, Real>",
            "    {",
            "        return std::uniform_real_distribution<Real>(a, b)(*this);",
            "    }",
            "};"
        ],
        "description": "Snippet for Random64"
    },
    "sport_hacker": {
        "prefix": "sport_hacker",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"../libra/misc/dbg.h\"",
            "#else",
            "#define debug(...)",
            "#define endl \"\\\\n\"",
            "#endif",
            "",
            "void main_()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int t = 1;",
            "    cin >> t;",
            "    for(int tt = 1; tt <= t; tt ++)",
            "    {",
            "        ifstream fin(\"inp.txt\");",
            "        ofstream fout(\"out.txt\");",
            "",
            "        $0",
            "    }",
            "}",
            "",
            "static void run_with_stack_size(void (*func)(void), size_t stsize)",
            "{",
            "    char *stack, *send;",
            "    stack = (char *)malloc(stsize);",
            "    send = stack + stsize - 16;",
            "    send = (char *)((uintptr_t)send / 16 * 16);",
            "    asm volatile(",
            "        \"mov %%rsp, (%0)\\\\n\"",
            "        \"mov %0, %%rsp\\\\n\"",
            "        :",
            "        : \"r\"(send));",
            "    func();",
            "    asm volatile(\"mov (%0), %%rsp\\\\n\" : : \"r\"(send));",
            "    free(stack);",
            "}",
            "",
            "int32_t main()",
            "{",
            "    run_with_stack_size(main_, 1024 * 1024 * 1024); // run with a 1 GiB stack",
            "    return 0;",
            "}"
        ],
        "description": "Snippet for HackerCup"
    },
    "TemplateBitmask": {
        "prefix": "TemplateBitmask",
        "body": [
            "//wip",
            "",
            "namespace BitmaskChan",
            "{",
            "    ",
            "};",
            "using namespace BitmaskChan;"
        ],
        "description": "Snippet for Bitmask"
    },
    "TemplateTime": {
        "prefix": "TemplateTime",
        "body": [
            "auto start = std::chrono::high_resolution_clock::now();",
            "// Code to benchmark",
            "auto end = std::chrono::high_resolution_clock::now();",
            "auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();",
            "std::cout << \"Execution time: \" << duration << \" microseconds\" << std::endl;"
        ],
        "description": "Snippet for Time"
    },
    "TemplateSolnCorrect": {
        "prefix": "TemplateSolnCorrect",
        "body": [
            "#include<bits/stdc++.h>",
            "#pragma GCC optimize(\"O3\")",
            "",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"/dbg.h\"",
            "#else",
            "#define endl \"\\\\n\"",
            "#define debug(...)",
            "#endif",
            "",
            "const int64_t inf = 1e9+9, INF = 1e18;",
            "",
            "//#define int int64_t",
            "",
            "const int N = 3e5+5;",
            "",
            "int32_t main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int a, b;",
            "    cin >> a >> b;",
            "    cout << a + b << endl;",
            "}"
        ],
        "description": "Snippet for SolnCorrect"
    },
    "TemplateTestGenerator": {
        "prefix": "TemplateTestGenerator",
        "body": [
            "#include<bits/stdc++.h>",
            "#pragma GCC optimize(\"O3\")",
            "",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"/dbg.h\"",
            "#else",
            "#define endl \"\\\\n\"",
            "#define debug(...)",
            "#endif",
            "",
            "const int64_t inf = 1e9+9, INF = 1e18;",
            "",
            "//#define int int64_t",
            "",
            "const int N = 3e5+5;",
            "",
            "int32_t main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int a = rand() % 10, b = rand() % 10;",
            "    cout << a << \" \" << b << endl; ",
            "}"
        ],
        "description": "Snippet for TestGenerator"
    },
    "TemplateSolnMy": {
        "prefix": "TemplateSolnMy",
        "body": [
            "#include<bits/stdc++.h>",
            "#pragma GCC optimize(\"O3\")",
            "",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"/dbg.h\"",
            "#else",
            "#define endl \"\\\\n\"",
            "#define debug(...)",
            "#endif",
            "",
            "const int64_t inf = 1e9+9, INF = 1e18;",
            "",
            "//#define int int64_t",
            "",
            "const int N = 3e5+5;",
            "",
            "int32_t main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int a, b;",
            "    cin >> a >> b;",
            "    cout << a + b << endl;",
            "}"
        ],
        "description": "Snippet for SolnMy"
    },
    "TemplateHashMap": {
        "prefix": "TemplateHashMap",
        "body": [
            "// #include<bits/extc++.h>",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "",
            "struct splitmix64_hash {",
            "    static uint64_t splitmix64(uint64_t x) {",
            "        // http://xorshift.di.unimi.it/splitmix64.c",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            "",
            "    size_t operator()(uint64_t x) const {",
            "        static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "    }",
            "};",
            "",
            "template <typename K, typename V, typename Hash = splitmix64_hash>",
            "using HashMap = __gnu_pbds::gp_hash_table<K, V, Hash>;",
            "",
            "template <typename K, typename Hash = splitmix64_hash>",
            "using HashSet = HashMap<K, __gnu_pbds::null_type, Hash>;"
        ],
        "description": "Snippet for HashMap"
    },
    "TemplateOrderedSet": {
        "prefix": "TemplateOrderedSet",
        "body": [
            "// #include<bits/extc++.h>",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "",
            "template <typename K, typename V, typename Comp = std::less<K>>",
            "using ordered_map = __gnu_pbds::tree<",
            "    K, V, Comp,",
            "    __gnu_pbds::rb_tree_tag,",
            "    __gnu_pbds::tree_order_statistics_node_update",
            ">;",
            "",
            "template <typename K, typename Comp = std::less<K>>",
            "using ordered_set = ordered_map<K, __gnu_pbds::null_type, Comp>;",
            "",
            "// Supports",
            "//  auto iterator = ordered_set().find_by_order(idx); // (0-indexed)",
            "//  int num_strictly_smaller = ordered_set().order_of_key(key);"
        ],
        "description": "Snippet for OrderedSet"
    },
    "TemplateInt128": {
        "prefix": "TemplateInt128",
        "body": [
            "// int128 bit for numbers larger than 1e18. Will support numbers till 1e36",
            "// Comment out everything related to PBDS while using this",
            "// Put all the code in the same order",
            "",
            "// Typedef to ell",
            "typedef __int128 ell;",
            "",
            "// For printing",
            "std::ostream&",
            "operator<<( std::ostream& dest, __int128_t value ) {",
            "\tstd::ostream::sentry s( dest );",
            "\tif ( s ) {",
            "\t\t__uint128_t tmp = value < 0 ? -value : value; char buffer[ 128 ];",
            "\t\tchar* d = std::end( buffer );",
            "\t\tdo {\t-- d; *d = \"0123456789\"[ tmp % 10 ]; tmp /= 10;} while ( tmp != 0 );",
            "\t\tif ( value < 0 ) {-- d; *d = '-';}",
            "\t\tint len = std::end( buffer ) - d;",
            "\t\tif ( dest.rdbuf()->sputn( d, len ) != len ) {dest.setstate( std::ios_base::badbit );}",
            "\t}",
            "\treturn dest;",
            "}",
            "",
            "// For reading _int128 to_read = read()",
            "__int128 read() {",
            "\t__int128 x = 0, f = 1;",
            "\tchar ch = getchar();",
            "\twhile (ch < '0' || ch > '9') {if (ch == '-') f = -1; ch = getchar();}",
            "\twhile (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}",
            "\treturn x * f;",
            "}",
            "",
            "// For debugging",
            "void _print(ell t) {cerr << t;}"
        ],
        "description": "Snippet for Int128"
    },
    "TemplateMinPQ": {
        "prefix": "TemplateMinPQ",
        "body": [
            "template<typename T>",
            "using MinPQ = priority_queue<T, vector<T>, greater<T>>;"
        ],
        "description": "Snippet for MinPQ"
    },
    "TemplateUltraFastSet": {
        "prefix": "TemplateUltraFastSet",
        "body": [
            "using uint = unsigned int;",
            "using ull = unsigned long long;",
            "constexpr ull lowest_bitsll[] = {0ull, 1ull, 3ull, 7ull, 15ull, 31ull, 63ull, 127ull, 255ull, 511ull, 1023ull, 2047ull, 4095ull, 8191ull, 16383ull, 32767ull, 65535ull, 131071ull, 262143ull, 524287ull, 1048575ull, 2097151ull, 4194303ull, 8388607ull, 16777215ull, 33554431ull, 67108863ull, 134217727ull, 268435455ull, 536870911ull, 1073741823ull, 2147483647ull, 4294967295ull, 8589934591ull, 17179869183ull, 34359738367ull, 68719476735ull, 137438953471ull, 274877906943ull, 549755813887ull, 1099511627775ull, 2199023255551ull, 4398046511103ull, 8796093022207ull, 17592186044415ull, 35184372088831ull, 70368744177663ull, 140737488355327ull, 281474976710655ull, 562949953421311ull, 1125899906842623ull, 2251799813685247ull, 4503599627370495ull, 9007199254740991ull, 18014398509481983ull, 36028797018963967ull, 72057594037927935ull, 144115188075855871ull, 288230376151711743ull, 576460752303423487ull, 1152921504606846975ull, 2305843009213693951ull, 4611686018427387903ull, 9223372036854775807ull, 18446744073709551615ull};",
            "const uint NO = 1 << 20; // This value will be returned in lower_bound functions, if no answer exists. Change, if need.",
            "template <uint MAXN>     // Can correctly work with numbers in range [0; MAXN]",
            "class godgod_suc_pred",
            "{",
            "    static const uint PREF = (MAXN <= 64 ? 0 : MAXN <= 4096     ? 1",
            "                                           : MAXN <= 262144     ? 1 + 64",
            "                                           : MAXN <= 16777216   ? 1 + 64 + 4096",
            "                                           : MAXN <= 1073741824 ? 1 + 64 + 4096 + 262144",
            "                                                                : 227) +",
            "                             1;",
            "    static const uint SZ = PREF + (MAXN + 63) / 64 + 1;",
            "    ull m[SZ] = {0};",
            "",
            "    inline uint left(uint v) const { return (v - 62) * 64; }",
            "    inline uint parent(uint v) const { return v / 64 + 62; }",
            "    inline void setbit(uint v) { m[v >> 6] |= 1ull << (v & 63); }",
            "    inline void resetbit(uint v) { m[v >> 6] &= ~(1ull << (v & 63)); }",
            "    inline uint getbit(uint v) const { return m[v >> 6] >> (v & 63) & 1; }",
            "    inline ull childs_value(uint v) const { return m[left(v) >> 6]; }",
            "",
            "    inline uint left_go(uint x, const uint c) const",
            "    {",
            "        const ull rem = x & 63;",
            "        uint bt = PREF * 64 + x;",
            "        ull num = m[bt >> 6] & lowest_bitsll[rem + c];",
            "        if (num)",
            "            return (x ^ rem) | __lg(num);",
            "        for (bt = parent(bt); bt > 62; bt = parent(bt))",
            "        {",
            "            const ull rem = bt & 63;",
            "            num = m[bt >> 6] & lowest_bitsll[rem];",
            "            if (num)",
            "            {",
            "                bt = (bt ^ rem) | __lg(num);",
            "                break;",
            "            }",
            "        }",
            "        if (bt == 62)",
            "            return NO;",
            "        while (bt < PREF * 64)",
            "            bt = left(bt) | __lg(m[bt - 62]);",
            "        return bt - PREF * 64;",
            "    }",
            "",
            "    inline uint right_go(uint x, const uint c) const",
            "    {",
            "        const ull rem = x & 63;",
            "        uint bt = PREF * 64 + x;",
            "        ull num = m[bt >> 6] & ~lowest_bitsll[rem + c];",
            "        if (num)",
            "            return (x ^ rem) | __builtin_ctzll(num);",
            "        for (bt = parent(bt); bt > 62; bt = parent(bt))",
            "        {",
            "            const ull rem = bt & 63;",
            "            num = m[bt >> 6] & ~lowest_bitsll[rem + 1];",
            "            if (num)",
            "            {",
            "                bt = (bt ^ rem) | __builtin_ctzll(num);",
            "                break;",
            "            }",
            "        }",
            "        if (bt == 62)",
            "            return NO;",
            "        while (bt < PREF * 64)",
            "            bt = left(bt) | __builtin_ctzll(m[bt - 62]);",
            "        return bt - PREF * 64;",
            "    }",
            "",
            "public:",
            "    godgod_suc_pred()",
            "    {",
            "        assert(PREF != 228);",
            "        setbit(62);",
            "    }",
            "",
            "    bool empty() const { return getbit(63); }",
            "",
            "    void clear()",
            "    {",
            "        fill(m, m + SZ, 0);",
            "        setbit(62);",
            "    }",
            "",
            "    bool count(uint x) const { return m[PREF + (x >> 6)] >> (x & 63) & 1; }",
            "",
            "    void insert(uint x)",
            "    {",
            "        for (uint v = PREF * 64 + x; !getbit(v); v = parent(v))",
            "        {",
            "            setbit(v);",
            "        }",
            "    }",
            "",
            "    void erase(uint x)",
            "    {",
            "        if (!getbit(PREF * 64 + x))",
            "            return;",
            "        resetbit(PREF * 64 + x);",
            "        for (uint v = parent(PREF * 64 + x); v > 62 && !childs_value(v); v = parent(v))",
            "        {",
            "            resetbit(v);",
            "        }",
            "    }",
            "",
            "    uint lower_bound(uint x) const { return right_go(x, 0); }",
            "    uint upper_bound(uint x) const { return right_go(x, 1); }",
            "    uint inverse_lower_bound(uint x) const { return left_go(x, 1); }",
            "    uint inverse_upper_bound(uint x) const { return left_go(x, 0); }",
            "};",
            "// Supports all std::set operations in O(1) on random queries / dense arrays, O(log_64(N)) in worst case (sparce array).",
            "// Count operation works in O(1) always.",
            "//  reference : https://codeforces.com/contest/1793/submission/193330718"
        ],
        "description": "Snippet for UltraFastSet"
    },
    "TemplateFastIO": {
        "prefix": "TemplateFastIO",
        "body": [
            "namespace FastIO",
            "{",
            "    /*",
            "    warning:",
            "        remove custom fastio things",
            "    ",
            "    usage:",
            "        https://codeforces.com/contest/659/submission/128052727",
            "    */",
            "",
            "\tconstexpr int SIZE = (1 << 21) + 1;",
            "\tint num = 0, f;",
            "\tchar ibuf[SIZE], obuf[SIZE], que[65], *iS, *iT, *oS = obuf, *oT = obuf + SIZE - 1, c;",
            "\t#define gc() (iS == iT ? (iT = ((iS = ibuf) + fread(ibuf, 1, SIZE, stdin)), (iS == iT ? EOF : *iS ++)) : *iS ++)",
            "\tinline void flush()",
            "    {",
            "\t\tfwrite(obuf, 1, oS - obuf, stdout);",
            "\t\toS = obuf;",
            "\t}",
            "\tinline void putc(char c)",
            "    {",
            "\t\t*oS ++ = c;",
            "\t\tif (oS == oT) flush();",
            "\t}",
            "\tinline void getc(char &c) ",
            "    {",
            "\t\tfor (c = gc(); (c == ' ' || c == '\\\\0' || c == '\\\\n') && c != EOF; c = gc());",
            "\t}",
            "\tinline void reads(char *st) ",
            "    {",
            "\t\tchar c;",
            "\t\tint n = 0; ",
            "\t\tgetc(st[++ n]);",
            "\t\tfor (c = gc(); c != ' ' && c != '\\\\0' && c != '\\\\n' && c != EOF ; c = gc()) st[++ n] = c;",
            "\t\tst[++ n] = '\\\\0';",
            "\t}",
            "\ttemplate<class I>",
            "\tinline void read(I &x) ",
            "    {",
            "\t\tfor (f = 1, c = gc(); c < '0' || c > '9' ; c = gc()) if (c == '-') f = -1;",
            "\t\tfor (x = 0; c >= '0' && c <= '9' ; c = gc()) x = (x << 3) + (x << 1) + (c & 15);",
            "\t\tx *= f;",
            "\t}",
            "\ttemplate<class I>",
            "\tinline void print(I x) ",
            "    {",
            "\t\tif (x < 0) putc('-'), x = -x;",
            "\t\tif (!x) putc('0');",
            "\t\twhile (x) que[++ num] = x % 10 + 48, x /= 10;",
            "\t\twhile (num) putc(que[num --]);",
            "\t}",
            "\tinline void putstr(string st) ",
            "    {",
            "\t\tfor (int i = 0; i < (int)st.size() ; ++ i)  putc(st[i]);",
            "\t}",
            "\tstruct Flusher_{~Flusher_(){flush();}} io_Flusher_;",
            "}",
            "using FastIO :: read;",
            "using FastIO :: putc;",
            "using FastIO :: putstr;",
            "using FastIO :: getc;",
            "using FastIO :: reads;",
            "using FastIO :: print;"
        ],
        "description": "Snippet for FastIO"
    },
    "TemplateFastSet": {
        "prefix": "TemplateFastSet",
        "body": [
            "// https://codeforces.com/contest/1641/submission/147448352",
            "",
            "// D : 3 -> 2.6 * 10 ^ 5",
            "// D : 4 -> 1.6 * 10 ^ 7",
            "// D : 5 -> 1.0 * 10 ^ 9",
            "// D : 6 -> int \u306e\u7bc4\u56f2\u5168\u90e8",
            "",
            "const int not_found = 262144;",
            "",
            "template <const int D = 6> struct FastSet {",
            "    int n;",
            "    using u64 = uint64_t;",
            "    vector<u64> a[D];",
            "    FastSet(int n_ = (1 << std::min(31, D * 6))) : n(n_) {",
            "        for(int i = 0; i < D; i++) {",
            "            n_ = (n_ + 63) >> 6;",
            "            a[i].assign(n_, 0);",
            "        }",
            "    }",
            "    bool empty() const { return !a[D - 1][0]; }",
            "    bool contains(int x) const { return (a[0][x >> 6] >> (x & 63)) & 1; }",
            "    void insert(int x) {",
            "        for(int i = 0; i < D; i++) {",
            "            const int y = x & 63;",
            "            x >>= 6;",
            "            a[i][x] |= 1ULL << y;",
            "        }",
            "    }",
            "    void erase(int x) {",
            "        for(int i = 0; i < D; i++) {",
            "            const int y = x & 63;",
            "            x >>= 6;",
            "            if((a[i][x] &= ~(1ULL << y))) break;",
            "        }",
            "    }",
            "    int next(int x) const {             //smallest element >= x, returns 262144 if no such element",
            "        for(int i = 0; i < D; i++) {",
            "            const int k = x >> 6, y = x & 63;",
            "            if(k >= a[i].size()) return n;",
            "            const u64 top = a[i][k] >> y;",
            "            if(top) {",
            "                x += __builtin_ctzll(top);",
            "                for(int j = i - 1; j >= 0; --j) x = x << 6 | __builtin_ctzll(a[j][x]);",
            "                return x;",
            "            }",
            "            x = k + 1;",
            "        }",
            "        return n;",
            "    }",
            "    int prev(int x) const {            //largest element <= x",
            "        for(int i = 0; i < D; ++i) {",
            "            if(x < 0) return -1;",
            "            const int k = x >> 6, y = x & 63;",
            "            const u64 bot = a[i][k] << (63 - y);",
            "            if(bot) {",
            "                x -= __builtin_clzll(bot);",
            "                for(int j = i - 1; j >= 0; --j) x = x << 6 | (63 - __builtin_clzll(a[j][x]));",
            "                return x;",
            "            }",
            "            x = k - 1;",
            "        }",
            "        return -1;",
            "    }",
            "    int max() const { return prev(n); }",
            "    int min() const { return next(0); }",
            "};"
        ],
        "description": "Snippet for FastSet"
    },
    "TemplateRandomSuffixTree": {
        "prefix": "TemplateRandomSuffixTree",
        "body": [
            "template<typename C, typename L, typename G, typename R>",
            "class RandomSuffixTreeChan",
            "{",
            "    /*",
            "    info:",
            "        - Based on  https://welcome-to-the-sunny-side.github.io/2024/08/16/Funny-Way-To-Construct-Suffix-Tree.html ",
            "        - Generates suffix tree using the leader split technique for a set of strings numbered from 0 to n - 1",
            "        - bool compare(int i, int j, int x) returns true if x-length prefix of strings i and j is equal, and false otherwise",
            "        - int length(int i) returns length of ith string",
            "        - int get(int i, int x) returns the xth integer of string i (1 based indexing)",
            "        - rng just needs to have rng(x) generating random integer in [0, x)",
            "    warning:",
            "        - has been stress tested but its pretty slow and not optimized at all: https://judge.yosupo.jp/submission/237581",
            "    */",
            "public:",
            "    int n, root;",
            "    vector<int> dep;",
            "    vector<int> nid;",
            "    vector<int> rep;",
            "    vector<vector<int>> adj;",
            "",
            "    RandomSuffixTreeChan(int n, C compare, L length, G get, R rng) : ",
            "    n(n), dep(2 * n + 5), nid(2 * n + 5), rep(2 * n + 5, -1), adj(2 * n + 5)",
            "    {",
            "        vector<int> alive(n);",
            "        iota(alive.begin(), alive.end(), 0);",
            "",
            "        int timer = n - 1;",
            "        vector<int> dis(2 * n + 5);",
            "        vector<int> brk(2 * n + 5);",
            "",
            "        auto construct = [&](vector<int> a, auto &&construct) -> int",
            "        {",
            "            assert(!a.empty());",
            "",
            "            if(a.size() == 1)",
            "            {",
            "                int u = a[0];",
            "                nid[u] = u;",
            "                rep[u] = u;",
            "                return a[0];",
            "            }",
            "",
            "            int l = a[rng(a.size())];",
            "            a.erase(find(a.begin(), a.end(), l));",
            "            dis[l] = length(l);",
            "",
            "            for(auto v : a)",
            "            {",
            "                dis[v] = 0;",
            "                int s = 1, e = min(dis[l], length(v));",
            "                while(s <= e)",
            "                {",
            "                    int mid = (s + e)/2;",
            "                    if(compare(l, v, mid))",
            "                        s = mid + 1, dis[v] = mid;",
            "                    else",
            "                        e = mid - 1;",
            "                }",
            "            }",
            "",
            "            sort(a.begin(), a.end(), [&](int i, int j) {return dis[i] > dis[j];});",
            "            a.insert(a.begin(), l);",
            "",
            "            vector<int> nodes;",
            "",
            "            while(!a.empty())",
            "            {",
            "                int len = dis[a.back()];",
            "                vector<int> split;",
            "",
            "                int node = -1;",
            "",
            "                while(!a.empty() and dis[a.back()] == len)",
            "                {",
            "                    if(length(a.back()) == len)",
            "                    {",
            "                        if(node == -1)",
            "                            node = a.back(), rep[node] = node;",
            "                        nid[a.back()] = node;",
            "                    }",
            "                    else",
            "                        split.push_back(a.back());",
            "                    a.pop_back();",
            "                }",
            "",
            "                if(node == -1)",
            "                    node = ++ timer;",
            "",
            "                dep[node] = len;",
            "",
            "                for(auto u : split)",
            "                    brk[u] = get(u, len + 1);",
            "                ",
            "                sort(split.begin(), split.end(), [&](int i, int j) {return brk[i] < brk[j];});",
            "                ",
            "                for(int i = 0; i < split.size();)",
            "                {",
            "                    int j = i;",
            "                    while(j < split.size() and brk[split[i]] == brk[split[j]])",
            "                        ++ j;",
            "                    ",
            "                    vector<int> hsplit;",
            "                    for(int k = i; k < j; k ++)",
            "                        hsplit.push_back(split[k]);",
            "                    ",
            "                    int child = construct(hsplit, construct);",
            "",
            "                    adj[node].push_back(child);",
            "                    rep[node] = max(rep[node], rep[child]);",
            "",
            "                    i = j;",
            "                }",
            "              ",
            "                nodes.push_back(node);",
            "            }",
            "",
            "            for(int i = 0; i < nodes.size() - 1; i ++)",
            "            {",
            "                adj[nodes[i]].push_back(nodes[i + 1]);",
            "                rep[nodes[i]] = max(rep[nodes[i]], rep[nodes[i + 1]]);",
            "            }",
            "",
            "            return nodes.front();",
            "        };",
            "        root = construct(alive, construct);",
            "",
            "        if(dep[root] != 0)",
            "        {",
            "            int new_root = ++ timer;",
            "            adj[new_root].push_back(root);",
            "            dep[new_root] = 0;",
            "            rep[new_root] = rep[root];",
            "            root = new_root;",
            "        }",
            "",
            "        for(int u = 0; u < adj.size(); u ++)",
            "        {",
            "            for(auto v : adj[u])",
            "                brk[v] = get(rep[v], dep[u] + 1);",
            "",
            "            sort(adj[u].begin(), adj[u].end(), ",
            "            [&](int i, int j) {return brk[i] < brk[j];});",
            "        }",
            "    };",
            "};"
        ],
        "description": "Snippet for RandomSuffixTree"
    },
    "TemplateSCC": {
        "prefix": "TemplateSCC",
        "body": [
            "class CondenserChan",
            "{",
            "    /*",
            "    tc: O(n + m)",
            "    ml: O(n + m)",
            "",
            "    info:",
            "        0-indexed    ",
            "        SCC u occurs before SCC v (u < v) in some topological ordering of SCCs ",
            "",
            "    warning: ",
            "        there may be multiple edges between different SCCs",
            "",
            "    var:",
            "        [n -> number of nodes]",
            "        [c -> number of SCCs]",
            "        [comp[u] -> component number of node u]",
            "        [scc[u] -> outedge list for scc u]",
            "        [grp[u] -> node list for scc u]",
            "    */",
            "public:",
            "    int n, c;",
            "    vector<bool> vis;",
            "    vector<int> stak, comp;",
            "    vector<vector<int>> adj, rdj, scc, grp;",
            "",
            "    CondenserChan(int n, const vector<vector<int>> &adj) :",
            "    n(n), c(0), vis(n), adj(adj), rdj(n), scc(n), grp(n), comp(n, -1) ",
            "    {",
            "        for(int u = 0; u < n; u ++)",
            "            for(auto v : adj[u])",
            "                rdj[v].push_back(u);",
            "    };",
            "",
            "    void Condense()",
            "    {",
            "        auto dfs1 = [&](int u, auto &&dfs1) -> void ",
            "        {",
            "            vis[u] = true;",
            "            for(auto v : adj[u])",
            "                if(!vis[v])",
            "                    dfs1(v, dfs1);",
            "            stak.push_back(u);",
            "        };",
            "        for(int u = 0; u < n; u ++)",
            "            if(!vis[u])",
            "                dfs1(u, dfs1);",
            "",
            "        auto dfs2 = [&](int u, auto &&dfs2) -> void ",
            "        {",
            "            comp[u] = c;",
            "            for(auto v : rdj[u])",
            "                if(comp[v] == -1)",
            "                    dfs2(v, dfs2);",
            "        };",
            "",
            "        reverse(stak.begin(), stak.end());",
            "        for(auto u : stak)",
            "            if(comp[u] == -1)",
            "                dfs2(u, dfs2), ++ c;",
            "",
            "        for(int u = 0; u < n; u ++)",
            "            for(auto v : adj[u])",
            "                if(comp[u] != comp[v])",
            "                    scc[comp[u]].push_back(comp[v]);",
            "",
            "        for(int u = 0; u < n; u ++)",
            "            grp[comp[u]].push_back(u);",
            "    }",
            "",
            "    void Fix()      //remove multiple edges [O(m log(m))]",
            "    {",
            "        for(auto &v : scc)",
            "        {",
            "            sort(v.begin(), v.end());",
            "            v.erase(unique(v.begin(), v.end()), v.end());",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet for SCC"
    },
    "TemplateConnectivity": {
        "prefix": "TemplateConnectivity",
        "body": [
            "class ConnectivityChan",
            "{",
            "public:",
            "    int n;",
            "    vector<vector<int>> adj;",
            "    int timer;",
            "    vector<int> tin, low;",
            "",
            "    vector<pair<int, int>> bridge;",
            "",
            "    int a;",
            "    vector<bool> cut;",
            "",
            "    int m;",
            "    vector<vector<int>> bcc;",
            "",
            "    int b;",
            "    vector<int> block_node_id;",
            "    vector<int> cut_node_id;",
            "    vector<vector<int>> bct_comp;    ",
            "    vector<vector<int>> bct;",
            "",
            "    ConnectivityChan(const vector<vector<int>> &adj) : n(adj.size()), m(n), adj(adj), timer(0), tin(n, -1), low(n, -1), cut(n), bcc(n) ",
            "    {",
            "        ComputeConnectivity();",
            "        MakeBlockCutTree();",
            "    };",
            "",
            "    void ComputeConnectivity()",
            "    {",
            "        vector<bool> vis(n);",
            "        vector<int> stk;",
            "",
            "        auto dfs = [&](int u, int p, auto &&dfs) -> void",
            "        {",
            "            tin[u] = low[u] = timer ++;",
            "            vis[u] = true;",
            "            stk.push_back(u);",
            "",
            "            int ptimes = 0;",
            "            int children = 0;",
            "            for(auto v : adj[u])",
            "            {",
            "                if(v == p)",
            "                {",
            "                    ++ ptimes;",
            "                    continue;",
            "                }",
            "",
            "                if(vis[v])",
            "                    low[u] = min(low[u], tin[v]);",
            "                else",
            "                {",
            "                    ++ children;",
            "                    int s = stk.size();",
            "                    dfs(v, u, dfs);",
            "                    low[u] = min(low[u], low[v]);",
            "",
            "                    if((p == -1 and children > 1) or (p != -1 and tin[u] <= low[v]))",
            "                    {",
            "                        cut[u] = true;",
            "                        bcc.push_back(vector<int> ());",
            "                        bcc[m].push_back(u);",
            "                        while(stk.size() > s)",
            "                        {",
            "                            bcc[m].push_back(stk.back());",
            "                            stk.pop_back();",
            "                        }",
            "                        ++ m;",
            "                    }",
            "                }",
            "            ",
            "            }",
            "",
            "            if(p != -1 and ptimes <= 1 and low[u] > tin[p])",
            "                bridge.emplace_back(min(u, p), max(u, p));",
            "        };",
            "        for(int u = 0; u < n; u ++)",
            "            if(!vis[u])",
            "            {",
            "                dfs(u, -1, dfs);",
            "                bcc.push_back(vector<int> ());",
            "                while(!stk.empty())",
            "                {",
            "                    bcc[m].push_back(stk.back());",
            "                    stk.pop_back();",
            "                }",
            "                ++ m;",
            "            }",
            "        a = count(cut.begin(), cut.end(), true);",
            "    }",
            "",
            "    void MakeBlockCutTree()",
            "    {",
            "        b = (m - n) + a;",
            "        bct_comp.assign(b, vector<int>());",
            "",
            "        for(int i = n; i < m; i ++)",
            "        {",
            "            bct_comp[i - n] = bcc[i];",
            "            for(auto u : bct_comp[i - n])",
            "                block_node_id[u] = i - n;",
            "        }",
            "",
            "        vector<int> cut_list;",
            "        for(int i = 0; i < n; i ++)",
            "            if(cut[i])",
            "                cut_list.push_back(i);",
            "            ",
            "        for(int i = m - n; i < m - n + a; i ++)",
            "        {",
            "            bct_comp[i] = {cut_list[i - (m - n)]};",
            "            for(auto u : bct_comp[i])",
            "                cut_node_id[u] = i;",
            "        }",
            "",
            "        for(int i = 0; i < m - n; i ++)",
            "            for(auto u : bct_comp[i - n])",
            "                if(cut[u])",
            "                    bct[i].push_back(cut_node_id[u]), bct[cut_node_id[u]].push_back(i);",
            "    }",
            "};"
        ],
        "description": "Snippet for Connectivity"
    },
    "TemplateDijkstras": {
        "prefix": "TemplateDijkstras",
        "body": [
            "template<typename T, T zero, T inf>",
            "vector<T> DijkstrasChan(int source, const vector<vector<pair<int, T>>> &adj)",
            "{",
            "    int n = adj.size();",
            "    vector<T> dis(n, inf);",
            "    dis[source] = zero;",
            "",
            "    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;",
            "    q.emplace(dis[source], source);",
            "",
            "    while(!q.empty())",
            "    {",
            "        auto [d, u] = q.top();",
            "        q.pop();",
            "        if(d > dis[u])",
            "            continue;",
            "        for(auto [v, w] : adj[u])",
            "            if(d + w < dis[v])",
            "                dis[v] = d + w, q.emplace(dis[v], v); ",
            "    }",
            "",
            "    return dis;",
            "}"
        ],
        "description": "Snippet for Dijkstras"
    },
    "TemplateHeavyLight": {
        "prefix": "TemplateHeavyLight",
        "body": [
            "template <typename I, typename T, template<typename, typename> typename S, const bool on_edge>",
            "class HeavyLightChan",
            "{",
            "    /*",
            "        info:",
            "            - 0 indexed",
            "            - range [pos[u], out[u]) represents subtree of u",
            "        vars:",
            "            - I: Info struct of segment tree",
            "            - T: Lazy Tag struct of segment tree",
            "            - S: segment tree class (S must support S<I, T>)",
            "            - r = tree root",
            "            - on_edge = true => values on edges. Internally, value of edge is stored at lower node",
            "        warning:",
            "            - handle segtree initialization correctly",
            "            - monoid operations must be commutative here",
            "                (implement directed path queries later)",
            "    */",
            "public:",
            "    int n, r;",
            "    vector<int> par, heavy, dep, root, pos, out;",
            "    S<I, T> tree;",
            "",
            "    HeavyLightChan(int n, int r, vector<vector<int>> adj) :",
            "    n(n), r(r), par(n, -1), heavy(n, -1), dep(n), root(n), pos(n), out(n),",
            "    tree(n + 1)",
            "    {",
            "        assert(r < n);",
            "",
            "        auto dfs_sz = [&](int u, auto &&dfs) -> int",
            "        {",
            "            int ss = 1, m = 0;",
            "            for(auto &v : adj[u])",
            "                if(v != par[u])",
            "                {",
            "                    par[v] = u, dep[v] = dep[u] + 1;",
            "                    int s = dfs(v, dfs);",
            "                    ss += s;",
            "                    if(s > m)",
            "                        heavy[u] = v, m = s, swap(adj[u][0], v);",
            "                }",
            "            return ss;",
            "        };",
            "        int timer = 0;",
            "        auto dfs_hld = [&](int u, auto &&dfs) -> void",
            "        {",
            "            pos[u] = timer ++;",
            "            for(auto v : adj[u])",
            "                if(v != par[u])",
            "                    root[v] = (heavy[u] == v ? root[u] : v), dfs(v, dfs);",
            "            out[u] = timer;",
            "        };",
            "        par[r] = -1, dep[r] = 0, root[r] = r;",
            "        dfs_sz(r, dfs_sz), dfs_hld(r, dfs_hld);",
            "    };",
            "",
            "    int LCA(int u, int v)",
            "    {",
            "        for (; root[u] != root[v]; v = par[root[v]])",
            "            if (dep[root[u]] > dep[root[v]])",
            "                swap(u, v);",
            "        return (dep[u] < dep[v] ? u : v);",
            "    }",
            "",
            "    template <typename O>",
            "    void ProcessPath(int u, int v, O op)",
            "    {",
            "        for (; root[u] != root[v]; v = par[root[v]])",
            "        {",
            "            if (dep[root[u]] > dep[root[v]])",
            "                swap(u, v);",
            "            op(pos[root[v]], pos[v]);",
            "        }",
            "        if (dep[u] > dep[v])",
            "            swap(u, v);",
            "        ",
            "        if(!on_edge)",
            "            op(pos[u], pos[v]);",
            "        else if(u != v)",
            "            op(pos[u] + 1, pos[v]);",
            "    }",
            "    ",
            "    void Set(int v, const I &info)",
            "    {",
            "        tree.Set(pos[v], info);",
            "    }",
            "    void ModifyPath(int u, int v, const T &tag)",
            "    {",
            "        ProcessPath(u, v, [this, &tag](int l, int r)  {tree.Modify(l, r, tag);});",
            "    }",
            "    void ModifySubtree(int u, const T &tag)",
            "    {",
            "        if(!on_edge)",
            "            tree.Modify(pos[u], out[u] - 1, tag);",
            "        else if(pos[u] < out[u] - 1)",
            "            tree.Modify(pos[u] + 1, out[u] - 1, tag);",
            "    }",
            "",
            "    I Get(int v)",
            "    {",
            "        return tree.Get(pos[v]);",
            "    }",
            "    I QueryPath(int u, int v)",
            "    {",
            "        I res = I();",
            "        ProcessPath(u, v, [this, &res](int l, int r)    {res.Join(tree.Query(l, r));});",
            "        return res;",
            "    }",
            "    I QuerySubtree(int u)",
            "    {",
            "        if(on_edge)",
            "            return (pos[u] < out[u] - 1 ? tree.Query(pos[u] + 1, out[u] - 1) : I());   ",
            "        return tree.Query(pos[u], out[u] - 1);",
            "    }",
            "};"
        ],
        "description": "Snippet for HeavyLight"
    },
    "TemplateBinaryLifter": {
        "prefix": "TemplateBinaryLifter",
        "body": [
            "class BinaryLifterChan",
            "{",
            "    /*",
            "    tc: O(n logn) preprocessing, O(logn) query",
            "    ml: O(n logn)",
            "",
            "    info:",
            "        1 indexed",
            "        n -> number of nodes",
            "        dep[u] -> depth of node u",
            "        tin[u], tout[u] -> intime, outtime of node u",
            "        up[u][i] -> stores 2^ith ancestor of u",
            "    */",
            "public:",
            "    int n, L, timer;",
            "    vector<int> dep, tin, tout;",
            "    vector<vector<int>> up;",
            "",
            "    BinaryLifterChan(int n, int r, const vector<vector<int>> &adj) : ",
            "    n(n), L(ceil(log2(n)) + 1), timer(0), dep(n), tin(n), tout(n), up(n, vector<int> (L, r))",
            "    {",
            "        timer = 0;",
            "        dep[r] = 0;",
            "        Dfs(r, r, adj);",
            "    }",
            "",
            "    void Dfs(int u, int p, const vector<vector<int>> &adj)",
            "    {",
            "        tin[u] = ++ timer;",
            "        up[u][0] = p;",
            " ",
            "        for(int i = 1; i < L; ++i)",
            "            up[u][i] = up[up[u][i - 1]][i - 1];",
            " ",
            "        for(auto v : adj[u])",
            "            if (v != p)",
            "                dep[v] = dep[u] + 1, Dfs(v, u, adj);",
            "",
            "        tout[u] = ++ timer;",
            "    }",
            "",
            "    int GetKth(int v, int k)",
            "    {",
            "        if(k != 0)",
            "            for(int i = L - 1; i >= 0 and v > 0; i --)",
            "                if((1 << i) <= k)",
            "                    k -= (1 << i), v = up[v][i];",
            "        return v;",
            "    }",
            "",
            "    bool IsAnc(int anc, int v)",
            "    {",
            "        return tin[anc] <= tin[v] and tout[v] <= tout[anc];",
            "    }",
            "",
            "    int LCA(int u, int v)",
            "    {",
            "        if (IsAnc(u, v))",
            "            return u;",
            "        if (IsAnc(v, u))",
            "            return v;",
            "        for (int i = L - 1; i >= 0; --i) ",
            "            if (!IsAnc(up[u][i], v))",
            "                u = up[u][i];",
            "        return up[u][0];",
            "    }",
            "};"
        ],
        "description": "Snippet for BinaryLifter"
    },
    "TemplateLevelAncestor": {
        "prefix": "TemplateLevelAncestor",
        "body": [
            "//wip",
            "class LevelAncestorChan",
            "{",
            "public:",
            "    int n;",
            "    vector<int> tin;",
            "    vector<int> tout;",
            "    vector<int> heavy;",
            "",
            "    LevelAncestorChan(int n, int r, const vector<vector<int>> &tree) : ",
            "    n(n), heavy(n + 1), tin(n + 1), tout(n + 1)",
            "    {",
            "        auto adj = tree;",
            "        vector<int> sz(n + 1, 0);",
            "        auto dfs1 = [&](int u, int p, auto &&dfs) -> void",
            "        {",
            "            sz[u] = 1;",
            "            if(p != 0)",
            "                adj[u].erase(find(adj[u].begin(), adj[u].end(), p));",
            "            for(auto v : adj[u])",
            "                dfs(v, u, dfs), sz[u] += sz[v];",
            "            if(!adj[u].empty())",
            "            {",
            "                auto mit = *max_element(adj[u].begin(), adj[u].end(), [&](int v1, int v2) {return sz[v1] < sz[v2];});",
            "                swap(*adj[u].begin(), mit);",
            "            }",
            "        };",
            "        dfs1(r, 0, dfs1);",
            "",
            "        int timer = 0;",
            "        auto dfs2 = [&](int u, int p, auto &&dfs) -> void",
            "        {",
            "            tin[]",
            "        };",
            "    };",
            "",
            "    bool IsAnc(int a, int u)",
            "    {",
            "        return tin[a] <= tin[u] and tout[u] <= tout[a];",
            "    }",
            "",
            "    int Lca(int u, int v)",
            "    {",
            "",
            "    }",
            "",
            "    int GetAncestor(int u, int k)",
            "    {",
            "",
            "    }",
            "};"
        ],
        "description": "Snippet for LevelAncestor"
    },
    "TemplateVirtualTree": {
        "prefix": "TemplateVirtualTree",
        "body": [
            "template <typename L>",
            "vector<pair<int, int>> VirtualTreeChan(vector<int> key, const vector<int> &tin, const vector<int> &tout, L &lca)",
            "{",
            "    assert(!key.empty());",
            "    sort(key.begin(), key.end(), [&](int a, int b)  { return tin[a] < tin[b]; });",
            "",
            "    vector<int> l;",
            "    for (int i = 0; i < key.size() - 1; i++)",
            "        l.push_back(lca.LCA(key[i], key[i + 1]));",
            "    ",
            "    for (auto p : l)",
            "        key.push_back(p);",
            "    sort(key.begin(), key.end(), [&](int a, int b)  { return tin[a] < tin[b]; });",
            "    key.erase(unique(key.begin(), key.end()), key.end());",
            "    reverse(key.begin(), key.end());",
            "",
            "    // stk contains path from root to current node, key contains unvisited nodes",
            "    stack<int> stk;",
            "    vector<pair<int, int>> edge;",
            "",
            "    stk.push(key.back());",
            "    key.pop_back();",
            "",
            "    while (!stk.empty())",
            "    {",
            "        int u = stk.top();",
            "        if (!key.empty() and tin[u] <= tin[key.back()] and tout[key.back()] <= tout[u])",
            "        {",
            "            edge.push_back(make_pair(u, key.back()));",
            "            stk.push(key.back());",
            "            key.pop_back();",
            "            continue;",
            "        }",
            "        stk.pop();",
            "    }",
            "",
            "    return edge;",
            "};"
        ],
        "description": "Snippet for VirtualTree"
    },
    "TemplateOfflineLCA": {
        "prefix": "TemplateOfflineLCA",
        "body": [
            "vector<int> OfflineLCAChan(int n, int r, const vector<vector<int>> &adj, vector<pair<int, int>> query)",
            "{",
            "    //dsu",
            "    vector<int> par(n), siz(n, 1);",
            "    iota(par.begin(), par.end(), 0);",
            "    auto get = [&](int u, auto &&get) -> int",
            "    {",
            "        return (par[u] == u ? u : par[u] = get(par[u], get));",
            "    };",
            "    auto unite = [&](int u, int v) -> void",
            "    {",
            "        u = get(u, get), v = get(v, get);",
            "        if(u == v)",
            "            return;",
            "        if(siz[u] < siz[v])",
            "            swap(u, v);",
            "        par[v] = u, siz[u] += siz[v];",
            "    };",
            "",
            "    assert(!query.empty());",
            "    int m = query.size();",
            "    ",
            "    vector<int> ans(m);",
            "    vector<bool> see(m);",
            "    vector<vector<int>> store(n);",
            "",
            "    for(int i = 0; i < m; i ++)",
            "    {",
            "        auto [u, v] = query[i];",
            "        store[u].push_back(i), store[v].push_back(i);",
            "    }",
            "",
            "    auto dfs = [&](int u, int p, auto &&dfs) -> void",
            "    {",
            "        for(auto i : store[u])",
            "        {",
            "            if(see[i])",
            "                ans[i] = get(query[i].first == u ? query[i].second : query[i].first, get);",
            "            see[i] = true;",
            "        }",
            "",
            "        for(auto v : adj[u])",
            "            if(v != p)",
            "                dfs(v, u, dfs);",
            "",
            "        if(p != 0)",
            "            unite(u, p);",
            "    };",
            "    dfs(r, 0, dfs);",
            "    ",
            "    return ans;",
            "};"
        ],
        "description": "Snippet for OfflineLCA"
    },
    "TemplateBipartite": {
        "prefix": "TemplateBipartite",
        "body": [
            "class BipartiteChan",
            "{",
            "    /*",
            "        tc: O(E sqrt(V))",
            "        mc: O(V + E)",
            "",
            "        vars:",
            "            n, m: size of left and right partitions",
            "            adj: left to right edges ONLY",
            "        info:",
            "            Both partitions are individually 1 indexed",
            "            After calling MaxMatching():",
            "                - matching = size of max matching",
            "                - l[u] = matched right node for u (l[u] = -1 => unmatched)",
            "                - r[u] = matched left node for u (r[u] = -1 => unmatched)",
            "            MVC is found by:",
            "                - orienting matched edges from right to left, unmatched opposite",
            "                - running dfs from all unmatched left side nodes",
            "                - (unvis nodes on the left) + (visited nodes on right) = mvc",
            "            MIS is complement of MVC",
            "    */",
            "public:",
            "    int n, m;",
            "    int matching = 0;",
            "    vector<vector<int>> adj;",
            "    vector<int> l, r, lvl;",
            "    BipartiteChan(int n, int m, const vector<vector<int>> &adj) : ",
            "        n(n), m(m), l(n, -1), r(m, -1), adj(adj) {};",
            "",
            "    // void Add(int u, int v)  { adj[u].push_back(v); }",
            "    bool Dfs(int u)",
            "    {",
            "        int t = exchange(lvl[u], -1) + 1;",
            "        for (int v : adj[u])",
            "            if (r[v] == -1 or (lvl[r[v]] == t and Dfs(r[v])))",
            "                return l[u] = v, r[v] = u, 1;",
            "        return 0;",
            "    }",
            "",
            "    int MaxMatching()",
            "    {",
            "        matching = 0;   ",
            "        vector<int> q(n);",
            "        for (int s = 0, t = 0;; s = t = 0)",
            "        {",
            "            lvl = vector<int>(n);   bool f = 0;",
            "            for(int i = 0; i < n; i ++) ",
            "                if (l[i] == -1) ",
            "                    lvl[i] = 1, q[t ++] = i;",
            "            ",
            "            while (s < t)",
            "            {",
            "                int u = q[ s++];",
            "                for (int v : adj[u])",
            "                {",
            "                    int x = r[v];",
            "                    if (x == -1)",
            "                        f = 1;",
            "                    else if (!lvl[x])",
            "                        lvl[x] = lvl[u] + 1, q[t++] = x;",
            "                }",
            "            }",
            "",
            "            if (!f)",
            "                break;",
            "            ",
            "            for(int i = 0; i < n; i ++) ",
            "                if (l[i] == -1) ",
            "                    matching += Dfs(i);",
            "        }",
            "        return matching;",
            "    }",
            "",
            "    vector<pair<int, int>> MaxMatchingEdges()",
            "    {",
            "        vector<pair<int, int>> mme;",
            "        for(int u = 0; u < n; u ++)",
            "            if(l[u] != -1)",
            "                mme.push_back(make_pair(u, l[u]));",
            "        return mme;",
            "    }",
            "    ",
            "    pair<vector<int>, vector<int>> MinVertexCover()",
            "    {",
            "        vector<bool> lv(n, false), rv(m, false);",
            "        ",
            "        auto dfs = [&](int u, auto &&dfs) -> void",
            "        {",
            "            lv[u] = true;",
            "            for(auto v : adj[u])",
            "                if(r[v] != u and !rv[v])",
            "                {",
            "                    rv[v] = true;",
            "                    if(r[v] != -1 and !lv[r[v]])",
            "                        dfs(r[v], dfs);",
            "                }",
            "        };",
            "        for(int u = 0; u < n; u ++)",
            "            if(l[u] == -1 and !lv[u])",
            "                dfs(u, dfs);",
            "",
            "        vector<int> lc, rc;",
            "        for(int u = 0; u < n; u ++)",
            "            if(!lv[u])",
            "                lc.push_back(u);",
            "        for(int u = 0; u < m; u ++)",
            "            if(rv[u])",
            "                rc.push_back(u);",
            "        ",
            "        assert(matching == (int)lc.size() + (int)rc.size());",
            "        return {lc, rc};",
            "    }",
            "};"
        ],
        "description": "Snippet for Bipartite"
    },
    "TemplateModIntVariable": {
        "prefix": "TemplateModIntVariable",
        "body": [
            "",
            "namespace atcoder",
            "{",
            "",
            "    namespace internal",
            "    {",
            "",
            "        // @param m `1 <= m`",
            "        // @return x mod m",
            "        constexpr long long safe_mod(long long x, long long m)",
            "        {",
            "            x %= m;",
            "            if (x < 0)",
            "                x += m;",
            "            return x;",
            "        }",
            "",
            "        // Fast modular multiplication by barrett reduction",
            "        // Reference: https://en.wikipedia.org/wiki/Barrett_reduction",
            "        // NOTE: reconsider after Ice Lake",
            "        struct barrett",
            "        {",
            "            unsigned int _m;",
            "            unsigned long long im;",
            "",
            "            // @param m `1 <= m`",
            "            explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}",
            "",
            "            // @return m",
            "            unsigned int umod() const { return _m; }",
            "",
            "            // @param a `0 <= a < m`",
            "            // @param b `0 <= b < m`",
            "            // @return `a * b % m`",
            "            unsigned int mul(unsigned int a, unsigned int b) const",
            "            {",
            "                // [1] m = 1",
            "                // a = b = im = 0, so okay",
            "",
            "                // [2] m >= 2",
            "                // im = ceil(2^64 / m)",
            "                // -> im * m = 2^64 + r (0 <= r < m)",
            "                // let z = a*b = c*m + d (0 <= c, d < m)",
            "                // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im",
            "                // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2",
            "                // ((ab * im) >> 64) == c or c + 1",
            "                unsigned long long z = a;",
            "                z *= b;",
            "#ifdef _MSC_VER",
            "                unsigned long long x;",
            "                _umul128(z, im, &x);",
            "#else",
            "                unsigned long long x =",
            "                    (unsigned long long)(((unsigned __int128)(z)*im) >> 64);",
            "#endif",
            "                unsigned long long y = x * _m;",
            "                return (unsigned int)(z - y + (z < y ? _m : 0));",
            "            }",
            "        };",
            "",
            "        // @param n `0 <= n`",
            "        // @param m `1 <= m`",
            "        // @return `(x ** n) % m`",
            "        constexpr long long pow_mod_constexpr(long long x, long long n, int m)",
            "        {",
            "            if (m == 1)",
            "                return 0;",
            "            unsigned int _m = (unsigned int)(m);",
            "            unsigned long long r = 1;",
            "            unsigned long long y = safe_mod(x, m);",
            "            while (n)",
            "            {",
            "                if (n & 1)",
            "                    r = (r * y) % _m;",
            "                y = (y * y) % _m;",
            "                n >>= 1;",
            "            }",
            "            return r;",
            "        }",
            "",
            "        // Reference:",
            "        // M. Forisek and J. Jancina,",
            "        // Fast Primality Testing for Integers That Fit into a Machine Word",
            "        // @param n `0 <= n`",
            "        constexpr bool is_prime_constexpr(int n)",
            "        {",
            "            if (n <= 1)",
            "                return false;",
            "            if (n == 2 || n == 7 || n == 61)",
            "                return true;",
            "            if (n % 2 == 0)",
            "                return false;",
            "            long long d = n - 1;",
            "            while (d % 2 == 0)",
            "                d /= 2;",
            "            constexpr long long bases[3] = {2, 7, 61};",
            "            for (long long a : bases)",
            "            {",
            "                long long t = d;",
            "                long long y = pow_mod_constexpr(a, t, n);",
            "                while (t != n - 1 && y != 1 && y != n - 1)",
            "                {",
            "                    y = y * y % n;",
            "                    t <<= 1;",
            "                }",
            "                if (y != n - 1 && t % 2 == 0)",
            "                {",
            "                    return false;",
            "                }",
            "            }",
            "            return true;",
            "        }",
            "        template <int n>",
            "        constexpr bool is_prime = is_prime_constexpr(n);",
            "",
            "        // @param b `1 <= b`",
            "        // @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g",
            "        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b)",
            "        {",
            "            a = safe_mod(a, b);",
            "            if (a == 0)",
            "                return {b, 0};",
            "",
            "            // Contracts:",
            "            // [1] s - m0 * a = 0 (mod b)",
            "            // [2] t - m1 * a = 0 (mod b)",
            "            // [3] s * |m1| + t * |m0| <= b",
            "            long long s = b, t = a;",
            "            long long m0 = 0, m1 = 1;",
            "",
            "            while (t)",
            "            {",
            "                long long u = s / t;",
            "                s -= t * u;",
            "                m0 -= m1 * u; // |m1 * u| <= |m1| * s <= b",
            "",
            "                // [3]:",
            "                // (s - t * u) * |m1| + t * |m0 - m1 * u|",
            "                // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)",
            "                // = s * |m1| + t * |m0| <= b",
            "",
            "                auto tmp = s;",
            "                s = t;",
            "                t = tmp;",
            "                tmp = m0;",
            "                m0 = m1;",
            "                m1 = tmp;",
            "            }",
            "            // by [3]: |m0| <= b/g",
            "            // by g != b: |m0| < b/g",
            "            if (m0 < 0)",
            "                m0 += b / s;",
            "            return {s, m0};",
            "        }",
            "",
            "        // Compile time primitive root",
            "        // @param m must be prime",
            "        // @return primitive root (and minimum in now)",
            "        constexpr int primitive_root_constexpr(int m)",
            "        {",
            "            if (m == 2)",
            "                return 1;",
            "            if (m == 167772161)",
            "                return 3;",
            "            if (m == 469762049)",
            "                return 3;",
            "            if (m == 754974721)",
            "                return 11;",
            "            if (m == 998244353)",
            "                return 3;",
            "            int divs[20] = {};",
            "            divs[0] = 2;",
            "            int cnt = 1;",
            "            int x = (m - 1) / 2;",
            "            while (x % 2 == 0)",
            "                x /= 2;",
            "            for (int i = 3; (long long)(i)*i <= x; i += 2)",
            "            {",
            "                if (x % i == 0)",
            "                {",
            "                    divs[cnt++] = i;",
            "                    while (x % i == 0)",
            "                    {",
            "                        x /= i;",
            "                    }",
            "                }",
            "            }",
            "            if (x > 1)",
            "            {",
            "                divs[cnt++] = x;",
            "            }",
            "            for (int g = 2;; g++)",
            "            {",
            "                bool ok = true;",
            "                for (int i = 0; i < cnt; i++)",
            "                {",
            "                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1)",
            "                    {",
            "                        ok = false;",
            "                        break;",
            "                    }",
            "                }",
            "                if (ok)",
            "                    return g;",
            "            }",
            "        }",
            "        template <int m>",
            "        constexpr int primitive_root = primitive_root_constexpr(m);",
            "",
            "        // @param n `n < 2^32`",
            "        // @param m `1 <= m < 2^32`",
            "        // @return sum_{i=0}^{n-1} floor((ai + b) / m) (mod 2^64)",
            "        unsigned long long floor_sum_unsigned(unsigned long long n,",
            "                                              unsigned long long m,",
            "                                              unsigned long long a,",
            "                                              unsigned long long b)",
            "        {",
            "            unsigned long long ans = 0;",
            "            while (true)",
            "            {",
            "                if (a >= m)",
            "                {",
            "                    ans += n * (n - 1) / 2 * (a / m);",
            "                    a %= m;",
            "                }",
            "                if (b >= m)",
            "                {",
            "                    ans += n * (b / m);",
            "                    b %= m;",
            "                }",
            "",
            "                unsigned long long y_max = a * n + b;",
            "                if (y_max < m)",
            "                    break;",
            "                // y_max < m * (n + 1)",
            "                // floor(y_max / m) <= n",
            "                n = (unsigned long long)(y_max / m);",
            "                b = (unsigned long long)(y_max % m);",
            "                std::swap(m, a);",
            "            }",
            "            return ans;",
            "        }",
            "",
            "    } // namespace internal",
            "",
            "} // namespace atcoder",
            "namespace atcoder",
            "{",
            "",
            "    namespace internal",
            "    {",
            "",
            "#ifndef _MSC_VER",
            "        template <class T>",
            "        using is_signed_int128 =",
            "            typename std::conditional<std::is_same<T, __int128_t>::value ||",
            "                                          std::is_same<T, __int128>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_unsigned_int128 =",
            "            typename std::conditional<std::is_same<T, __uint128_t>::value ||",
            "                                          std::is_same<T, unsigned __int128>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using make_unsigned_int128 =",
            "            typename std::conditional<std::is_same<T, __int128_t>::value,",
            "                                      __uint128_t,",
            "                                      unsigned __int128>;",
            "",
            "        template <class T>",
            "        using is_integral = typename std::conditional<std::is_integral<T>::value ||",
            "                                                          is_signed_int128<T>::value ||",
            "                                                          is_unsigned_int128<T>::value,",
            "                                                      std::true_type,",
            "                                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_signed_int = typename std::conditional<(is_integral<T>::value &&",
            "                                                         std::is_signed<T>::value) ||",
            "                                                            is_signed_int128<T>::value,",
            "                                                        std::true_type,",
            "                                                        std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_unsigned_int =",
            "            typename std::conditional<(is_integral<T>::value &&",
            "                                       std::is_unsigned<T>::value) ||",
            "                                          is_unsigned_int128<T>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using to_unsigned = typename std::conditional<",
            "            is_signed_int128<T>::value,",
            "            make_unsigned_int128<T>,",
            "            typename std::conditional<std::is_signed<T>::value,",
            "                                      std::make_unsigned<T>,",
            "                                      std::common_type<T>>::type>::type;",
            "",
            "#else",
            "",
            "        template <class T>",
            "        using is_integral = typename std::is_integral<T>;",
            "",
            "        template <class T>",
            "        using is_signed_int =",
            "            typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_unsigned_int =",
            "            typename std::conditional<is_integral<T>::value &&",
            "                                          std::is_unsigned<T>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using to_unsigned = typename std::conditional<is_signed_int<T>::value,",
            "                                                      std::make_unsigned<T>,",
            "                                                      std::common_type<T>>::type;",
            "",
            "#endif",
            "",
            "        template <class T>",
            "        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
            "",
            "        template <class T>",
            "        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
            "",
            "        template <class T>",
            "        using to_unsigned_t = typename to_unsigned<T>::type;",
            "",
            "    } // namespace internal",
            "",
            "} // namespace atcoder",
            "namespace atcoder",
            "{",
            "",
            "    namespace internal",
            "    {",
            "",
            "        struct modint_base",
            "        {",
            "        };",
            "        struct static_modint_base : modint_base",
            "        {",
            "        };",
            "",
            "        template <class T>",
            "        using is_modint = std::is_base_of<modint_base, T>;",
            "        template <class T>",
            "        using is_modint_t = std::enable_if_t<is_modint<T>::value>;",
            "",
            "    } // namespace internal",
            "",
            "    template <int m, std::enable_if_t<(1 <= m)> * = nullptr>",
            "    struct static_modint : internal::static_modint_base",
            "    {",
            "        using mint = static_modint;",
            "",
            "    public:",
            "        static constexpr int mod() { return m; }",
            "        static mint raw(int v)",
            "        {",
            "            mint x;",
            "            x._v = v;",
            "            return x;",
            "        }",
            "",
            "        static_modint() : _v(0) {}",
            "        template <class T, internal::is_signed_int_t<T> * = nullptr>",
            "        static_modint(T v)",
            "        {",
            "            long long x = (long long)(v % (long long)(umod()));",
            "            if (x < 0)",
            "                x += umod();",
            "            _v = (unsigned int)(x);",
            "        }",
            "        template <class T, internal::is_unsigned_int_t<T> * = nullptr>",
            "        static_modint(T v)",
            "        {",
            "            _v = (unsigned int)(v % umod());",
            "        }",
            "",
            "        unsigned int val() const { return _v; }",
            "",
            "        mint &operator++()",
            "        {",
            "            _v++;",
            "            if (_v == umod())",
            "                _v = 0;",
            "            return *this;",
            "        }",
            "        mint &operator--()",
            "        {",
            "            if (_v == 0)",
            "                _v = umod();",
            "            _v--;",
            "            return *this;",
            "        }",
            "        mint operator++(int)",
            "        {",
            "            mint result = *this;",
            "            ++*this;",
            "            return result;",
            "        }",
            "        mint operator--(int)",
            "        {",
            "            mint result = *this;",
            "            --*this;",
            "            return result;",
            "        }",
            "",
            "        mint &operator+=(const mint &rhs)",
            "        {",
            "            _v += rhs._v;",
            "            if (_v >= umod())",
            "                _v -= umod();",
            "            return *this;",
            "        }",
            "        mint &operator-=(const mint &rhs)",
            "        {",
            "            _v -= rhs._v;",
            "            if (_v >= umod())",
            "                _v += umod();",
            "            return *this;",
            "        }",
            "        mint &operator*=(const mint &rhs)",
            "        {",
            "            unsigned long long z = _v;",
            "            z *= rhs._v;",
            "            _v = (unsigned int)(z % umod());",
            "            return *this;",
            "        }",
            "        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "",
            "        mint operator+() const { return *this; }",
            "        mint operator-() const { return mint() - *this; }",
            "",
            "        mint pow(long long n) const",
            "        {",
            "            assert(0 <= n);",
            "            mint x = *this, r = 1;",
            "            while (n)",
            "            {",
            "                if (n & 1)",
            "                    r *= x;",
            "                x *= x;",
            "                n >>= 1;",
            "            }",
            "            return r;",
            "        }",
            "        mint inv() const",
            "        {",
            "            if (prime)",
            "            {",
            "                assert(_v);",
            "                return pow(umod() - 2);",
            "            }",
            "            else",
            "            {",
            "                auto eg = internal::inv_gcd(_v, m);",
            "                assert(eg.first == 1);",
            "                return eg.second;",
            "            }",
            "        }",
            "",
            "        friend mint operator+(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) += rhs;",
            "        }",
            "        friend mint operator-(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) -= rhs;",
            "        }",
            "        friend mint operator*(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) *= rhs;",
            "        }",
            "        friend mint operator/(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) /= rhs;",
            "        }",
            "        friend bool operator==(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v == rhs._v;",
            "        }",
            "        friend bool operator!=(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v != rhs._v;",
            "        }",
            "",
            "    private:",
            "        unsigned int _v;",
            "        static constexpr unsigned int umod() { return m; }",
            "        static constexpr bool prime = internal::is_prime<m>;",
            "    };",
            "",
            "    template <int id>",
            "    struct dynamic_modint : internal::modint_base",
            "    {",
            "        using mint = dynamic_modint;",
            "",
            "    public:",
            "        static int mod() { return (int)(bt.umod()); }",
            "        static void set_mod(int m)",
            "        {",
            "            assert(1 <= m);",
            "            bt = internal::barrett(m);",
            "        }",
            "        static mint raw(int v)",
            "        {",
            "            mint x;",
            "            x._v = v;",
            "            return x;",
            "        }",
            "",
            "        dynamic_modint() : _v(0) {}",
            "        template <class T, internal::is_signed_int_t<T> * = nullptr>",
            "        dynamic_modint(T v)",
            "        {",
            "            long long x = (long long)(v % (long long)(mod()));",
            "            if (x < 0)",
            "                x += mod();",
            "            _v = (unsigned int)(x);",
            "        }",
            "        template <class T, internal::is_unsigned_int_t<T> * = nullptr>",
            "        dynamic_modint(T v)",
            "        {",
            "            _v = (unsigned int)(v % mod());",
            "        }",
            "",
            "        unsigned int val() const { return _v; }",
            "",
            "        mint &operator++()",
            "        {",
            "            _v++;",
            "            if (_v == umod())",
            "                _v = 0;",
            "            return *this;",
            "        }",
            "        mint &operator--()",
            "        {",
            "            if (_v == 0)",
            "                _v = umod();",
            "            _v--;",
            "            return *this;",
            "        }",
            "        mint operator++(int)",
            "        {",
            "            mint result = *this;",
            "            ++*this;",
            "            return result;",
            "        }",
            "        mint operator--(int)",
            "        {",
            "            mint result = *this;",
            "            --*this;",
            "            return result;",
            "        }",
            "",
            "        mint &operator+=(const mint &rhs)",
            "        {",
            "            _v += rhs._v;",
            "            if (_v >= umod())",
            "                _v -= umod();",
            "            return *this;",
            "        }",
            "        mint &operator-=(const mint &rhs)",
            "        {",
            "            _v += mod() - rhs._v;",
            "            if (_v >= umod())",
            "                _v -= umod();",
            "            return *this;",
            "        }",
            "        mint &operator*=(const mint &rhs)",
            "        {",
            "            _v = bt.mul(_v, rhs._v);",
            "            return *this;",
            "        }",
            "        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "",
            "        mint operator+() const { return *this; }",
            "        mint operator-() const { return mint() - *this; }",
            "",
            "        mint pow(long long n) const",
            "        {",
            "            assert(0 <= n);",
            "            mint x = *this, r = 1;",
            "            while (n)",
            "            {",
            "                if (n & 1)",
            "                    r *= x;",
            "                x *= x;",
            "                n >>= 1;",
            "            }",
            "            return r;",
            "        }",
            "        mint inv() const",
            "        {",
            "            auto eg = internal::inv_gcd(_v, mod());",
            "            assert(eg.first == 1);",
            "            return eg.second;",
            "        }",
            "",
            "        friend mint operator+(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) += rhs;",
            "        }",
            "        friend mint operator-(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) -= rhs;",
            "        }",
            "        friend mint operator*(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) *= rhs;",
            "        }",
            "        friend mint operator/(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) /= rhs;",
            "        }",
            "        friend bool operator==(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v == rhs._v;",
            "        }",
            "        friend bool operator!=(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v != rhs._v;",
            "        }",
            "",
            "    private:",
            "        unsigned int _v;",
            "        static internal::barrett bt;",
            "        static unsigned int umod() { return bt.umod(); }",
            "    };",
            "    template <int id>",
            "    internal::barrett dynamic_modint<id>::bt(998244353);",
            "",
            "    using modint998244353 = static_modint<998244353>;",
            "    using modint1000000007 = static_modint<1000000007>;",
            "    using modint = dynamic_modint<-1>;",
            "",
            "    namespace internal",
            "    {",
            "",
            "        template <class T>",
            "        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;",
            "",
            "        template <class T>",
            "        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;",
            "",
            "        template <class>",
            "        struct is_dynamic_modint : public std::false_type",
            "        {",
            "        };",
            "        template <int id>",
            "        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type",
            "        {",
            "        };",
            "",
            "        template <class T>",
            "        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;",
            "",
            "    } // namespace internal",
            "",
            "} // namespace atcoder",
            "",
            "using mint = atcoder::dynamic_modint<-1>;",
            "// mint::set_mod(variable_mod)"
        ],
        "description": "Snippet for ModIntVariable"
    },
    "TemplateModInt": {
        "prefix": "TemplateModInt",
        "body": [
            "template <const int &MOD>",
            "struct Mint",
            "{",
            "    int val;",
            "",
            "    Mint(int64_t v = 0)",
            "    {",
            "        if (v < 0)",
            "            v = v % MOD + MOD;",
            "        if (v >= MOD)",
            "            v %= MOD;",
            "        val = int(v);",
            "    }",
            "",
            "    Mint(uint64_t v)",
            "    {",
            "        if (v >= MOD)",
            "            v %= MOD;",
            "        val = int(v);",
            "    }",
            "",
            "    Mint(int v) : Mint(int64_t(v)) {}",
            "    Mint(unsigned v) : Mint(uint64_t(v)) {}",
            "",
            "    explicit operator int() const { return val; }",
            "    explicit operator unsigned() const { return val; }",
            "    explicit operator int64_t() const { return val; }",
            "    explicit operator uint64_t() const { return val; }",
            "    explicit operator double() const { return val; }",
            "    explicit operator long double() const { return val; }",
            "",
            "    Mint &operator+=(const Mint &other)",
            "    {",
            "        val -= MOD - other.val;",
            "        if (val < 0)",
            "            val += MOD;",
            "        return *this;",
            "    }",
            "",
            "    Mint &operator-=(const Mint &other)",
            "    {",
            "        val -= other.val;",
            "        if (val < 0)",
            "            val += MOD;",
            "        return *this;",
            "    }",
            "",
            "    static unsigned fast_mod(uint64_t x, unsigned m = MOD)",
            "    {",
            "#if !defined(_WIN32) || defined(_WIN64)",
            "        return unsigned(x % m);",
            "#endif",
            "        // Optimized mod for Codeforces 32-bit machines.",
            "        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.",
            "        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);",
            "        unsigned quot, rem;",
            "        asm(\"divl %4\\\\n\"",
            "            : \"=a\"(quot), \"=d\"(rem)",
            "            : \"d\"(x_high), \"a\"(x_low), \"r\"(m));",
            "        return rem;",
            "    }",
            "",
            "    Mint &operator*=(const Mint &other)",
            "    {",
            "        val = fast_mod(uint64_t(val) * other.val);",
            "        return *this;",
            "    }",
            "",
            "    Mint &operator/=(const Mint &other)",
            "    {",
            "        return *this *= other.inv();",
            "    }",
            "",
            "    friend Mint operator+(const Mint &a, const Mint &b) { return Mint(a) += b; }",
            "    friend Mint operator-(const Mint &a, const Mint &b) { return Mint(a) -= b; }",
            "    friend Mint operator*(const Mint &a, const Mint &b) { return Mint(a) *= b; }",
            "    friend Mint operator/(const Mint &a, const Mint &b) { return Mint(a) /= b; }",
            "",
            "    Mint &operator++()",
            "    {",
            "        val = val == MOD - 1 ? 0 : val + 1;",
            "        return *this;",
            "    }",
            "",
            "    Mint &operator--()",
            "    {",
            "        val = val == 0 ? MOD - 1 : val - 1;",
            "        return *this;",
            "    }",
            "",
            "    Mint operator++(int)",
            "    {",
            "        Mint before = *this;",
            "        ++*this;",
            "        return before;",
            "    }",
            "    Mint operator--(int)",
            "    {",
            "        Mint before = *this;",
            "        --*this;",
            "        return before;",
            "    }",
            "",
            "    Mint operator-() const",
            "    {",
            "        return val == 0 ? 0 : MOD - val;",
            "    }",
            "",
            "    friend bool operator==(const Mint &a, const Mint &b) { return a.val == b.val; }",
            "    friend bool operator!=(const Mint &a, const Mint &b) { return a.val != b.val; }",
            "    friend bool operator<(const Mint &a, const Mint &b) { return a.val < b.val; }",
            "    friend bool operator>(const Mint &a, const Mint &b) { return a.val > b.val; }",
            "    friend bool operator<=(const Mint &a, const Mint &b) { return a.val <= b.val; }",
            "    friend bool operator>=(const Mint &a, const Mint &b) { return a.val >= b.val; }",
            "",
            "    static const int SAVE_INV = int(1e6) + 5;",
            "    static Mint save_inv[SAVE_INV];",
            "",
            "    static void prepare_inv()",
            "    {",
            "        // Ensures that MOD is prime, which is necessary for the inverse algorithm below.",
            "        for (int64_t p = 2; p * p <= MOD; p += p % 2 + 1)",
            "            assert(MOD % p != 0);",
            "",
            "        save_inv[0] = 0;",
            "        save_inv[1] = 1;",
            "",
            "        for (int i = 2; i < SAVE_INV; i++)",
            "            save_inv[i] = save_inv[MOD % i] * (MOD - MOD / i);",
            "    }",
            "",
            "    Mint inv() const",
            "    {",
            "        if (save_inv[1] == 0)",
            "            prepare_inv();",
            "",
            "        if (val < SAVE_INV)",
            "            return save_inv[val];",
            "",
            "        Mint product = 1;",
            "        int v = val;",
            "",
            "        do",
            "        {",
            "            product *= MOD - MOD / v;",
            "            v = MOD % v;",
            "        } while (v >= SAVE_INV);",
            "",
            "        return product * save_inv[v];",
            "    }",
            "",
            "    Mint pow(int64_t p) const",
            "    {",
            "        if (p < 0)",
            "            return inv().pow(-p);",
            "",
            "        Mint a = *this, result = 1;",
            "",
            "        while (p > 0)",
            "        {",
            "            if (p & 1)",
            "                result *= a;",
            "",
            "            p >>= 1;",
            "",
            "            if (p > 0)",
            "                a *= a;",
            "        }",
            "",
            "        return result;",
            "    }",
            "",
            "    friend ostream &operator<<(ostream &os, const Mint &m)",
            "    {",
            "        return os << m.val;",
            "    }",
            "};",
            "template <const int &MOD>",
            "Mint<MOD> Mint<MOD>::save_inv[Mint<MOD>::SAVE_INV];",
            "const int MOD = 998244353;",
            "using mint = Mint<MOD>;",
            "void __print(mint x) { cerr << x; }"
        ],
        "description": "Snippet for ModInt"
    },
    "TemplateCombinatorics": {
        "prefix": "TemplateCombinatorics",
        "body": [
            "template<typename T, const int P>",
            "class Combinatorics",
            "{",
            "public:",
            "    int n;",
            "    vector<T> inv, fac, ifac, pw;",
            "    Combinatorics (int n) : n(n), inv(n), fac(n), ifac(n), pw(n)",
            "    {",
            "        fac[0] = inv[0] = ifac[0] = pw[0] = T(1);",
            " ",
            "        for(int i = 1; i <= n; i ++)",
            "            inv[i] = T(1)/T(i), fac[i] = fac[i - 1] * T(i), ifac[i] = ifac[i - 1] * inv[i], pw[i] = pw[i - 1] * T(P);",
            "    }",
            "",
            "    T ncr(int n, int r)",
            "    {",
            "        if(n < r or r < 0)",
            "            return 0;",
            "        return fac[n] * ifac[r] * ifac[n - r];",
            "    }",
            "};"
        ],
        "description": "Snippet for Combinatorics"
    },
    "TemplateGaussianElimination": {
        "prefix": "TemplateGaussianElimination",
        "body": [
            "class GaussChan",
            "{",
            "public:",
            "    int d, sz;",
            "    vector<int> basis;",
            "",
            "    GaussChan (int d) : d(d), sz(0), basis(d) {};",
            "",
            "    void insert(int mask)",
            "    {",
            "        for(int i = 0; i < d; i ++) if(mask & (1 << i))",
            "        {",
            "            if(basis[i] == 0)",
            "            {",
            "                basis[i] = mask;",
            "                ++ sz;",
            "                break;",
            "            }",
            "            mask ^= basis[i];",
            "        }",
            "    }",
            "",
            "    void query()",
            "    {",
            "        //",
            "    }",
            "};"
        ],
        "description": "Snippet for GaussianElimination"
    },
    "TemplateConvexHullTrick": {
        "prefix": "TemplateConvexHullTrick",
        "body": [
            "class CHTChan",
            "{",
            "public:",
            "    /*",
            "        tc: O(log(n)) per insertion amortized, O(log(n)) per query",
            "        ml: O(n)",
            "",
            "        info:",
            "            1. inserts lines of form Ax + B",
            "            2. returns inserted line with maximum value of Ax + B for queried x ",
            "    */",
            "\tstatic const int64_t INF=1e18;",
            "\tstruct Line",
            "\t{",
            "\t\tint64_t a, b; //y = ax + b",
            "\t\tdouble xLeft; //Stores the llersection wiith previous line in the convex hull. First line has -INF",
            "",
            "\t\tenum Type {line, maxQuery, minQuery} type;",
            "\t\tint64_t val;",
            "",
            "\t\texplicit Line(int64_t aa=0, int64_t bb=0): a(aa), b(bb), xLeft(-INF), type(Type::line), val(0) {}",
            "",
            "\t\tint64_t valueAt(int64_t x) const",
            "\t\t{",
            "\t\t\treturn a*x + b;",
            "\t\t}",
            "\t\tfriend bool isParallel(const Line &l1, const Line &l2)",
            "\t\t{",
            "\t\t\treturn l1.a == l2.a;",
            "\t\t}",
            "\t\tfriend double llersectX(const Line &l1, const Line &l2)",
            "\t\t{",
            "\t\t\treturn isParallel(l1, l2)?INF:1.0*(l2.b-l1.b)/(l1.a-l2.a);",
            "\t\t}",
            "\t\tbool operator<(const Line& l2) const",
            "\t\t{",
            "\t\t\tif(l2.type == line)",
            "\t\t\t\treturn this->a < l2.a;",
            "\t\t\tif(l2.type == maxQuery)",
            "\t\t\t\treturn this->xLeft < l2.val;",
            "\t\t\tif(l2.type == minQuery)",
            "\t\t\t\treturn this->xLeft > l2.val;",
            "            return 0;",
            "\t\t}",
            "\t};",
            "",
            "\tbool isMax;",
            "\tset<Line> hull;",
            "",
            "\tbool hasPrev(set<Line>::iterator it)",
            "\t{",
            "\t\treturn it!=hull.begin();",
            "\t}\t",
            "\tbool hasNext(set<Line>::iterator it)",
            "\t{",
            "\t\treturn it!=hull.end() && next(it)!=hull.end();",
            "\t}",
            "\tbool irrelevant(const Line &l1, const Line &l2, const Line &l3)",
            "\t{",
            "\t\treturn llersectX(l1, l3) <= llersectX(l1, l2);",
            "\t}",
            "\tbool irrelevant(set<Line>::iterator it)",
            "\t{",
            "\t\treturn hasPrev(it) && hasNext(it) && ( ",
            "\t\t\t(isMax && irrelevant(*prev(it), *it, *next(it))) ",
            "\t\t\t|| (!isMax && irrelevant(*next(it), *it, *prev(it))));",
            "\t}",
            "\t//Updates xValue of line polled by it",
            "\tset<Line>::iterator updateLeftBorder(set<Line>::iterator it)",
            "\t{",
            "\t\tif(isMax && !hasPrev(it) || !isMax && !hasNext(it))",
            "\t\t\treturn it;",
            "\t\tdouble val=llersectX(*it, isMax?(*prev(it)):(*next(it)));",
            "\t\tLine temp(*it);",
            "\t\tit=hull.erase(it);",
            "\t\ttemp.xLeft=val;",
            "\t\tit=hull.insert(it, temp);",
            "\t\treturn it;",
            "\t}",
            "",
            "\texplicit CHTChan(bool isMax): isMax(isMax) {}",
            "",
            "\tvoid addLine(int64_t a, int64_t b) //Add ax + b in logN time",
            "\t{",
            "\t\tLine l3=Line(a, b);",
            "\t\tauto it=hull.lower_bound(l3);",
            "",
            "\t\t//If parallel liune is already in set, one of the lines becomes irrelevant",
            "\t\tif(it!=hull.end() && isParallel(*it, l3))",
            "\t\t{",
            "\t\t\tif(isMax && it->b<b || !isMax && it->b>b)",
            "\t\t\t\tit=hull.erase(it);",
            "\t\t\telse",
            "\t\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tit=hull.insert(it, l3);",
            "\t\tif(irrelevant(it))",
            "\t\t{",
            "\t\t\thull.erase(it);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\t//Remove lines which became irrelevant after inserting",
            "\t\twhile(hasPrev(it) && irrelevant(prev(it)))",
            "\t\t\thull.erase(prev(it));",
            "\t\twhile(hasNext(it) && irrelevant(next(it)))",
            "\t\t\thull.erase(next(it));",
            "",
            "\t\t//Update xLine",
            "\t\tit=updateLeftBorder(it);",
            "\t\tif(hasPrev(it))",
            "\t\t\tupdateLeftBorder(prev(it));",
            "\t\tif(hasNext(it))",
            "\t\t\tupdateLeftBorder(next(it));",
            "\t}",
            "",
            "\tint64_t getBest(int64_t x)",
            "\t{",
            "\t\tLine q;",
            "\t\tq.val=x;",
            "\t\tq.type = isMax?Line::Type::maxQuery : Line::Type::minQuery;",
            "",
            "\t\tauto bestLine=hull.lower_bound(q);",
            "\t\tif(isMax)",
            "\t\t\t--bestLine;",
            "\t\treturn bestLine->valueAt(x);",
            "\t}",
            "};"
        ],
        "description": "Snippet for ConvexHullTrick"
    },
    "TemplateSuffixArray": {
        "prefix": "TemplateSuffixArray",
        "body": [
            "template <class T>",
            "array<vector<int>, 3> SuffixArrayChan(const T &s, int max_num)",
            "{",
            "    /*",
            "        tc: O(|s|.log(|s|) + max_num)",
            "        mc: O(|s| + max_num)",
            "",
            "        info:",
            "            must pass s such that s[i] works as array index",
            "            returns {suffix array, inverse suffix array, lcp array}",
            "    */",
            "    int n = (int)size(s);",
            "    vector<int> sa(n), sa_inv(begin(s), end(s)), lcp(max(0, n - 1));",
            "    iota(begin(sa), end(sa), 0);",
            "    ",
            "    for (int ln = 0; ln < n; ln = max(1, 2 * ln))",
            "    {",
            "        vector<int> tmp(n), freq(max_num);",
            "        iota(begin(tmp), begin(tmp) + ln, n - ln);",
            "        copy_if(begin(sa), end(sa), begin(tmp) + ln, [&](int &x) { return (x -= ln) >= 0; });",
            "        for (int x : sa_inv)    freq[x]++;",
            "        ",
            "        partial_sum(begin(freq), end(freq), begin(freq));",
            "        for_each(rbegin(tmp), rend(tmp), [&](int x) { sa[--freq[sa_inv[x]]] = x; });",
            "        swap(sa_inv, tmp);",
            "        max_num = 1, sa_inv[sa[0]] = 0;",
            "        ",
            "        auto prev_inv = [&](int i) { return pair(tmp[i], i + ln < n ? tmp[i + ln] : -1); };",
            "        for (int i = 1; i < (n); i++)",
            "        {",
            "            max_num += prev_inv(sa[i - 1]) != prev_inv(sa[i]);",
            "            sa_inv[sa[i]] = max_num - 1;",
            "        }",
            "        if (max_num == n)",
            "            break;",
            "    }",
            "",
            "    int sz = 0;",
            "    for (int i = 0; i < (n); i++)",
            "    {",
            "        if (sz > 0)",
            "            sz--;",
            "        if (sa_inv[i] == 0)",
            "            continue;",
            "        for (int j = sa[sa_inv[i] - 1]; max(i, j) + sz < n && s[i + sz] == s[j + sz];)",
            "            sz++;",
            "        lcp[sa_inv[i] - 1] = sz;",
            "    }",
            "    return {sa, sa_inv, lcp};",
            "}"
        ],
        "description": "Snippet for SuffixArray"
    },
    "TemplateManachers": {
        "prefix": "TemplateManachers",
        "body": [
            "template <typename T>",
            "vector<int> ManachersChan(const T &s)",
            "{",
            "    /*",
            "        tc: O(|s|)",
            "        mc: O(|s|)",
            "",
            "        info:",
            "            0-indexed",
            "            res[2 * i]  = odd RADIUS in position i",
            "            res[2 * i + 1] = even RADIUS between positions i and i + 1",
            "        ",
            "        ex:",
            "            s = \"abaa\" -> res = {0, 0, 1, 0, 0, 1, 0};",
            "        ",
            "        author notes:",
            "            in other words, for every z from 0 to 2 * n - 2:",
            "            calculate i = (z + 1) >> 1 and j = z >> 1",
            "            now there is a palindrome from i - res[z] to j + res[z]",
            "            (watch out for i > j and res[z] = 0)",
            "    */",
            "    int n = (int)s.size();",
            "    if (n == 0)",
            "        return vector<int>();",
            "        ",
            "    vector<int> res(2 * n - 1, 0);",
            "    int l = -1, r = -1;",
            "    for (int z = 0; z < 2 * n - 1; z ++)",
            "    {",
            "        int i = (z + 1) >> 1, j = z >> 1;",
            "        int p = (i >= r ? 0 : min(r - i, res[2 * (l + r) - z]));",
            "",
            "        while (j + p + 1 < n and i - p - 1 >= 0 and (s[j + p + 1] == s[i - p - 1]))",
            "            p ++;",
            "",
            "        if (j + p > r)",
            "            l = i - p, r = j + p;",
            "        res[z] = p;",
            "    }",
            "",
            "    return res;",
            "}"
        ],
        "description": "Snippet for Manachers"
    },
    "TemplateTrie": {
        "prefix": "TemplateTrie",
        "body": [
            "template<const int C>",
            "class StaticNodeChan",
            "{",
            "public:",
            "    int sub = 0;",
            "    int leaf = 0;",
            "    array<int, C> next;",
            "};",
            "class DynamicNodeChan",
            "{",
            "public: ",
            "    int sub = 0;",
            "    int leaf = 0;",
            "    map<int, int> next;",
            "};",
            "",
            "template<typename S, typename T, typename I>",
            "class TrieChan",
            "{",
            "public:",
            "    int r = 0, p = 0;",
            "    vector<T> t;",
            "    I ind;",
            "",
            "    TrieChan(int n, I ind) : t(n), ind(ind) {};",
            "",
            "    void Insert(const vector<S> &s)",
            "    {",
            "        int v = r;",
            "        for(auto x : s)",
            "        {",
            "            ++ t[v].sub;",
            "",
            "            int f = ind(x);",
            "         ",
            "            if(t[v].next[f] == 0)",
            "                t[v].next[f] = ++ p;",
            "            v = t[v].next[f];",
            "        }",
            "        ++ t[v].sub, ++ t[v].leaf;",
            "    }",
            "};"
        ],
        "description": "Snippet for Trie"
    },
    "TemplateKMP": {
        "prefix": "TemplateKMP",
        "body": [
            "template <typename T>",
            "vector<int> KMPTable(const T &s)",
            "{",
            "    /*",
            "        tc: O(|s|)",
            "        mc: O(|s|)",
            "",
            "        info:",
            "            p[i] = longest suffix of substring s[0, 1, .. i] which is also a suffix ",
            "    */",
            "    int n = s.size();",
            "    vector<int> p(n, 0);",
            "    int k = 0;",
            "    for (int i = 1; i < n; i ++)",
            "    {",
            "        while (k > 0 && !(s[i] == s[k]))",
            "            k = p[k - 1];",
            "        if (s[i] == s[k])",
            "            k ++;",
            "        p[i] = k;",
            "    }",
            "    return p;",
            "}",
            "",
            "template <typename T>",
            "vector<int> KMPSearch(const T &s, const T &w, const vector<int> &p)",
            "{",
            "    /*",
            "        tc: O(|s| + |w|)",
            "        mc: O(|w|)",
            "",
            "        info:",
            "            finds 0-indexed positions of occurences of s in w",
            "            p is kmp table of s",
            "    */",
            "    int n = s.size(), m = w.size();",
            "    assert(n >= 1 && (int)p.size() == n);",
            "    vector<int> res;",
            "    int k = 0;",
            "    for (int i = 0; i < m; i ++)",
            "    {",
            "        while (k > 0 && (k == n || !(w[i] == s[k])))",
            "            k = p[k - 1];",
            "        if (w[i] == s[k])",
            "            k ++;",
            "        if (k == n)",
            "            res.push_back(i - n + 1);",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Snippet for KMP"
    },
    "TemplateSuffixTree": {
        "prefix": "TemplateSuffixTree",
        "body": [
            "class SuffixTreeChan",
            "{",
            "    /*",
            "    tc: O(n)",
            "    mc: O(n)",
            "",
            "    info:",
            "        0 indexed",
            "        pass it 0 indexed suffix array and lcp array",
            "        constructs suffix tree with the following properties:",
            "            1. node i (< n) represents suffix i (length = n - 1)",
            "            2. for every suffix there exists node in the suffix tree (even if it has only child)",
            "            3. if u > v, then u cannot be in the subtree of v",
            "            4. adj[u] contains downward edges from node u, sorted lexicography in order of strings on their labels",
            "            5. `root` is root node",
            "            6. dep[u] contains length of path from root to node u, used for edge labels",
            "            7. rep[u] = some i such that leaf for suffix i is in subtree of u ",
            "            8. m is the total number of nodes in the suffix tree (so m - n is the number of new internal nodes)",
            "",
            "        warning:",
            "            sa gets modified so dont pass by reference",
            "    */",
            "public:",
            "    int n, m, root;",
            "    vector<int> dep, rep;",
            "    vector<vector<int>> adj;",
            "",
            "    SuffixTreeChan(int n, vector<int> sa, vector<int> lcp) : ",
            "    n(n), m(n), dep(2 * n + 1), rep(2 * n + 1), adj(2 * n + 1)",
            "    {",
            "        vector<int> l(n), r(n);",
            "        for(int i = 0; i < n; i ++) ",
            "            l[i] = r[i] = rep[i] = i, dep[i] = n - i;",
            "        ",
            "        vector<vector<int>> q(n);",
            "        for(int i = 0; i < n - 1; i ++)",
            "            q[lcp[i]].push_back(i);",
            "        ",
            "        for(int d = n - 1; d >= 0; d --)",
            "            for(auto i : q[d])",
            "            {",
            "                int u;",
            "                if(dep[sa[i]] == d)",
            "                    u = sa[i], adj[u].push_back(sa[i + 1]);",
            "                else if(dep[sa[i + 1]] == d)",
            "                    u = sa[i + 1], adj[u].push_back(sa[i]);",
            "                else",
            "                    u = m ++, rep[u] = rep[sa[i]], adj[u] = {sa[i], sa[i + 1]};",
            "                ",
            "                dep[u] = d;",
            "                l[r[i + 1]] = l[i], r[l[i]] = r[i + 1];",
            "                sa[l[i]] = sa[r[i + 1]] = u;",
            "            }",
            "",
            "        root = sa[0];",
            "        if(dep[root] != 0)",
            "            root = m ++, dep[root] = 0, adj[root] = {sa[0]};",
            "    };",
            "};"
        ],
        "description": "Snippet for SuffixTree"
    },
    "TemplateZ": {
        "prefix": "TemplateZ",
        "body": [
            "template <typename T>",
            "vector<int> ZChan(const T &s)",
            "{",
            "    int n = s.size();",
            "    vector<int> z(n, n);",
            "    int l = 0, r = 0;",
            "    for (int i = 1; i < n; i++)",
            "    {",
            "        z[i] = (i > r ? 0 : min(r - i + 1, z[i - l]));",
            "        while (i + z[i] < n && s[z[i]] == s[i + z[i]])",
            "            z[i]++;",
            "",
            "        if (i + z[i] - 1 > r)",
            "            l = i, r = i + z[i] - 1;",
            "    }",
            "    return z;",
            "}"
        ],
        "description": "Snippet for Z"
    },
    "TemplateCartesianTree": {
        "prefix": "TemplateCartesianTree",
        "body": [
            "template<typename T, typename C>",
            "vector<vector<int>> CartesianTree(const vector<T> &p, C c = C())",
            "{",
            "    int n = p.size();",
            "",
            "    vector<int> l(n, -1);",
            "",
            "    vector<int> stk;",
            "    for(int i = n - 1; i >= 0; i --)",
            "    {",
            "        while(!stk.empty() and c(p[i], p[stk.back()]))",
            "            l[stk.back()] = i, stk.pop_back();",
            "        stk.push_back(i);",
            "    }",
            "    stk.clear();",
            "",
            "    vector<int> r(n, n);",
            "    for(int i = 0; i < n; i ++)",
            "    {",
            "        while(!stk.empty() and c(p[i], p[stk.back()]))",
            "            r[stk.back()] = i, stk.pop_back();",
            "        stk.push_back(i);",
            "    }",
            "    stk.clear();",
            "",
            "    vector<vector<int>> adj(n);",
            "    for(int i = 0; i < n; i ++)",
            "    {",
            "        int parent = -1;",
            "        if(l[i] != -1)",
            "            parent = l[i];",
            "        ",
            "        if(r[i] != -1)",
            "            if(parent == -1 or !c(p[parent], p[r[i]]))",
            "                parent = r[i];",
            "        ",
            "        if(parent != -1)",
            "            adj[parent].push_back(i);",
            "    }",
            "",
            "    return adj;",
            "}"
        ],
        "description": "Snippet for CartesianTree"
    },
    "TemplateMonoidDeque": {
        "prefix": "TemplateMonoidDeque",
        "body": [
            "//wip",
            "",
            "template<typename T>",
            "class MonoidDequeChan",
            "{",
            "    stack<T> a, b;",
            "",
            "    void Push(T a)",
            "    {",
            "",
            "    }",
            "",
            "    void Pop()",
            "    {",
            "",
            "    }",
            "",
            "    void Compute",
            "};"
        ],
        "description": "Snippet for MonoidDeque"
    },
    "TemplateDisjointSparseTable": {
        "prefix": "TemplateDisjointSparseTable",
        "body": [
            "class ElementChan",
            "{",
            "public:",
            "    static constexpr int neutral = 0;",
            "    int val;",
            "    ElementChan() : val(neutral) {};",
            "    ElementChan(int x) : val(x) {};",
            "    ElementChan Unite(const ElementChan &b) const",
            "    {",
            "        return ElementChan(val + b.val);",
            "    };",
            "};",
            "template <typename T>",
            "class DisjointSparseTableChan",
            "{",
            "public:",
            "    int n;",
            "    vector<vector<T>> mat;",
            "",
            "    DisjointSparseTableChan(const vector<T> &a)",
            "    {",
            "        n = static_cast<int>(a.size());",
            "        mat.push_back(a);",
            "        for (int p = 1; (1 << p) < n; p++)",
            "        {",
            "            mat.emplace_back(n);",
            "            for (int mid = 1 << p; mid < n; mid += 1 << (p + 1))",
            "            {",
            "                mat[p][mid - 1] = a[mid - 1];",
            "                for (int j = mid - 2; j >= mid - (1 << p); j--)",
            "                    mat[p][j] = a[j].Unite(mat[p][j + 1]);",
            "                mat[p][mid] = a[mid];",
            "                for (int j = mid + 1; j < min(n, mid + (1 << p)); j++)",
            "                    mat[p][j] = mat[p][j - 1].Unite(a[j]);",
            "            }",
            "        }",
            "    }",
            "",
            "    T Query(int l, int r) const",
            "    {",
            "        assert(0 <= l && l < r && r <= n);",
            "        if (r - l == 1)",
            "            return mat[0][l];",
            "        int p = bit_width(unsigned(l ^ (r - 1))) - 1;",
            "        returnr mat[p][l].Unite(mat[p][r - 1]);",
            "    }",
            "};"
        ],
        "description": "Snippet for DisjointSparseTable"
    },
    "TemplateSplay": {
        "prefix": "TemplateSplay",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"../libra/misc/dbg.h\"",
            "#else",
            "#define debug(...)",
            "#define endl \"\\\\n\"",
            "#endif",
            "",
            "class Node",
            "{",
            "public:",
            "    Node *l, *r, *p;",
            "",
            "    int key, val;",
            "",
            "    //subtree aggregates",
            "    int siz, sum;",
            "",
            "    //lazy propagation",
            "    int add;",
            "",
            "    Node() : p(nullptr), l(nullptr), r(nullptr), key(0), val(0), sum(0), add(0) {};",
            "",
            "    void Push()",
            "    {",
            "        if(l != nullptr)",
            "            l->sum += add;",
            "        if(r != nullptr)",
            "            r->sum += add;",
            "        add = 0;",
            "    }",
            "    void Pull()",
            "    {",
            "        siz = sum = 0;",
            "        if(l != nullptr)",
            "            siz += l->siz, sum += r->sum;",
            "        siz += 1, sum += val;",
            "        if(r != nullptr)",
            "            siz += r->siz, sum += r->sum;",
            "    }",
            "};",
            "",
            "// template<typename Node>",
            "namespace SplayChan",
            "{",
            "    bool IsRoot(Node* u)",
            "    {",
            "        if(u == nullptr)",
            "            return false;",
            "        return (u->p == nullptr);",
            "    }",
            "",
            "    void Rotate(Node* u)",
            "    {",
            "        auto p = u->p;",
            "        assert(p != nullptr);",
            "",
            "        p->Push();",
            "        u->Push();",
            "        p->p = u->p;",
            "",
            "        if(u->p != nullptr)",
            "        {",
            "            if(p->p->l == u)",
            "                p->p->l = u;",
            "            else if(p->p->r == u)",
            "                p->p->r = u;",
            "        }",
            "",
            "        if(u == p->l)",
            "        {",
            "            p->l = u->r;",
            "            u->r = p;",
            "        }",
            "        else",
            "        {",
            "            p->r = u->l;",
            "            u->l = p;",
            "        }",
            "",
            "        p->Pull();",
            "        u->Pull();",
            "    }",
            "",
            "    void Splay(Node *u)",
            "    {",
            "        if(u == nullptr)",
            "            return;",
            "        while(!IsRoot(u))",
            "        {",
            "            auto p = u->p;",
            "            if(!IsRoot(p))",
            "            {",
            "                if((p->l == u) ^ (p->p->l == p))",
            "                    Rotate(u);",
            "                else",
            "                    Rotate(p);",
            "            }",
            "            Rotate(u);",
            "        }",
            "    }",
            "",
            "    pair<Node*, int> Access(Node* u, const function<int(Node*)> &go_to)",
            "    {",
            "        if(u == nullptr)",
            "            return {u, 0};",
            "        Splay(u);",
            "        int d;",
            "",
            "        while(1)",
            "        {",
            "            u->Push();",
            "            d = go_to(u);",
            "            if(d == 0)",
            "                break;",
            "            Node *v = (d == -1 ? u->l : u->r);",
            "            if(v == nullptr)",
            "                break;",
            "            u = v;",
            "        }",
            "        Splay(u);",
            "        return {u, d};",
            "    }",
            "",
            "    Node* GetLeftmost(Node* u)",
            "    {",
            "        return Access(u, [&](Node*) {return -1;}).first;",
            "    }",
            "    Node* GetRightmost(Node* u)",
            "    {",
            "        return Access(u, [&](Node*) {return 1;}).first;",
            "    }",
            "",
            "    Node* GetKth(Node* u, int k)        // 0-indexed",
            "    {",
            "        pair<Node*, int> p = Access(u, [&](Node* u)",
            "        {",
            "            if(u->l != nullptr)",
            "            {",
            "                if(u->l->siz > k)",
            "                    return -1;",
            "                k -= u->l->siz;",
            "            }",
            "            if(k == 0)",
            "                return 0;",
            "            -- k;",
            "            return 1;",
            "        });",
            "",
            "        return (p.second == 0 ? p.first : nullptr); ",
            "    }",
            "",
            "    int GetPosition(Node *u)        // 0 -indexed",
            "    {",
            "        Splay(u);",
            "        return (u->l == nullptr ? 0 : u->l->siz);",
            "    }",
            "",
            "    Node* GetRoot(Node* u)",
            "    {",
            "        Splay(u);",
            "        return u;",
            "    }",
            "",
            "    pair<Node*, Node*> Split(Node* u, const function<bool(Node*)> &IsRight)",
            "    {",
            "        if(u == nullptr)",
            "            return {nullptr, nullptr};",
            "        ",
            "        pair<Node*, int> p = Access(u, [&](Node* u) {return IsRight(u) ? -1 : 1;});",
            "        ",
            "        //if p.second == 1, we have found the greatest node which should be in the left subtree",
            "        //if p.second == -1, we have found the smallest node which should be in the right subtree",
            "        //then, we splayed this node and its now the root",
            "",
            "        u = p.first;",
            "        u->Push();",
            "",
            "        if(p.second == -1)",
            "        {",
            "            Node* v = u->l;",
            "            if(v == nullptr)",
            "                return {nullptr, u};",
            "            u->l = nullptr;",
            "            v->p = u->p;",
            "            v = GetRightmost(v);",
            "            u->p = v;",
            "            u->Pull();",
            "            return {v, u};",
            "        }",
            "        else",
            "        {",
            "            Node* v = u->r;",
            "            if(v == nullptr)",
            "                return {u, nullptr};",
            "            u->r = nullptr;",
            "            u->Pull();",
            "            return {u, v};",
            "        }",
            "",
            "        return {nullptr, nullptr};",
            "    }",
            "",
            "    Node* Merge(Node* u, Node* v)       //all in u <= all in v",
            "    {",
            "        if(u == nullptr)",
            "            return u;",
            "        if(v == nullptr)",
            "            return v;",
            "        ",
            "        u = GetRightmost(u);",
            "        assert(v->r == nullptr);",
            "",
            "        Splay(v);",
            "        u->Push();",
            "        u->r = v;",
            "        u->Pull();",
            "        return u;",
            "    }",
            "};",
            "using namespace SplayChan;",
            "",
            "int32_t main()",
            "{",
            "}"
        ],
        "description": "Snippet for Splay"
    },
    "TemplateDSU": {
        "prefix": "TemplateDSU",
        "body": [
            "class DSUChan",
            "{",
            "    /*",
            "        tc: ",
            "            O(n a(n)) amortized",
            "            O(n log(n)) for rollbackable",
            "",
            "        info:",
            "            par[u] stores leader of u",
            "            siz[u] stores size of component with leader u",
            "",
            "        modify:",
            "            to make rollbackable, we do not make modifications in get() [which makes the get() function O(log(N))] ",
            "            and store change info in unite()",
            "    */",
            "public:",
            "    int n;",
            "    vector<int> par, siz;",
            "    DSUChan(int n) : n(n), par(n), siz(n, 1)",
            "    {",
            "        iota(par.begin(), par.end(), 0);",
            "    };",
            "    ",
            "    int Get(int x)",
            "    {",
            "        return (par[x] == x ? x : par[x] = Get(par[x]));",
            "    }",
            "",
            "    void Unite(int x, int y)",
            "    {",
            "        x = Get(x), y = Get(y);",
            "        if(x == y)",
            "            return;",
            "        if(siz[x] > siz[y]) swap(x, y);",
            "        par[x] = y, siz[y] += siz[x];",
            "    }",
            "",
            "    vector<vector<int>> Groups()",
            "    {",
            "        vector<vector<int>> g(n);",
            "        for(int u = 0; u < n; u ++)",
            "            g[Get(u)].push_back(u);",
            "        return g;",
            "    }",
            "};"
        ],
        "description": "Snippet for DSU"
    },
    "TemplateOfflineDeletion": {
        "prefix": "TemplateOfflineDeletion",
        "body": [
            "template<typename T, typename Q, typename D>",
            "class OfflineDeletionChan",
            "{",
            "public:",
            "    int n;",
            "    vector<Q> ans;",
            "    vector<vector<T>> store;",
            "    D ds;",
            "",
            "    OfflineDeletionChan(int n) : ",
            "    n(n), ans(4 * n + 5), store(4 * n + 5) {};",
            "",
            "    //Put(L, R, life) puts element \"life\" into segment [L, R]",
            "    void Put(int L, int R, T life)",
            "    {",
            "        auto rec = [&](int v, int l, int r, auto &&rec) -> void",
            "        {",
            "            if(l > r or r < L or R < l)",
            "                return;",
            "",
            "            if(L <= l and r <= R)",
            "            {",
            "                store[v].push_back(life);",
            "                return;",
            "            }",
            "            ",
            "            int mid = (l + r)/2;",
            "            put(v * 2, l, mid, rec);",
            "            put(v * 2 + 1, mid + 1, r, rec);",
            "        };",
            "        rec(1, 1, n, rec);",
            "    }",
            "",
            "    void Compute()",
            "    {",
            "        auto dfs = [&](int v, int l, int r, auto &&dfs) -> void",
            "        {",
            "            if(l > r)",
            "                return;",
            "",
            "            for(auto point : store[v])",
            "                ds.Insert(point);",
            "",
            "            if(l == r)",
            "                ans[l] = ds.Query();",
            "            else",
            "            {",
            "                int mid = (l + r)/2;",
            "                dfs(v * 2, l, mid, dfs);",
            "                dfs(v * 2 + 1, mid + 1, r, dfs);",
            "            }",
            "            ",
            "            for(auto point : store[v])",
            "                ds.Rollback();",
            "        };",
            "        dfs(1, 1, n, dfs);",
            "    }",
            "};"
        ],
        "description": "Snippet for OfflineDeletion"
    },
    "TemplateSparseTable": {
        "prefix": "TemplateSparseTable",
        "body": [
            "class ElementChan",
            "{",
            "public:",
            "    static constexpr int neutral = inf;",
            "    ",
            "    int val;",
            "    ElementChan() : val(neutral) {};",
            "    ElementChan(int x) : val(x) {};",
            "    ElementChan Unite(const ElementChan &b) const",
            "    {",
            "        return ElementChan(min(val, b.val));",
            "    };",
            "};",
            "template <typename T>",
            "class SparseTableChan",
            "{",
            "public:",
            "    int n;",
            "    vector<vector<T>> mat;",
            "    SparseTableChan(const vector<T> &a)",
            "    {",
            "        n = a.size();",
            "        int max_log = 32 - __builtin_clz(n);",
            "        mat.resize(max_log);",
            "        mat[0] = a;",
            "        for (int j = 1; j < max_log; j++)",
            "        {",
            "            mat[j].resize(n - (1 << j) + 1);",
            "            for (int i = 0; i <= n - (1 << j); i++)",
            "                mat[j][i] = mat[j - 1][i].Unite(mat[j - 1][i + (1 << (j - 1))]);",
            "        }",
            "    }",
            "    T Query(int from, int to) const",
            "    {",
            "        assert(0 <= from && from <= to && to <= n - 1);",
            "        int lg = 32 - __builtin_clz(to - from + 1) - 1;",
            "        return mat[lg][from].Unite(mat[lg][to - (1 << lg) + 1]);",
            "    }",
            "};"
        ],
        "description": "Snippet for SparseTable"
    },
    "TemplateFenwickTree": {
        "prefix": "TemplateFenwickTree",
        "body": [
            "class NodeChan",
            "{",
            "public:",
            "    int v = 0;",
            "",
            "    inline void operator+=(NodeChan &other)",
            "    {",
            "        v += other.v;",
            "    }",
            "    inline bool operator<(NodeChan &other)",
            "    {",
            "        return v < other.v;",
            "    }",
            "};",
            "template <typename T>",
            "class FenwickChan",
            "{",
            "public:",
            "    vector<T> fenw;",
            "    int n;",
            "    int pw;",
            "",
            "    FenwickChan() : n(0) {}",
            "    FenwickChan(int n_) : n(n_)",
            "    {",
            "        fenw.resize(n);",
            "        pw = (n == 0 ? 0 : 1ULL << (63 - __builtin_clzll(unsigned(n))));",
            "    }",
            "",
            "    // a[x] += v;",
            "    void Modify(int x, T v)",
            "    {",
            "        assert(0 <= x && x < n);",
            "        while (x < n)",
            "        {",
            "            fenw[x] += v;",
            "            x |= x + 1;",
            "        }",
            "    }",
            "",
            "    /// sum of prefix [0, .. x] ",
            "    T Query(int x)",
            "    {",
            "        ++ x;",
            "        assert(0 <= x && x <= n);",
            "        T v{};",
            "        while (x > 0)",
            "        {",
            "            v += fenw[x - 1];",
            "            x &= x - 1;",
            "        }",
            "        return v;",
            "    }",
            "",
            "    // Returns the length of the longest prefix (0 indexed) with sum <= c",
            "    int MaxPrefix(T c)",
            "    {",
            "        T v{};",
            "        int at = 0;",
            "        for (int len = pw; len > 0; len >>= 1)",
            "        {",
            "            if (at + len <= n)",
            "            {",
            "                auto nv = v;",
            "                nv += fenw[at + len - 1];",
            "                if (!(c < nv))",
            "                {",
            "                    v = nv;",
            "                    at += len;",
            "                }",
            "            }",
            "        }",
            "        assert(0 <= at && at <= n);",
            "        return at;",
            "    }",
            "};"
        ],
        "description": "Snippet for FenwickTree"
    },
    "TemplateMonotonicQueue": {
        "prefix": "TemplateMonotonicQueue",
        "body": [
            "class ElementChan",
            "{",
            "public:",
            "    int x;",
            "    ElementChan() : x(0) {};",
            "    ElementChan(int v) : x(v) {};",
            "",
            "    bool opt(const ElementChan &o) const",
            "    {",
            "        return x > o.x;",
            "    }",
            "};",
            "template<typename T>",
            "class MonoQChan",
            "{",
            "public:",
            "    T neutral;",
            "",
            "    deque<pair<T, int>> q;",
            "    int l, r;",
            "",
            "    MonoQChan() : l(0), r(0) {};",
            "",
            "    int Size()",
            "    {",
            "        return r - l;",
            "    }",
            "    T Opt()",
            "    {",
            "        return (Size() ? q.front().first : T());",
            "    }",
            "    void Push(T x)",
            "    {",
            "        while(!q.empty() and x.opt(q.back().first))",
            "            q.pop_back();",
            "        q.push_back({x, r ++});",
            "    }",
            "    void Pop()",
            "    {",
            "        if (!q.empty() and q.front().second == l)",
            "            q.pop_front();",
            "        l ++;",
            "    }",
            "    void Clear()",
            "    {",
            "        q.clear();",
            "        l = r = 0;",
            "    }",
            "};"
        ],
        "description": "Snippet for MonotonicQueue"
    },
    "TemplateBlockDecomposition": {
        "prefix": "TemplateBlockDecomposition",
        "body": [
            "class ElementChan",
            "{",
            "public:",
            "};",
            "class BlockChan",
            "{",
            "public:",
            "};",
            "",
            "template<typename E, typename T, const int B>",
            "class BlockDecompositionChan",
            "{",
            "public:",
            "    static int ceil_div(int x, int y)",
            "    {",
            "        return (x + y - 1)/y;",
            "    }",
            "    static int block_id(int i)",
            "    {",
            "        return i/B;",
            "    }",
            "    static int lb(int bid)",
            "    {",
            "        return bid * B;",
            "    }",
            "    static int rb(int bid)",
            "    {",
            "        return min(n, (bid + 1) * B - 1);",
            "    }",
            "",
            "public:",
            "    int n;",
            "    vector<E> element;",
            "    vector<T> block;",
            "",
            "    BlockDecompositionChan(int n, vector<E> a, vector<T> b) : n(n), element(a), block(b)",
            "    {",
            "",
            "    };",
            "",
            "    void Process(int l, int r, auto block_brute, auto block_quick)",
            "    {",
            "        assert(1 <= l and l <= r and r <= n);",
            "",
            "        int bl = block_id(l), br = block_id(r);",
            "",
            "        if(bl == br)",
            "            block_brute(l, r);",
            "        else",
            "        {",
            "            block_brute(l, rb(bl));",
            "            for(int b = bl + 1; b < br; b ++)",
            "                block_quick(b);",
            "            block_brute(lb(br), r);",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet for BlockDecomposition"
    },
    "TemplateBitset": {
        "prefix": "TemplateBitset",
        "body": [
            "template<typename T, const int B>",
            "class BitsetChan",
            "{",
            "public:",
            "    using T_T = T;",
            "    static_assert(sizeof(T) * 8 == B, \"check block width\");",
            "    static_assert(std::is_same<T, uint64_t>::value, \"modify popcnt(), ctz(), clz()\");",
            "",
            "//static helper",
            "public:",
            "    static inline constexpr bool on(int i, T x) noexcept",
            "    {",
            "        return ((T(1) << i) & x) != 0;",
            "    }",
            "    static inline constexpr T prefix(int i) noexcept",
            "    {",
            "        return (i >= B) ? ~T(0) : ((T(1) << i) - T(1));",
            "    }",
            "    static inline constexpr T suffix(int i) noexcept",
            "    {",
            "        return ~prefix(B - i);",
            "    }",
            "    static inline constexpr T range(int l, int r) noexcept",
            "    {",
            "        return prefix(r) ^ prefix(l - 1);",
            "    }",
            "    static constexpr int popcnt(T x) noexcept",
            "    {",
            "        // return _mm_popcnt_u64(x);",
            "        return __builtin_popcountll(x);",
            "    }",
            "    static constexpr int clz(T x) noexcept",
            "    {",
            "        return __builtin_clzll(x);",
            "    }",
            "    static constexpr int ctz(T x) noexcept",
            "    {",
            "        return __builtin_ctzll(x);",
            "    }",
            "    static inline constexpr int block_id(int i) noexcept",
            "    {",
            "        return i / B;",
            "    }",
            " ",
            "//helper",
            "public:",
            "    inline T submask(int l, int r) const noexcept",
            "    {",
            "        int bx = block_id(l);",
            "        assert(bx == block_id(r));",
            "        return (b[bx] & range(l - bx * B + 1, r - bx * B + 1)); ",
            "    }",
            "    inline void trim() noexcept",
            "    {",
            "        b.back() &= prefix(n % B == 0 ? B : n % B);",
            "    }",
            " ",
            "//main",
            "public:",
            "    int n, m;",
            "    std::vector<T> b;",
            " ",
            "    BitsetChan(int n) : BitsetChan(n, false) {};",
            "    BitsetChan(int n, bool init) : n(n), m((n + B - 1)/B), b(m, init ? ~T(0) : T(0)) ",
            "    {",
            "        trim();",
            "    };",
            " ",
            "    inline void Set(int i, bool val) noexcept",
            "    {",
            "        assert(0 <= i and i < n);",
            "        if(val)",
            "            b[i/B] |= (T(1) << (i % B));",
            "        else",
            "            b[i/B] &= ~(T(1) << (i % B));",
            "    }",
            " ",
            "    inline bool Get(int i) const noexcept",
            "    {",
            "        assert(0 <= i and i < n);",
            "        return (b[i/B] & (T(1) << (i % B))) != 0;",
            "    }",
            " ",
            "    void Reset() noexcept",
            "    {",
            "        std::fill(b.begin(), b.end(), T(0));",
            "    }",
            " ",
            "    //bitwise operations",
            "    void operator &= (const BitsetChan &other)",
            "    {",
            "        for(int i = 0; i < std::min(m, other.m); i ++)",
            "            b[i] &= other.b[i];",
            "        if(m > other.m)",
            "            std::fill(b.begin() + other.m, b.begin() + m, T(0));",
            "        // trim();",
            "    }",
            " ",
            "    void operator |= (const BitsetChan &other)",
            "    {",
            "        for(int i = 0; i < std::min(m, other.m); i ++)",
            "            b[i] |= other.b[i];",
            "        trim();",
            "    }",
            " ",
            "    void operator ^= (const BitsetChan &other)",
            "    {",
            "        for(int i = 0; i < std::min(m, other.m); i ++)",
            "            b[i] ^= other.b[i];",
            "        trim();",
            "    }",
            " ",
            "    void operator <<= (int x)",
            "    {",
            "        if(x == 0)",
            "            return;",
            " ",
            "        if(x >= n)",
            "        {",
            "            Reset();",
            "            return;",
            "        }",
            " ",
            "        const int s = x/B, d = x % B, r = B - d;",
            " ",
            "        if(d > 0)",
            "        {",
            "            for(int i = m - 1 - s; i > 0; i --)",
            "                b[i + s] = (b[i] << d) | (b[i - 1] >> r);",
            "            b[s] = b[0] << d;",
            "        }",
            "        else",
            "        {",
            "            for(int i = m - 1 - s; i > 0; i --)",
            "                b[i + s] = b[i];",
            "            b[s] = b[0];",
            "        }",
            " ",
            "        std::fill(b.begin(), b.begin() + s, T(0));",
            " ",
            "        trim();",
            "    }",
            " ",
            "    void operator >>= (int x)",
            "    {",
            "        if(x == 0)",
            "            return;",
            "     ",
            "        if(x >= n)",
            "        {",
            "            Reset();",
            "            return;",
            "        }",
            " ",
            "        const int s = x/B, d = x % B, l = B - d;",
            " ",
            "        if(d > 0)",
            "        {",
            "            for(int i = s; i < m - 1; i ++)",
            "                b[i - s] = (b[i] >> d) | (b[i + 1] << l); ",
            "            b[m - 1 - s] = b[m - 1] >> d;",
            "        }",
            "        else",
            "            for(int i = s; i < m; i ++)",
            "                b[i - s] = b[i];",
            " ",
            "        std::fill(b.begin() + m - s, b.end(), T(0));        ",
            " ",
            "        // trim();",
            "    }",
            " ",
            "    bool operator == (const BitsetChan &other)",
            "    {",
            "        return ((n == other.n) and b == other.b); ",
            "    }",
            " ",
            "    bool operator != (const BitsetChan &other)",
            "    {",
            "        return !(*this == other);",
            "    }",
            " ",
            "    //extended",
            "    BitsetChan operator & (const BitsetChan &other)",
            "    {",
            "        BitsetChan result(*this);",
            "        result &= other;",
            "        return result;",
            "    }",
            " ",
            "    BitsetChan operator | (const BitsetChan &other)",
            "    {",
            "        BitsetChan result(*this);",
            "        result |= other;",
            "        return result;",
            "    }",
            " ",
            "    BitsetChan operator ^ (const BitsetChan &other)",
            "    {",
            "        BitsetChan result(*this);",
            "        result ^= other;",
            "        return result;",
            "    }",
            " ",
            "    BitsetChan operator >> (int x)",
            "    {",
            "        BitsetChan result(*this);",
            "        result >>= x;",
            "        return result;",
            "    }",
            " ",
            "    BitsetChan operator << (int x)",
            "    {",
            "        BitsetChan result(*this);",
            "        result <<= x;",
            "        return result;",
            "    }",
            " ",
            "    BitsetChan operator ~()",
            "    {",
            "        BitsetChan result(*this);",
            "        for(auto &v : result)",
            "            v = ~v;",
            "        result.trim();",
            "        return result;",
            "    }",
            " ",
            "    //custom operations",
            "    int Count() const noexcept",
            "    {",
            "        return std::accumulate(b.begin(), b.end(), 0, [](int sum, T value) { return sum + popcnt(value); });",
            "    }",
            "     ",
            "    int FindFirst()",
            "    {",
            "        int pos = -1;",
            "",
            "        for(int bi = 0; bi < m; bi ++)",
            "        {",
            "            if(b[bi] == T(0))",
            "                continue;",
            "            ",
            "            pos = ctz(b[bi]) + bi * B;",
            "            break;",
            "        }",
            "",
            "        return pos;",
            "    }",
            "",
            "    int FindLast()",
            "    {",
            "        int pos = -1;",
            "",
            "        for(int bi = m - 1; bi >= 0; bi --)",
            "        {",
            "            if(b[bi] == T(0))",
            "                continue;",
            "            ",
            "            pos = B - clz(b[bi]) - 1 + bi * B;",
            "            break;",
            "        }",
            "",
            "        return pos;",
            "    }",
            "",
            "    void RangeProcess(int l, int r, auto block_brute, auto block_quick)",
            "    {",
            "        assert(0 <= l and l <= r and r < n);",
            " ",
            "        int bl = block_id(l), br = block_id(r);",
            " ",
            "        if(bl == br)",
            "            block_brute(l, r);",
            "        else",
            "        {",
            "            block_brute(l, (bl + 1) * B - 1);",
            "            for(int bi = bl + 1; bi < br; bi ++)",
            "                block_quick(bi);",
            "            block_brute(br * B, r);",
            "        }",
            "    }",
            " ",
            "    void RangeSet(int l, int r, bool val)",
            "    {",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            int bi = block_id(l);",
            "            T mask = range(l - bi * B + 1, r - bi * B + 1);",
            "            if(val)",
            "                b[bi] |= mask;",
            "            else",
            "                b[bi] &= ~mask;",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            b[bi] = (val ? ~T(0) : T(0));",
            "        };",
            "        RangeProcess(l, r, block_brute, block_quick);",
            "    }",
            " ",
            "    int Count(int l, int r)",
            "    {",
            "        int cnt = 0;",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            cnt += popcnt(submask(l, r));",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            cnt += popcnt(b[bi]);",
            "        };",
            "        RangeProcess(l, r, block_brute, block_quick);",
            "        return cnt;",
            "    }",
            " ",
            "    int FindFirst (int l, int r)",
            "    {",
            "        int pos = -1;",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            for(int i = l; i <= r and pos == -1; i ++)",
            "                if(Get(i))",
            "                    pos = i;    ",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            if(b[bi] == T(0) or pos != -1)",
            "                return;",
            " ",
            "            pos = ctz(b[bi]) + bi * B;",
            "        };",
            " ",
            "        RangeProcess(l, r, block_brute, block_quick);",
            "        return pos;",
            "    }",
            "    ",
            "    int FindLast(int l, int r)",
            "    {",
            "        int pos = -1;",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            for(int i = l; i <= r; i ++)",
            "                if(Get(i))",
            "                    pos = i;    ",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            if(b[bi] == T(0))",
            "                return;",
            " ",
            "            pos = B - clz(b[bi]) - 1 + bi * B;",
            "        };",
            " ",
            "        RangeProcess(l, r, block_brute, block_quick);",
            "        return pos;",
            "    }",
            "",
            "    friend std::ostream &operator<<(std::ostream &os, const BitsetChan &bitset)",
            "    {",
            "        for (int i = bitset.m - 1; i >= 0; --i)",
            "            os << std::bitset<B>(bitset.b[i]);",
            "        os << '\\\\n';",
            "        return os;",
            "    }",
            "};",
            "",
            "using BitsetChan64 = BitsetChan<uint64_t, bit_width(uint64_t())>;"
        ],
        "description": "Snippet for Bitset"
    },
    "TemplateRecursiveSegmentTreeSimple": {
        "prefix": "TemplateRecursiveSegmentTreeSimple",
        "body": [
            "template <typename Info>",
            "class SegTreeChan",
            "{",
            "public:",
            "    int n;",
            "    vector<Info> infos;",
            "",
            "    template<typename O>",
            "    void Recurse(int lb, int rb, bool update, O op)",
            "    {",
            "        auto rec = [&](int v, int l, int r, auto &&rec) -> void",
            "        {",
            "            if(l > r)",
            "                return;",
            "            ",
            "            if(lb <= l and r <= rb)",
            "            {",
            "                op(v, l, r);",
            "                return;",
            "            }",
            "            ",
            "            int m = (l + r)/2;",
            "            ",
            "            if(m >= lb)",
            "                rec(2 * v, l, m, rec);",
            "            if(m + 1 <= rb)",
            "                rec(2 * v + 1, m + 1, r, rec);",
            "            ",
            "            if(update)",
            "                infos[v] = infos[2 * v].Unite(infos[2 * v + 1]);",
            "        };",
            "        rec(1, 0, n - 1, rec);",
            "    };",
            "",
            "    SegTreeChan() : SegTreeChan(0) {};",
            "    SegTreeChan(int n) : SegTreeChan(vector<Info> (n)) {};",
            "    SegTreeChan(const vector<Info> &a) : ",
            "    n((int)a.size()), infos(4 * n + 5)",
            "    {",
            "        auto build = [&](int v, int l, int r, auto &&build) -> void",
            "        {",
            "            if(l > r)",
            "                return;",
            "            if(l == r)",
            "            {",
            "                infos[v] = Info(a[l]);",
            "                return;",
            "            }",
            "            int m = (l + r)/2;",
            "            build(v * 2, l, m, build);",
            "            build(v * 2 + 1, m + 1, r, build);",
            "            infos[v] = infos[v * 2].Unite(infos[v * 2 + 1]);",
            "        };",
            "        build(1, 0, n - 1, build);",
            "    };",
            "",
            "    void Set(int p, const Info &info)",
            "    {",
            "        Recurse(p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = info;",
            "        });",
            "    }",
            "    void Add(int p, const Info &info)",
            "    {",
            "        Recurse(p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infos[v].Unite(info);",
            "        });",
            "    }",
            "    Info Query(int lb, int rb)",
            "    {",
            "        Info res = Info();",
            "        Recurse(lb, rb, false, [&](int v, int l, int r)",
            "        {",
            "            res = res.Unite(infos[v]);",
            "        });",
            "        return res;",
            "    }",
            "    Info Get(int p)",
            "    {",
            "        Info res = Info();",
            "        Recurse(p, p, false, [&](int v, int l, int r)",
            "        {",
            "            res = infos[v];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for RecursiveSegmentTreeSimple"
    },
    "TemplateRecursiveSegmentTreeLazy": {
        "prefix": "TemplateRecursiveSegmentTreeLazy",
        "body": [
            "template <typename Info, typename Tag>",
            "class SegTreeChan",
            "{",
            "public:",
            "    int n;",
            "    vector<Info> infos;",
            "    vector<Tag> tags;",
            "",
            "    template<typename O>",
            "    void Recurse(int lb, int rb, bool update, O op)",
            "    {",
            "        auto rec = [&](int v, int l, int r, auto &&rec) -> void",
            "        {",
            "            Propagate(v, l, r);",
            "",
            "            if(l > r)",
            "                return;",
            "            ",
            "            if(lb <= l and r <= rb)",
            "            {",
            "                op(v, l, r);",
            "                return;",
            "            }",
            "            ",
            "            int m = (l + r)/2;",
            "            ",
            "            if(m >= lb)",
            "                rec(2 * v, l, m, rec);",
            "            else if(update)",
            "                Propagate(2 * v, l, m);",
            "",
            "            if(m + 1 <= rb)",
            "                rec(2 * v + 1, m + 1, r, rec);",
            "            else if(update)",
            "                Propagate(2 * v + 1, m + 1, r);",
            "            ",
            "            if(update)",
            "                infos[v] = infos[2 * v].Unite(infos[2 * v + 1]);",
            "        };",
            "        rec(1, 0, n - 1, rec);",
            "    };",
            "",
            "    SegTreeChan() : SegTreeChan(0) {};",
            "    SegTreeChan(int n) : SegTreeChan(vector<Info> (n)) {};",
            "    SegTreeChan(const vector<Info> &a) : ",
            "    n((int)a.size()), infos(4 * n + 5), tags(4 * n + 5)",
            "    {",
            "        auto build = [&](int v, int l, int r, auto &&build) -> void",
            "        {",
            "            if(l > r)",
            "                return;",
            "            if(l == r)",
            "            {",
            "                infos[v] = Info(a[l]);",
            "                return;",
            "            }",
            "            int m = (l + r)/2;",
            "            build(v * 2, l, m, build);",
            "            build(v * 2 + 1, m + 1, r, build);",
            "            infos[v] = infos[v * 2].Unite(infos[v * 2 + 1]);",
            "        };",
            "        build(1, 0, n - 1, build);",
            "    };",
            "",
            "    void Propagate(int v, int l, int r)",
            "    {",
            "        if(tags[v].Empty())",
            "            return;",
            "        tags[v].ApplyTo(infos[v], l, r);",
            "        if(l != r)",
            "        {",
            "            tags[v].ApplyTo(tags[2 * v]);",
            "            tags[v].ApplyTo(tags[2 * v  + 1]);",
            "        }",
            "        tags[v] = Tag();",
            "    }",
            "",
            "    void Modify(int lb, int rb, const Tag &tag)",
            "    {",
            "        Recurse(lb, rb, true, [&](int v, int l, int r)",
            "        {",
            "            tag.ApplyTo(tags[v]);",
            "            Propagate(v, l, r);",
            "        });",
            "    }",
            "    void Set(int p, const Info &info)",
            "    {",
            "        Recurse(p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = info;",
            "        });",
            "    }",
            "    void Add(int p, const Info &info)",
            "    {",
            "        Recurse(p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infos[v].Unite(info);",
            "            Propagate(v, l, r);",
            "        });",
            "    }",
            "    Info Query(int lb, int rb)",
            "    {",
            "        Info res = Info();",
            "        Recurse(lb, rb, false, [&](int v, int l, int r)",
            "        {",
            "            res = res.Unite(infos[v]);",
            "        });",
            "        return res;",
            "    }",
            "    Info Get(int p)",
            "    {",
            "        Info res = Info();",
            "        Recurse(p, p, false, [&](int v, int l, int r)",
            "        {",
            "            res = infos[v];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for RecursiveSegmentTreeLazy"
    },
    "TemplateSegmentTreeSimple": {
        "prefix": "TemplateSegmentTreeSimple",
        "body": [
            "template <typename Info>",
            "class SegTreeChan",
            "{",
            "public:",
            "    int n;",
            "    vector<Info> infos;",
            "    seg_tree::in_order_layout layout;",
            "",
            "    void UpdateNode(seg_tree::point a)",
            "    {",
            "        infos[a] = infos[a.c(0)].Unite(infos[a.c(1)]);",
            "    }",
            "",
            "    SegTreeChan(int n_) : SegTreeChan(vector<Info>(n_)) {}",
            "",
            "    SegTreeChan(const vector<Info> &a) : n(int(a.size()))",
            "    {",
            "        assert(n > 0);",
            "        infos.resize(2 * n);",
            "        layout = seg_tree::in_order_layout(n);",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            infos[layout.get_point(i)] = a[i];",
            "        }",
            "        for (int i = n - 1; i >= 1; i--)",
            "        {",
            "            infos[i] = infos[2 * i].Unite(infos[2 * i + 1]);",
            "        }",
            "    }",
            "",
            "    void Set(int p, const Info &v)",
            "    {",
            "        auto pt = layout.get_point(p);",
            "        infos[pt] = v;",
            "        pt.for_parents_up([&](seg_tree::point a)",
            "                          { UpdateNode(a); });",
            "    }",
            "",
            "    Info Query(int l, int r)",
            "    {",
            "        ++ r;",
            "        auto rng = layout.get_range(l, r);",
            "        Info res;",
            "        rng.for_each_l_to_r([&](seg_tree::point a)",
            "                            { res = res.Unite(infos[a]); });",
            "        return res;",
            "    }",
            "",
            "    Info Get(int p)",
            "    {",
            "        auto pt = layout.get_point(p);",
            "        return infos[pt];",
            "    }",
            "",
            "    //returns max `r` such that `f(sum[l, r]) = true` given that `f` is monotonic as `r` increases ",
            "    //if `(r > n)`, then `f(sum[l, n]) = true` ",
            "    //if `(r < l)`, then `f(sum[l, l]) = false`",
            "    template <typename F>",
            "    int MaxRight(int l, F f)",
            "    {",
            "        auto rng = layout.get_range(l, n);",
            "        int res = n;",
            "        Info sum;",
            "        rng.for_each_l_to_r([&](seg_tree::point a)",
            "        {",
            "            if (res != n) ",
            "            {",
            "                return;",
            "            }",
            "            auto new_sum = sum.Unite(infos[a]);",
            "            if (f(new_sum))",
            "            {",
            "                sum = new_sum;",
            "                return;",
            "            }",
            "            while (a < n) ",
            "            {",
            "                new_sum = sum.Unite(infos[a.c(0)]);",
            "                if (f(new_sum)) ",
            "                {",
            "                    sum = new_sum;",
            "                    a = a.c(1);",
            "                }",
            "                else",
            "                {",
            "                    a = a.c(0);",
            "                }",
            "            }",
            "            res = layout.get_node_bounds(a)[0];",
            "        });",
            "        -- res;",
            "        return min(n, res);",
            "    }",
            "",
            "    //returns min point l such that f(sum[l, r]) = true given that f is monotonic as l decreases",
            "    //if (l == 0), then f(sum[0, n]) = true",
            "    //if (l > r), then f(sum[r, r]) = false",
            "    template <typename F>",
            "    int MinLeft(int r, F f)",
            "    {",
            "        ++ r;",
            "        auto rng = layout.get_range(0, r);",
            "        int res = 0;",
            "        Info sum;",
            "        rng.for_each_r_to_l([&](seg_tree::point a)",
            "        {",
            "            if (res != 0) ",
            "            {",
            "                return;",
            "            }",
            "            ",
            "            auto new_sum = infos[a].Unite(sum);",
            "            if (f(new_sum))",
            "            {",
            "                sum = new_sum;",
            "                return;",
            "            }",
            "            while (a < n)",
            "            {",
            "                new_sum = infos[a.c(1)].Unite(sum);",
            "                if (f(new_sum)) ",
            "                {",
            "                    sum = new_sum;",
            "                    a = a.c(0);",
            "                }",
            "                else",
            "                {",
            "                    a = a.c(1);",
            "                }",
            "            }",
            "            res = layout.get_node_bounds(a)[1];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for SegmentTreeSimple"
    },
    "TemplateSegmentTreeLayout": {
        "prefix": "TemplateSegmentTreeLayout",
        "body": [
            "namespace seg_tree",
            "{",
            "    // Floor of log_2(a); index of highest 1-bit",
            "    inline int floor_log_2(int a)",
            "    {",
            "        return a ? bit_width(unsigned(a)) - 1 : -1;",
            "    }",
            "",
            "    class point",
            "    {",
            "    public:",
            "        int a;",
            "        point() : a(0) {}",
            "        explicit point(int a_) : a(a_) { assert(a >= -1); }",
            "",
            "        explicit operator bool() { return bool(a); }",
            "",
            "        // This is useful so you can directly do array indices",
            "        /* implicit */ operator int() const { return a; }",
            "",
            "        point c(bool z) const",
            "        {",
            "            return point((a << 1) | z);",
            "        }",
            "",
            "        point operator[](bool z) const",
            "        {",
            "            return c(z);",
            "        }",
            "",
            "        point p() const",
            "        {",
            "            return point(a >> 1);",
            "        }",
            "",
            "        friend std::ostream &operator<<(std::ostream &o, const point &p) { return o << int(p); }",
            "",
            "        template <typename F>",
            "        void for_each(F f) const",
            "        {",
            "            for (int v = a; v > 0; v >>= 1)",
            "            {",
            "                f(point(v));",
            "            }",
            "        }",
            "",
            "        template <typename F>",
            "        void for_parents_down(F f) const",
            "        {",
            "            // strictly greater than 0",
            "            for (int L = floor_log_2(a); L > 0; L--)",
            "            {",
            "                f(point(a >> L));",
            "            }",
            "        }",
            "",
            "        template <typename F>",
            "        void for_parents_up(F f) const",
            "        {",
            "            for (int v = a >> 1; v > 0; v >>= 1)",
            "            {",
            "                f(point(v));",
            "            }",
            "        }",
            "",
            "        point &operator++()",
            "        {",
            "            ++a;",
            "            return *this;",
            "        }",
            "        point operator++(int) { return point(a++); }",
            "        point &operator--()",
            "        {",
            "            --a;",
            "            return *this;",
            "        }",
            "        point operator--(int) { return point(a--); }",
            "    };",
            "",
            "    class range",
            "    {",
            "    public:",
            "        int a, b;",
            "        range() : a(1), b(1) {}",
            "        range(int a_, int b_) : a(a_), b(b_)",
            "        {",
            "            assert(1 <= a && a <= b && b <= 2 * a);",
            "        }",
            "        explicit range(std::array<int, 2> r) : range(r[0], r[1]) {}",
            "",
            "        explicit operator std::array<int, 2>() const",
            "        {",
            "            return {a, b};",
            "        }",
            "",
            "        const int &operator[](bool z) const",
            "        {",
            "            return z ? b : a;",
            "        }",
            "",
            "        friend std::ostream &operator<<(std::ostream &o, const range &r) { return o << \"[\" << r.a << \"..\" << r.b << \")\"; }",
            "",
            "        // Iterate over the range from outside-in.",
            "        //   Calls f(point a)",
            "        template <typename F>",
            "        void for_each(F f) const",
            "        {",
            "            for (int x = a, y = b; x < y; x >>= 1, y >>= 1)",
            "            {",
            "                if (x & 1)",
            "                    f(point(x++));",
            "                if (y & 1)",
            "                    f(point(--y));",
            "            }",
            "        }",
            "",
            "        // Iterate over the range from outside-in.",
            "        //   Calls f(point a, bool is_right)",
            "        template <typename F>",
            "        void for_each_with_side(F f) const",
            "        {",
            "            for (int x = a, y = b; x < y; x >>= 1, y >>= 1)",
            "            {",
            "                if (x & 1)",
            "                    f(point(x++), false);",
            "                if (y & 1)",
            "                    f(point(--y), true);",
            "            }",
            "        }",
            "",
            "        // Iterate over the range from left to right.",
            "        //    Calls f(point)",
            "        template <typename F>",
            "        void for_each_l_to_r(F f) const",
            "        {",
            "            int anc_depth = floor_log_2((a - 1) ^ b);",
            "            int anc_msk = (1 << anc_depth) - 1;",
            "            for (int v = (-a) & anc_msk; v; v &= v - 1)",
            "            {",
            "                int i = countr_zero(unsigned(v));",
            "                f(point(((a - 1) >> i) + 1));",
            "            }",
            "            for (int v = b & anc_msk; v;)",
            "            {",
            "                int i = floor_log_2(v);",
            "                f(point((b >> i) - 1));",
            "                v ^= (1 << i);",
            "            }",
            "        }",
            "",
            "        // Iterate over the range from right to left.",
            "        //    Calls f(point)",
            "        template <typename F>",
            "        void for_each_r_to_l(F f) const",
            "        {",
            "            int anc_depth = floor_log_2((a - 1) ^ b);",
            "            int anc_msk = (1 << anc_depth) - 1;",
            "            for (int v = b & anc_msk; v; v &= v - 1)",
            "            {",
            "                int i = countr_zero(unsigned(v));",
            "                f(point((b >> i) - 1));",
            "            }",
            "            for (int v = (-a) & anc_msk; v;)",
            "            {",
            "                int i = floor_log_2(v);",
            "                f(point(((a - 1) >> i) + 1));",
            "                v ^= (1 << i);",
            "            }",
            "        }",
            "",
            "        template <typename F>",
            "        void for_parents_down(F f) const",
            "        {",
            "            int x = a, y = b;",
            "            if ((x ^ y) > x)",
            "            {",
            "                x <<= 1, std::swap(x, y);",
            "            }",
            "            int dx = countr_zero(unsigned(x));",
            "            int dy = countr_zero(unsigned(y));",
            "            int anc_depth = floor_log_2((x - 1) ^ y);",
            "            for (int i = floor_log_2(x); i > dx; i--)",
            "            {",
            "                f(point(x >> i));",
            "            }",
            "            for (int i = anc_depth; i > dy; i--)",
            "            {",
            "                f(point(y >> i));",
            "            }",
            "        }",
            "",
            "        template <typename F>",
            "        void for_parents_up(F f) const",
            "        {",
            "            int x = a, y = b;",
            "            if ((x ^ y) > x)",
            "            {",
            "                x <<= 1, std::swap(x, y);",
            "            }",
            "            int dx = countr_zero(unsigned(x));",
            "            int dy = countr_zero(unsigned(y));",
            "            int anc_depth = floor_log_2((x - 1) ^ y);",
            "            for (int i = dx + 1; i <= anc_depth; i++)",
            "            {",
            "                f(point(x >> i));",
            "            }",
            "            for (int v = y >> (dy + 1); v; v >>= 1)",
            "            {",
            "                f(point(v));",
            "            }",
            "        }",
            "    };",
            "",
            "    class in_order_layout",
            "    {",
            "    public:",
            "        // Alias them in for convenience",
            "        using point = seg_tree::point;",
            "        using range = seg_tree::range;",
            "",
            "        int n, s;",
            "        in_order_layout() : n(0), s(0) {}",
            "        in_order_layout(int n_) : n(n_), s(n ? bit_ceil(unsigned(n)) : 0) {}",
            "",
            "        point get_point(int a) const",
            "        {",
            "            assert(0 <= a && a < n);",
            "            a += s;",
            "            return point(a >= 2 * n ? a - n : a);",
            "        }",
            "",
            "        range get_range(int a, int b) const",
            "        {",
            "            assert(0 <= a && a <= b && b <= n);",
            "            if (n == 0)",
            "                return range();",
            "            a += s, b += s;",
            "            return range((a >= 2 * n ? 2 * (a - n) : a), (b >= 2 * n ? 2 * (b - n) : b));",
            "        }",
            "",
            "        range get_range(std::array<int, 2> p) const",
            "        {",
            "            return get_range(p[0], p[1]);",
            "        }",
            "",
            "        int get_leaf_index(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(n <= a && a < 2 * n);",
            "            return (a < s ? a + n : a) - s;",
            "        }",
            "",
            "        std::array<int, 2> get_node_bounds(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(1 <= a && a < 2 * n);",
            "            int l = countl_zero(unsigned(a)) - countl_zero(unsigned(2 * n - 1));",
            "            int x = a << l, y = (a + 1) << l;",
            "            assert(s <= x && x < y && y <= 2 * s);",
            "            return {(x >= 2 * n ? (x >> 1) + n : x) - s, (y >= 2 * n ? (y >> 1) + n : y) - s};",
            "        }",
            "",
            "        int get_node_split(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(1 <= a && a < n);",
            "            int l = countl_zero(unsigned(2 * a + 1)) - countl_zero(unsigned(2 * n - 1));",
            "            int x = (2 * a + 1) << l;",
            "            assert(s <= x && x < 2 * s);",
            "            return (x >= 2 * n ? (x >> 1) + n : x) - s;",
            "        }",
            "",
            "        int get_node_size(point pt) const",
            "        {",
            "            auto bounds = get_node_bounds(pt);",
            "            return bounds[1] - bounds[0];",
            "        }",
            "    };",
            "",
            "    class circular_layout",
            "    {",
            "    public:",
            "        // Alias them in for convenience",
            "        using point = seg_tree::point;",
            "        using range = seg_tree::range;",
            "",
            "        int n;",
            "        circular_layout() : n(0) {}",
            "        circular_layout(int n_) : n(n_) {}",
            "",
            "        point get_point(int a) const",
            "        {",
            "            assert(0 <= a && a < n);",
            "            return point(n + a);",
            "        }",
            "",
            "        range get_range(int a, int b) const",
            "        {",
            "            assert(0 <= a && a <= b && b <= n);",
            "            if (n == 0)",
            "                return range();",
            "            return range(n + a, n + b);",
            "        }",
            "",
            "        range get_range(std::array<int, 2> p) const",
            "        {",
            "            return get_range(p[0], p[1]);",
            "        }",
            "",
            "        int get_leaf_index(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(n <= a && a < 2 * n);",
            "            return a - n;",
            "        }",
            "",
            "        // Returns {x,y} so that 0 <= x < n and 1 <= y <= n",
            "        // If the point is non-wrapping, then 0 <= x < y <= n",
            "        std::array<int, 2> get_node_bounds(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(1 <= a && a < 2 * n);",
            "            int l = countl_zero(unsigned(a)) - countl_zero(unsigned(2 * n - 1));",
            "            int s = bit_ceil(unsigned(n));",
            "            int x = a << l, y = (a + 1) << l;",
            "            assert(s <= x && x < y && y <= 2 * s);",
            "            return {(x >= 2 * n ? x >> 1 : x) - n, (y > 2 * n ? y >> 1 : y) - n};",
            "        }",
            "",
            "        // Returns the split point of the node, such that 1 <= s <= n.",
            "        int get_node_split(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(1 <= a && a < n);",
            "            return get_node_bounds(pt.c(0))[1];",
            "        }",
            "",
            "        int get_node_size(point pt) const",
            "        {",
            "            auto bounds = get_node_bounds(pt);",
            "            int r = bounds[1] - bounds[0];",
            "            return r > 0 ? r : r + n;",
            "        }",
            "    };",
            "}"
        ],
        "description": "Snippet for SegmentTreeLayout"
    },
    "TemplateMonoid": {
        "prefix": "TemplateMonoid",
        "body": [
            "class InfoChan",
            "{",
            "public:",
            "    int sum = 0;",
            "",
            "    InfoChan() : sum(0) {};",
            "    InfoChan(int x) : sum(x) {};",
            "",
            "    InfoChan Unite(InfoChan b) const ",
            "    {",
            "        InfoChan res(sum + b.sum);",
            "        return res;",
            "    }",
            "    static InfoChan GetDefault([[maybe_unused]] int l, [[maybe_unused]] int r)",
            "    {",
            "        return InfoChan();",
            "    }",
            "};",
            "class TagChan",
            "{",
            "public:",
            "    int add = 0;",
            "",
            "    TagChan() : add(0) {};",
            "    TagChan(int x) : add(x) {};",
            "",
            "    bool ApplyTo(InfoChan &a, [[maybe_unused]] int l, [[maybe_unused]] int r) const",
            "    {",
            "        a.sum += add * (r - l + 1);",
            "        return true;",
            "    }",
            "    void ApplyTo(TagChan &t) const",
            "    {",
            "        t.add += add;",
            "    }",
            "    bool Empty() const",
            "    {",
            "        return add == 0;",
            "    }",
            "};"
        ],
        "description": "Snippet for Monoid"
    },
    "TemplateSegmentTreeLazy": {
        "prefix": "TemplateSegmentTreeLazy",
        "body": [
            "template <typename Info, typename Tag>",
            "class LazySegTreeChan",
            "{",
            "public:",
            "    int n;",
            "    vector<Info> infos;",
            "    vector<Tag> tags;",
            "    seg_tree::in_order_layout layout;",
            "",
            "    void Apply(seg_tree::point a, const Tag &t)",
            "    {",
            "        auto [l, r] = layout.get_node_bounds(a);",
            "        if (!t.ApplyTo(infos[a], l, r - 1))     //r - 1 to make inclusive",
            "        {",
            "            assert(a < n);",
            "            DowndateNode(a);",
            "            Apply(a.c(0), t);",
            "            Apply(a.c(1), t);",
            "            UpdateNode(a);",
            "            return;",
            "        }",
            "        if (a < n)",
            "        {",
            "            t.ApplyTo(tags[a]);",
            "        }",
            "    }",
            "",
            "    void DowndateNode(seg_tree::point a)",
            "    {",
            "        if (!tags[a].Empty())",
            "        {",
            "            Apply(a.c(0), tags[a]);",
            "            Apply(a.c(1), tags[a]);",
            "            tags[a] = Tag();",
            "        }",
            "    }",
            "",
            "    void UpdateNode(seg_tree::point a)",
            "    {",
            "        infos[a] = infos[a.c(0)].Unite(infos[a.c(1)]);",
            "    }",
            "",
            "    LazySegTreeChan() : LazySegTreeChan(0) {}",
            "    LazySegTreeChan(int n_) : LazySegTreeChan(vector<Info>(n_)) {}",
            "    LazySegTreeChan(const vector<Info> &a) : n(int(a.size()))",
            "    {",
            "        infos.resize(2 * n);",
            "        tags.resize(n);",
            "        layout = seg_tree::in_order_layout(n);",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            infos[layout.get_point(i)] = a[i];",
            "        }",
            "        for (int i = n - 1; i >= 1; i--)",
            "        {",
            "            UpdateNode(seg_tree::point(i));",
            "        }",
            "    }",
            "",
            "    void Modify(int l, int r, const Tag &t)",
            "    {",
            "        ++ r;",
            "        auto rng = layout.get_range(l, r);",
            "        rng.for_parents_down([&](seg_tree::point a)",
            "                            { DowndateNode(a); });",
            "        rng.for_each([&](seg_tree::point a)",
            "                     { Apply(a, t); });",
            "        rng.for_parents_up([&](seg_tree::point a)",
            "                            { UpdateNode(a); });",
            "    }",
            "",
            "    void Set(int p, const Info &v)",
            "    {",
            "        auto pt = layout.get_point(p);",
            "        pt.for_parents_down([&](seg_tree::point a)",
            "                            { DowndateNode(a); });",
            "        infos[pt] = v;",
            "        pt.for_parents_up([&](seg_tree::point a)",
            "                          { UpdateNode(a); });",
            "    }",
            "",
            "    Info Query(int l, int r)",
            "    {",
            "        ++ r;",
            "        auto rng = layout.get_range(l, r);",
            "        rng.for_parents_down([&](seg_tree::point a)",
            "                             { DowndateNode(a); });",
            "        Info res;",
            "        rng.for_each_l_to_r([&](seg_tree::point a)",
            "                            { res = res.Unite(infos[a]); });",
            "        return res;",
            "    }",
            "",
            "    Info Get(int p)",
            "    {",
            "        auto pt = layout.get_point(p);",
            "        pt.for_parents_down([&](seg_tree::point a)",
            "                            { DowndateNode(a); });",
            "        return infos[pt];",
            "    }",
            "",
            "    //returns max point r such that f(sum[l, r]) = true given that f is monotonic as r increases ",
            "    //if (r > n), then f(sum[l, n]) = true ",
            "    //if (r < l), then f(sum[l, l]) = false",
            "    template <typename F>",
            "    int MaxRight(int l, F f)",
            "    {",
            "        auto rng = layout.get_range(l, n);",
            "        rng.for_parents_down([&](seg_tree::point a) { DowndateNode(a); });",
            "        ",
            "        int res = n;",
            "        Info sum;",
            "        rng.for_each_l_to_r([&](seg_tree::point a)",
            "        {",
            "            if (res != n)",
            "            {",
            "                return;",
            "            }",
            "            auto new_sum = sum.Unite(infos[a]);",
            "            if (f(new_sum)) ",
            "            {",
            "                sum = new_sum;",
            "                return;",
            "            }",
            "            while (a < n)",
            "            {",
            "                DowndateNode(a);",
            "                new_sum = sum.Unite(infos[a.c(0)]);",
            "                if (f(new_sum))",
            "                {",
            "                    sum = new_sum;",
            "                    a = a.c(1);",
            "                } ",
            "                else",
            "                {",
            "                    a = a.c(0);",
            "                }",
            "            }",
            "            res = layout.get_node_bounds(a)[0];",
            "        });",
            "        -- res;",
            "        return min(res, n);",
            "    }",
            "",
            "    //returns min point l such that f(sum[l, r]) = true given that f is monotonic as l decreases",
            "    //if (l == 0), then f(sum[0, n]) = true",
            "    //if (l > r), then f(sum[r, r]) = false",
            "    template <typename F>",
            "    int MinLeft(int r, F f)",
            "    {",
            "        ++ r;",
            "        auto rng = layout.get_range(0, r);",
            "        rng.for_parents_down([&](seg_tree::point a) { DowndateNode(a); });",
            "        ",
            "        int res = 0;",
            "        Info sum;",
            "        rng.for_each_r_to_l([&](seg_tree::point a)",
            "        {",
            "            if (res != 0) ",
            "            {",
            "                return;",
            "            }",
            "            auto new_sum = infos[a].Unite(sum);",
            "            if (f(new_sum))",
            "            {",
            "                sum = new_sum;",
            "                return;",
            "            }",
            "            while (a < n)",
            "            {",
            "                DowndateNode(a);",
            "                new_sum = infos[a.c(1)].Unite(sum);",
            "                if (f(new_sum))",
            "                {",
            "                    sum = new_sum;",
            "                    a = a.c(0);",
            "                }",
            "                else",
            "                {",
            "                    a = a.c(1);",
            "                }",
            "            }",
            "            res = layout.get_node_bounds(a)[1];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for SegmentTreeLazy"
    },
    "TemplateRecursiveSegmentTreeDynamicLazy": {
        "prefix": "TemplateRecursiveSegmentTreeDynamicLazy",
        "body": [
            "template <typename Info, typename Tag>",
            "class SegTreeChan",
            "{",
            "public:",
            "    int n;",
            "    vector<Info> infos;",
            "    vector<Tag> tags;",
            "",
            "    template<typename O>",
            "    void Recurse(int lb, int rb, bool update, O op)",
            "    {",
            "        auto rec = [&](int v, int l, int r, auto &&rec) -> void",
            "        {",
            "            Propagate(v, l, r);",
            "",
            "            if(l > r)",
            "                return;",
            "            ",
            "            if(lb <= l and r <= rb)",
            "            {",
            "                op(v, l, r);",
            "                return;",
            "            }",
            "            ",
            "            int m = (l + r)/2;",
            "            ",
            "            if(m >= lb)",
            "                rec(2 * v, l, m, rec);",
            "            else if(update)",
            "                Propagate(2 * v, l, m);",
            "",
            "            if(m + 1 <= rb)",
            "                rec(2 * v + 1, m + 1, r, rec);",
            "            else if(update)",
            "                Propagate(2 * v + 1, m + 1, r);",
            "            ",
            "            if(update)",
            "                infos[v] = infos[2 * v].Unite(infos[2 * v + 1]);",
            "        };",
            "        rec(1, 0, n - 1, rec);",
            "    };",
            "",
            "    SegTreeChan() : SegTreeChan(0) {};",
            "    SegTreeChan(int n) : SegTreeChan(vector<Info> (n)) {};",
            "    SegTreeChan(const vector<Info> &a) : ",
            "    n((int)a.size()), infos(4 * n + 5), tags(4 * n + 5)",
            "    {",
            "        auto build = [&](int v, int l, int r, auto &&build) -> void",
            "        {",
            "            if(l > r)",
            "                return;",
            "            if(l == r)",
            "            {",
            "                infos[v] = Info(a[l]);",
            "                return;",
            "            }",
            "            int m = (l + r)/2;",
            "            build(v * 2, l, m, build);",
            "            build(v * 2 + 1, m + 1, r, build);",
            "            infos[v] = infos[v * 2].Unite(infos[v * 2 + 1]);",
            "        };",
            "        build(1, 0, n - 1, build);",
            "    };",
            "",
            "    void Propagate(int v, int l, int r)",
            "    {",
            "        if(tags[v].Empty())",
            "            return;",
            "        tags[v].ApplyTo(infos[v], l, r);",
            "        if(l != r)",
            "        {",
            "            tags[v].ApplyTo(tags[2 * v]);",
            "            tags[v].ApplyTo(tags[2 * v  + 1]);",
            "        }",
            "        tags[v] = Tag();",
            "    }",
            "",
            "    void Modify(int lb, int rb, const Tag &tag)",
            "    {",
            "        Recurse(lb, rb, true, [&](int v, int l, int r)",
            "        {",
            "            tag.ApplyTo(tags[v]);",
            "            Propagate(v, l, r);",
            "        });",
            "    }",
            "    void Set(int p, const Info &info)",
            "    {",
            "        Recurse(p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = info;",
            "        });",
            "    }",
            "    void Add(int p, const Info &info)",
            "    {",
            "        Recurse(p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infos[v].Unite(info);",
            "            Propagate(v, l, r);",
            "        });",
            "    }",
            "    Info Query(int lb, int rb)",
            "    {",
            "        Info res = Info();",
            "        Recurse(lb, rb, false, [&](int v, int l, int r)",
            "        {",
            "            res = res.Unite(infos[v]);",
            "        });",
            "        return res;",
            "    }",
            "    Info Get(int p)",
            "    {",
            "        Info res = Info();",
            "        Recurse(p, p, false, [&](int v, int l, int r)",
            "        {",
            "            res = infos[v];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for RecursiveSegmentTreeDynamicLazy"
    },
    "TemplateDynamicMonoid": {
        "prefix": "TemplateDynamicMonoid",
        "body": [
            "class InfoChan",
            "{",
            "public:",
            "    InfoChan *left, *right;",
            "    int sum = 0;",
            "",
            "    InfoChan() : sum(0) {};",
            "    InfoChan(int x) : sum(x) {};",
            "",
            "    InfoChan Unite(InfoChan b) const ",
            "    {",
            "        InfoChan res(sum + b.sum);",
            "        return res;",
            "    }",
            "    static InfoChan GetDefault([[maybe_unused]] int l, [[maybe_unused]] int r)",
            "    {",
            "        return InfoChan();",
            "    }",
            "",
            "    InfoChan Grow()",
            "    {",
            "        if(left == nullptr)",
            "        {",
            "            left = new InfoChan();",
            "            right = new InfoChan();",
            "        }",
            "    }",
            "};",
            "",
            "class TagChan",
            "{",
            "public:",
            "    int add = 0;",
            "",
            "    TagChan() : add(0) {};",
            "    TagChan(int x) : add(x) {};",
            "",
            "    bool ApplyTo(InfoChan &a, [[maybe_unused]] int l, [[maybe_unused]] int r) const",
            "    {",
            "        a.sum += add * (r - l + 1);",
            "        return true;",
            "    }",
            "    void ApplyTo(TagChan &t) const",
            "    {",
            "        t.add += add;",
            "    }",
            "    bool Empty() const",
            "    {",
            "        return add == 0;",
            "    }",
            "};"
        ],
        "description": "Snippet for DynamicMonoid"
    },
    "TemplateRecursiveSegmentTreeDynamicSimple": {
        "prefix": "TemplateRecursiveSegmentTreeDynamicSimple",
        "body": [],
        "description": "Snippet for RecursiveSegmentTreeDynamicSimple"
    },
    "TemplateBSTNode": {
        "prefix": "TemplateBSTNode",
        "body": [
            "class BSTNodeChan",
            "{",
            "public:",
            "    ",
            "};"
        ],
        "description": "Snippet for BSTNode"
    }
}