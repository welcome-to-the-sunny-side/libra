{
    "sport": {
        "prefix": "sport",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"../libra/misc/dbg.h\"",
            "#else",
            "#define debug(...)",
            "#define endl \"\\\\n\"",
            "#endif",
            "",
            "signed main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int t = 1;",
            "    cin >> t;",
            "    while(t --)",
            "    {",
            "        $0",
            "    }",
            "}"
        ],
        "description": "Snippet for template (normal version)"
    },
    "sport_hacker": {
        "prefix": "sport_hacker",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"../libra/misc/dbg.h\"",
            "#else",
            "#define debug(...)",
            "#define endl \"\\\\n\"",
            "#endif",
            "",
            "void main_()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int t = 1;",
            "    cin >> t;",
            "    for(int tt = 1; tt <= t; tt ++)",
            "    {",
            "        ifstream fin(\"inp.txt\");",
            "        ofstream fout(\"out.txt\");",
            "",
            "        $0",
            "    }",
            "}",
            "",
            "static void run_with_stack_size(void (*func)(void), size_t stsize)",
            "{",
            "    char *stack, *send;",
            "    stack = (char *)malloc(stsize);",
            "    send = stack + stsize - 16;",
            "    send = (char *)((uintptr_t)send / 16 * 16);",
            "    asm volatile(",
            "        \"mov %%rsp, (%0)\\\\n\"",
            "        \"mov %0, %%rsp\\\\n\"",
            "        :",
            "        : \"r\"(send));",
            "    func();",
            "    asm volatile(\"mov (%0), %%rsp\\\\n\" : : \"r\"(send));",
            "    free(stack);",
            "}",
            "",
            "int32_t main()",
            "{",
            "    run_with_stack_size(main_, 1024 * 1024 * 1024); // run with a 1 GiB stack",
            "    return 0;",
            "}"
        ],
        "description": "Snippet for hacker_cup (normal version)"
    },
    "template_random": {
        "prefix": "template_random",
        "body": [
            "struct random : std::mt19937",
            "{",
            "    using std::mt19937::mt19937;",
            "    using std::mt19937::operator();",
            "    static int64_t gen_seed()",
            "    {",
            "        return std::chrono::steady_clock::now().time_since_epoch().count();",
            "    }",
            "    random() : std::mt19937(gen_seed()) {}",
            "    template <class Int>",
            "    auto operator()(Int a, Int b)",
            "        -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(a, b)(*this);",
            "    }",
            "    template <class Int>",
            "    auto operator()(Int a) -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(0, a - 1)(*this);",
            "    }",
            "    template <class Real>",
            "    auto operator()(Real a, Real b)",
            "        -> std::enable_if_t<std::is_floating_point_v<Real>, Real>",
            "    {",
            "        return std::uniform_real_distribution<Real>(a, b)(*this);",
            "    }",
            "};"
        ],
        "description": "Snippet for random (normal version)"
    },
    "template_pragma": {
        "prefix": "template_pragma",
        "body": [
            "#include <bits/allocator.h>",
            "#pragma GCC optimize(\"O3,unroll-loops\")",
            "#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")"
        ],
        "description": "Snippet for pragma (normal version)"
    },
    "template_random64": {
        "prefix": "template_random64",
        "body": [
            "struct random64 : std::mt19937_64",
            "{",
            "    using std::mt19937_64::mt19937_64;",
            "    using std::mt19937_64::operator();",
            "",
            "    static int64_t gen_seed()",
            "    {",
            "        return std::chrono::steady_clock::now().time_since_epoch().count();",
            "    }",
            "",
            "    random64() : std::mt19937_64(gen_seed()) {}",
            "",
            "    template <class Int>",
            "    auto operator()(Int a, Int b)",
            "        -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(a, b)(*this);",
            "    }",
            "",
            "    template <class Int>",
            "    auto operator()(Int a)",
            "        -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(0, a - 1)(*this);",
            "    }",
            "",
            "    template <class Real>",
            "    auto operator()(Real a, Real b)",
            "        -> std::enable_if_t<std::is_floating_point_v<Real>, Real>",
            "    {",
            "        return std::uniform_real_distribution<Real>(a, b)(*this);",
            "    }",
            "};"
        ],
        "description": "Snippet for random64 (normal version)"
    },
    "template_time": {
        "prefix": "template_time",
        "body": [
            "auto start = std::chrono::high_resolution_clock::now();",
            "// Code to benchmark",
            "auto end = std::chrono::high_resolution_clock::now();",
            "auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();",
            "std::cout << \"Execution time: \" << duration << \" microseconds\" << std::endl;"
        ],
        "description": "Snippet for time (normal version)"
    },
    "template_SolnCorrect": {
        "prefix": "template_SolnCorrect",
        "body": [
            "#include<bits/stdc++.h>",
            "#pragma GCC optimize(\"O3\")",
            "",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"/dbg.h\"",
            "#else",
            "#define endl \"\\\\n\"",
            "#define debug(...)",
            "#endif",
            "",
            "const int64_t inf = 1e9+9, INF = 1e18;",
            "",
            "//#define int int64_t",
            "",
            "const int N = 3e5+5;",
            "",
            "int32_t main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int a, b;",
            "    cin >> a >> b;",
            "    cout << a + b << endl;",
            "}"
        ],
        "description": "Snippet for SolnCorrect (normal version)"
    },
    "template_TestGenerator": {
        "prefix": "template_TestGenerator",
        "body": [
            "#include<bits/stdc++.h>",
            "#pragma GCC optimize(\"O3\")",
            "",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"/dbg.h\"",
            "#else",
            "#define endl \"\\\\n\"",
            "#define debug(...)",
            "#endif",
            "",
            "const int64_t inf = 1e9+9, INF = 1e18;",
            "",
            "//#define int int64_t",
            "",
            "const int N = 3e5+5;",
            "",
            "int32_t main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int a = rand() % 10, b = rand() % 10;",
            "    cout << a << \" \" << b << endl; ",
            "}"
        ],
        "description": "Snippet for TestGenerator (normal version)"
    },
    "template_SolnMy": {
        "prefix": "template_SolnMy",
        "body": [
            "#include<bits/stdc++.h>",
            "#pragma GCC optimize(\"O3\")",
            "",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"/dbg.h\"",
            "#else",
            "#define endl \"\\\\n\"",
            "#define debug(...)",
            "#endif",
            "",
            "const int64_t inf = 1e9+9, INF = 1e18;",
            "",
            "//#define int int64_t",
            "",
            "const int N = 3e5+5;",
            "",
            "int32_t main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int a, b;",
            "    cin >> a >> b;",
            "    cout << a + b << endl;",
            "}"
        ],
        "description": "Snippet for SolnMy (normal version)"
    },
    "template_ordered_set": {
        "prefix": "template_ordered_set",
        "body": [
            "// #include<bits/extc++.h>",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "",
            "template <typename K, typename V, typename Comp = std::less<K>>",
            "using ordered_map = __gnu_pbds::tree<",
            "    K, V, Comp,",
            "    __gnu_pbds::rb_tree_tag,",
            "    __gnu_pbds::tree_order_statistics_node_update",
            ">;",
            "",
            "template <typename K, typename Comp = std::less<K>>",
            "using ordered_set = ordered_map<K, __gnu_pbds::null_type, Comp>;",
            "",
            "// Supports",
            "//  auto iterator = ordered_set().find_by_order(idx); // (0-indexed)",
            "//  int num_strictly_smaller = ordered_set().order_of_key(key);"
        ],
        "description": "Snippet for ordered_set (normal version)"
    },
    "template_hash_map": {
        "prefix": "template_hash_map",
        "body": [
            "// #include<bits/extc++.h>",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "",
            "struct splitmix64_hash {",
            "    static uint64_t splitmix64(uint64_t x) {",
            "        // http://xorshift.di.unimi.it/splitmix64.c",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            "",
            "    size_t operator()(uint64_t x) const {",
            "        static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "    }",
            "};",
            "",
            "template <typename K, typename V, typename Hash = splitmix64_hash>",
            "using HashMap = __gnu_pbds::gp_hash_table<K, V, Hash>;",
            "",
            "template <typename K, typename Hash = splitmix64_hash>",
            "using HashSet = HashMap<K, __gnu_pbds::null_type, Hash>;"
        ],
        "description": "Snippet for hash_map (normal version)"
    },
    "template_int_128": {
        "prefix": "template_int_128",
        "body": [
            "// int128 bit for numbers larger than 1e18. Will support numbers till 1e36",
            "// Comment out everything related to PBDS while using this",
            "// Put all the code in the same order",
            "",
            "// Typedef to ell",
            "typedef __int128 ell;",
            "",
            "// For printing",
            "std::ostream&",
            "operator<<( std::ostream& dest, __int128_t value ) {",
            "\tstd::ostream::sentry s( dest );",
            "\tif ( s ) {",
            "\t\t__uint128_t tmp = value < 0 ? -value : value; char buffer[ 128 ];",
            "\t\tchar* d = std::end( buffer );",
            "\t\tdo {\t-- d; *d = \"0123456789\"[ tmp % 10 ]; tmp /= 10;} while ( tmp != 0 );",
            "\t\tif ( value < 0 ) {-- d; *d = '-';}",
            "\t\tint len = std::end( buffer ) - d;",
            "\t\tif ( dest.rdbuf()->sputn( d, len ) != len ) {dest.setstate( std::ios_base::badbit );}",
            "\t}",
            "\treturn dest;",
            "}",
            "",
            "// For reading _int128 to_read = read()",
            "__int128 read() {",
            "\t__int128 x = 0, f = 1;",
            "\tchar ch = getchar();",
            "\twhile (ch < '0' || ch > '9') {if (ch == '-') f = -1; ch = getchar();}",
            "\twhile (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}",
            "\treturn x * f;",
            "}",
            "",
            "// For debugging",
            "void _print(ell t) {cerr << t;}"
        ],
        "description": "Snippet for int_128 (normal version)"
    },
    "template_min_pq": {
        "prefix": "template_min_pq",
        "body": [
            "template<typename T>",
            "using MinPQ = priority_queue<T, vector<T>, greater<T>>;"
        ],
        "description": "Snippet for min_pq (normal version)"
    },
    "template_fast_io": {
        "prefix": "template_fast_io",
        "body": [
            "namespace fast_io",
            "{",
            "    /*",
            "    warning:",
            "        remove custom fastio things",
            "    ",
            "    usage:",
            "        https://codeforces.com/contest/659/submission/128052727",
            "    */",
            "",
            "\tconstexpr int SIZE = (1 << 21) + 1;",
            "\tint num = 0, f;",
            "\tchar ibuf[SIZE], obuf[SIZE], que[65], *iS, *iT, *oS = obuf, *oT = obuf + SIZE - 1, c;",
            "\t#define gc() (iS == iT ? (iT = ((iS = ibuf) + fread(ibuf, 1, SIZE, stdin)), (iS == iT ? EOF : *iS ++)) : *iS ++)",
            "\tinline void flush()",
            "    {",
            "\t\tfwrite(obuf, 1, oS - obuf, stdout);",
            "\t\toS = obuf;",
            "\t}",
            "\tinline void putc(char c)",
            "    {",
            "\t\t*oS ++ = c;",
            "\t\tif (oS == oT) flush();",
            "\t}",
            "\tinline void getc(char &c) ",
            "    {",
            "\t\tfor (c = gc(); (c == ' ' || c == '\\\\0' || c == '\\\\n') && c != EOF; c = gc());",
            "\t}",
            "\tinline void reads(char *st) ",
            "    {",
            "\t\tchar c;",
            "\t\tint n = 0; ",
            "\t\tgetc(st[++ n]);",
            "\t\tfor (c = gc(); c != ' ' && c != '\\\\0' && c != '\\\\n' && c != EOF ; c = gc()) st[++ n] = c;",
            "\t\tst[++ n] = '\\\\0';",
            "\t}",
            "\ttemplate<class I>",
            "\tinline void read(I &x) ",
            "    {",
            "\t\tfor (f = 1, c = gc(); c < '0' || c > '9' ; c = gc()) if (c == '-') f = -1;",
            "\t\tfor (x = 0; c >= '0' && c <= '9' ; c = gc()) x = (x << 3) + (x << 1) + (c & 15);",
            "\t\tx *= f;",
            "\t}",
            "\ttemplate<class I>",
            "\tinline void print(I x) ",
            "    {",
            "\t\tif (x < 0) putc('-'), x = -x;",
            "\t\tif (!x) putc('0');",
            "\t\twhile (x) que[++ num] = x % 10 + 48, x /= 10;",
            "\t\twhile (num) putc(que[num --]);",
            "\t}",
            "\tinline void putstr(string st) ",
            "    {",
            "\t\tfor (int i = 0; i < (int)st.size() ; ++ i)  putc(st[i]);",
            "\t}",
            "\tstruct Flusher_{~Flusher_(){flush();}} io_Flusher_;",
            "}",
            "using fast_io :: read;",
            "using fast_io :: putc;",
            "using fast_io :: putstr;",
            "using fast_io :: getc;",
            "using fast_io :: reads;",
            "using fast_io :: print;"
        ],
        "description": "Snippet for fast_io (normal version)"
    },
    "template_fast_set": {
        "prefix": "template_fast_set",
        "body": [
            "// https://codeforces.com/contest/1641/submission/147448352",
            "",
            "// D : 3 -> 2.6 * 10 ^ 5",
            "// D : 4 -> 1.6 * 10 ^ 7",
            "// D : 5 -> 1.0 * 10 ^ 9",
            "// D : 6 -> int \u306e\u7bc4\u56f2\u5168\u90e8",
            "",
            "const int not_found = 262144;",
            "",
            "template <const int D = 6> struct FastSet {",
            "    int n;",
            "    using u64 = uint64_t;",
            "    vector<u64> a[D];",
            "    FastSet(int n_ = (1 << std::min(31, D * 6))) : n(n_) {",
            "        for(int i = 0; i < D; i++) {",
            "            n_ = (n_ + 63) >> 6;",
            "            a[i].assign(n_, 0);",
            "        }",
            "    }",
            "    bool empty() const { return !a[D - 1][0]; }",
            "    bool contains(int x) const { return (a[0][x >> 6] >> (x & 63)) & 1; }",
            "    void insert(int x) {",
            "        for(int i = 0; i < D; i++) {",
            "            const int y = x & 63;",
            "            x >>= 6;",
            "            a[i][x] |= 1ULL << y;",
            "        }",
            "    }",
            "    void erase(int x) {",
            "        for(int i = 0; i < D; i++) {",
            "            const int y = x & 63;",
            "            x >>= 6;",
            "            if((a[i][x] &= ~(1ULL << y))) break;",
            "        }",
            "    }",
            "    int next(int x) const {             //smallest element >= x, returns 262144 if no such element",
            "        for(int i = 0; i < D; i++) {",
            "            const int k = x >> 6, y = x & 63;",
            "            if(k >= a[i].size()) return n;",
            "            const u64 top = a[i][k] >> y;",
            "            if(top) {",
            "                x += __builtin_ctzll(top);",
            "                for(int j = i - 1; j >= 0; --j) x = x << 6 | __builtin_ctzll(a[j][x]);",
            "                return x;",
            "            }",
            "            x = k + 1;",
            "        }",
            "        return n;",
            "    }",
            "    int prev(int x) const {            //largest element <= x",
            "        for(int i = 0; i < D; ++i) {",
            "            if(x < 0) return -1;",
            "            const int k = x >> 6, y = x & 63;",
            "            const u64 bot = a[i][k] << (63 - y);",
            "            if(bot) {",
            "                x -= __builtin_clzll(bot);",
            "                for(int j = i - 1; j >= 0; --j) x = x << 6 | (63 - __builtin_clzll(a[j][x]));",
            "                return x;",
            "            }",
            "            x = k - 1;",
            "        }",
            "        return -1;",
            "    }",
            "    int max() const { return prev(n); }",
            "    int min() const { return next(0); }",
            "};"
        ],
        "description": "Snippet for fast_set (normal version)"
    },
    "template_ultra_fast_set": {
        "prefix": "template_ultra_fast_set",
        "body": [
            "using uint = unsigned int;",
            "using ull = unsigned long long;",
            "constexpr ull lowest_bitsll[] = {0ull, 1ull, 3ull, 7ull, 15ull, 31ull, 63ull, 127ull, 255ull, 511ull, 1023ull, 2047ull, 4095ull, 8191ull, 16383ull, 32767ull, 65535ull, 131071ull, 262143ull, 524287ull, 1048575ull, 2097151ull, 4194303ull, 8388607ull, 16777215ull, 33554431ull, 67108863ull, 134217727ull, 268435455ull, 536870911ull, 1073741823ull, 2147483647ull, 4294967295ull, 8589934591ull, 17179869183ull, 34359738367ull, 68719476735ull, 137438953471ull, 274877906943ull, 549755813887ull, 1099511627775ull, 2199023255551ull, 4398046511103ull, 8796093022207ull, 17592186044415ull, 35184372088831ull, 70368744177663ull, 140737488355327ull, 281474976710655ull, 562949953421311ull, 1125899906842623ull, 2251799813685247ull, 4503599627370495ull, 9007199254740991ull, 18014398509481983ull, 36028797018963967ull, 72057594037927935ull, 144115188075855871ull, 288230376151711743ull, 576460752303423487ull, 1152921504606846975ull, 2305843009213693951ull, 4611686018427387903ull, 9223372036854775807ull, 18446744073709551615ull};",
            "const uint NO = 1 << 20; // This value will be returned in lower_bound functions, if no answer exists. Change, if need.",
            "template <uint MAXN>     // Can correctly work with numbers in range [0; MAXN]",
            "class godgod_suc_pred",
            "{",
            "    static const uint PREF = (MAXN <= 64 ? 0 : MAXN <= 4096     ? 1",
            "                                           : MAXN <= 262144     ? 1 + 64",
            "                                           : MAXN <= 16777216   ? 1 + 64 + 4096",
            "                                           : MAXN <= 1073741824 ? 1 + 64 + 4096 + 262144",
            "                                                                : 227) +",
            "                             1;",
            "    static const uint SZ = PREF + (MAXN + 63) / 64 + 1;",
            "    ull m[SZ] = {0};",
            "",
            "    inline uint left(uint v) const { return (v - 62) * 64; }",
            "    inline uint parent(uint v) const { return v / 64 + 62; }",
            "    inline void setbit(uint v) { m[v >> 6] |= 1ull << (v & 63); }",
            "    inline void resetbit(uint v) { m[v >> 6] &= ~(1ull << (v & 63)); }",
            "    inline uint getbit(uint v) const { return m[v >> 6] >> (v & 63) & 1; }",
            "    inline ull childs_value(uint v) const { return m[left(v) >> 6]; }",
            "",
            "    inline uint left_go(uint x, const uint c) const",
            "    {",
            "        const ull rem = x & 63;",
            "        uint bt = PREF * 64 + x;",
            "        ull num = m[bt >> 6] & lowest_bitsll[rem + c];",
            "        if (num)",
            "            return (x ^ rem) | __lg(num);",
            "        for (bt = parent(bt); bt > 62; bt = parent(bt))",
            "        {",
            "            const ull rem = bt & 63;",
            "            num = m[bt >> 6] & lowest_bitsll[rem];",
            "            if (num)",
            "            {",
            "                bt = (bt ^ rem) | __lg(num);",
            "                break;",
            "            }",
            "        }",
            "        if (bt == 62)",
            "            return NO;",
            "        while (bt < PREF * 64)",
            "            bt = left(bt) | __lg(m[bt - 62]);",
            "        return bt - PREF * 64;",
            "    }",
            "",
            "    inline uint right_go(uint x, const uint c) const",
            "    {",
            "        const ull rem = x & 63;",
            "        uint bt = PREF * 64 + x;",
            "        ull num = m[bt >> 6] & ~lowest_bitsll[rem + c];",
            "        if (num)",
            "            return (x ^ rem) | __builtin_ctzll(num);",
            "        for (bt = parent(bt); bt > 62; bt = parent(bt))",
            "        {",
            "            const ull rem = bt & 63;",
            "            num = m[bt >> 6] & ~lowest_bitsll[rem + 1];",
            "            if (num)",
            "            {",
            "                bt = (bt ^ rem) | __builtin_ctzll(num);",
            "                break;",
            "            }",
            "        }",
            "        if (bt == 62)",
            "            return NO;",
            "        while (bt < PREF * 64)",
            "            bt = left(bt) | __builtin_ctzll(m[bt - 62]);",
            "        return bt - PREF * 64;",
            "    }",
            "",
            "public:",
            "    godgod_suc_pred()",
            "    {",
            "        assert(PREF != 228);",
            "        setbit(62);",
            "    }",
            "",
            "    bool empty() const { return getbit(63); }",
            "",
            "    void clear()",
            "    {",
            "        fill(m, m + SZ, 0);",
            "        setbit(62);",
            "    }",
            "",
            "    bool count(uint x) const { return m[PREF + (x >> 6)] >> (x & 63) & 1; }",
            "",
            "    void insert(uint x)",
            "    {",
            "        for (uint v = PREF * 64 + x; !getbit(v); v = parent(v))",
            "        {",
            "            setbit(v);",
            "        }",
            "    }",
            "",
            "    void erase(uint x)",
            "    {",
            "        if (!getbit(PREF * 64 + x))",
            "            return;",
            "        resetbit(PREF * 64 + x);",
            "        for (uint v = parent(PREF * 64 + x); v > 62 && !childs_value(v); v = parent(v))",
            "        {",
            "            resetbit(v);",
            "        }",
            "    }",
            "",
            "    uint lower_bound(uint x) const { return right_go(x, 0); }",
            "    uint upper_bound(uint x) const { return right_go(x, 1); }",
            "    uint inverse_lower_bound(uint x) const { return left_go(x, 1); }",
            "    uint inverse_upper_bound(uint x) const { return left_go(x, 0); }",
            "};",
            "// Supports all std::set operations in O(1) on random queries / dense arrays, O(log_64(N)) in worst case (sparce array).",
            "// Count operation works in O(1) always.",
            "//  reference : https://codeforces.com/contest/1793/submission/193330718"
        ],
        "description": "Snippet for ultra_fast_set (normal version)"
    },
    "template_random_suffix_tree": {
        "prefix": "template_random_suffix_tree",
        "body": [
            "template<typename C, typename L, typename G, typename R>",
            "class random_suffix_tree_chan",
            "{",
            "    /*",
            "    info:",
            "        - Based on https://www.welcome-to-the-sunny-side.com/algo/theory/suffix_tree_funny_construction.html ",
            "        - Generates suffix tree using the leader split technique for a set of strings numbered from 0 to n - 1",
            "        - bool compare(int i, int j, int x) returns true if x-length prefix of strings i and j is equal, and false otherwise",
            "        - int length(int i) returns length of ith string",
            "        - int get(int i, int x) returns the xth integer of string i (1 based indexing)",
            "        - rng just needs to have rng(x) generating random integer in [0, x)",
            "    warning:",
            "        - has been stress tested but its pretty slow and not optimized at all: https://judge.yosupo.jp/submission/237581",
            "    */",
            "public:",
            "    int n, root;",
            "    vector<int> dep;",
            "    vector<int> nid;",
            "    vector<int> rep;",
            "    vector<vector<int>> adj;",
            "",
            "    random_suffix_tree_chan(int n, C compare, L length, G get, R rng) : ",
            "    n(n), dep(2 * n + 5), nid(2 * n + 5), rep(2 * n + 5, -1), adj(2 * n + 5)",
            "    {",
            "        vector<int> alive(n);",
            "        iota(alive.begin(), alive.end(), 0);",
            "",
            "        int timer = n - 1;",
            "        vector<int> dis(2 * n + 5);",
            "        vector<int> brk(2 * n + 5);",
            "",
            "        auto construct = [&](vector<int> a, auto &&construct) -> int",
            "        {",
            "            assert(!a.empty());",
            "",
            "            if(a.size() == 1)",
            "            {",
            "                int u = a[0];",
            "                nid[u] = u;",
            "                rep[u] = u;",
            "                return a[0];",
            "            }",
            "",
            "            int l = a[rng(a.size())];",
            "            a.erase(find(a.begin(), a.end(), l));",
            "            dis[l] = length(l);",
            "",
            "            for(auto v : a)",
            "            {",
            "                dis[v] = 0;",
            "                int s = 1, e = min(dis[l], length(v));",
            "                while(s <= e)",
            "                {",
            "                    int mid = (s + e)/2;",
            "                    if(compare(l, v, mid))",
            "                        s = mid + 1, dis[v] = mid;",
            "                    else",
            "                        e = mid - 1;",
            "                }",
            "            }",
            "",
            "            sort(a.begin(), a.end(), [&](int i, int j) {return dis[i] > dis[j];});",
            "            a.insert(a.begin(), l);",
            "",
            "            vector<int> nodes;",
            "",
            "            while(!a.empty())",
            "            {",
            "                int len = dis[a.back()];",
            "                vector<int> split;",
            "",
            "                int node = -1;",
            "",
            "                while(!a.empty() and dis[a.back()] == len)",
            "                {",
            "                    if(length(a.back()) == len)",
            "                    {",
            "                        if(node == -1)",
            "                            node = a.back(), rep[node] = node;",
            "                        nid[a.back()] = node;",
            "                    }",
            "                    else",
            "                        split.push_back(a.back());",
            "                    a.pop_back();",
            "                }",
            "",
            "                if(node == -1)",
            "                    node = ++ timer;",
            "",
            "                dep[node] = len;",
            "",
            "                for(auto u : split)",
            "                    brk[u] = get(u, len + 1);",
            "                ",
            "                sort(split.begin(), split.end(), [&](int i, int j) {return brk[i] < brk[j];});",
            "                ",
            "                for(int i = 0; i < split.size();)",
            "                {",
            "                    int j = i;",
            "                    while(j < split.size() and brk[split[i]] == brk[split[j]])",
            "                        ++ j;",
            "                    ",
            "                    vector<int> hsplit;",
            "                    for(int k = i; k < j; k ++)",
            "                        hsplit.push_back(split[k]);",
            "                    ",
            "                    int child = construct(hsplit, construct);",
            "",
            "                    adj[node].push_back(child);",
            "                    rep[node] = max(rep[node], rep[child]);",
            "",
            "                    i = j;",
            "                }",
            "              ",
            "                nodes.push_back(node);",
            "            }",
            "",
            "            for(int i = 0; i < nodes.size() - 1; i ++)",
            "            {",
            "                adj[nodes[i]].push_back(nodes[i + 1]);",
            "                rep[nodes[i]] = max(rep[nodes[i]], rep[nodes[i + 1]]);",
            "            }",
            "",
            "            return nodes.front();",
            "        };",
            "        root = construct(alive, construct);",
            "",
            "        if(dep[root] != 0)",
            "        {",
            "            int new_root = ++ timer;",
            "            adj[new_root].push_back(root);",
            "            dep[new_root] = 0;",
            "            rep[new_root] = rep[root];",
            "            root = new_root;",
            "        }",
            "",
            "        for(int u = 0; u < adj.size(); u ++)",
            "        {",
            "            for(auto v : adj[u])",
            "                brk[v] = get(rep[v], dep[u] + 1);",
            "",
            "            sort(adj[u].begin(), adj[u].end(), ",
            "            [&](int i, int j) {return brk[i] < brk[j];});",
            "        }",
            "    };",
            "};"
        ],
        "description": "Snippet for random_suffix_tree (normal version)"
    },
    "template_scc": {
        "prefix": "template_scc",
        "body": [
            "class condenser_chan",
            "{",
            "    /*",
            "    tc: O(n + m)",
            "    ml: O(n + m)",
            "",
            "    info:",
            "        0-indexed    ",
            "        SCC u occurs before SCC v (u < v) in some topological ordering of SCCs ",
            "",
            "    warning: ",
            "        there may be multiple edges between different SCCs",
            "",
            "    var:",
            "        [n -> number of nodes]",
            "        [c -> number of SCCs]",
            "        [comp[u] -> component number of node u]",
            "        [scc[u] -> outedge list for scc u]",
            "        [grp[u] -> node list for scc u]",
            "    */",
            "public:",
            "    int n, c;",
            "    vector<bool> vis;",
            "    vector<int> stak, comp;",
            "    vector<vector<int>> adj, rdj, scc, grp;",
            "",
            "    condenser_chan(int n, const vector<vector<int>> &adj) :",
            "    n(n), c(0), vis(n), adj(adj), rdj(n), scc(n), grp(n), comp(n, -1) ",
            "    {",
            "        for(int u = 0; u < n; u ++)",
            "            for(auto v : adj[u])",
            "                rdj[v].push_back(u);",
            "    };",
            "",
            "    void condense()",
            "    {",
            "        auto dfs1 = [&](int u, auto &&dfs1) -> void ",
            "        {",
            "            vis[u] = true;",
            "            for(auto v : adj[u])",
            "                if(!vis[v])",
            "                    dfs1(v, dfs1);",
            "            stak.push_back(u);",
            "        };",
            "        for(int u = 0; u < n; u ++)",
            "            if(!vis[u])",
            "                dfs1(u, dfs1);",
            "",
            "        auto dfs2 = [&](int u, auto &&dfs2) -> void ",
            "        {",
            "            comp[u] = c;",
            "            for(auto v : rdj[u])",
            "                if(comp[v] == -1)",
            "                    dfs2(v, dfs2);",
            "        };",
            "",
            "        reverse(stak.begin(), stak.end());",
            "        for(auto u : stak)",
            "            if(comp[u] == -1)",
            "                dfs2(u, dfs2), ++ c;",
            "",
            "        for(int u = 0; u < n; u ++)",
            "            for(auto v : adj[u])",
            "                if(comp[u] != comp[v])",
            "                    scc[comp[u]].push_back(comp[v]);",
            "",
            "        for(int u = 0; u < n; u ++)",
            "            grp[comp[u]].push_back(u);",
            "    }",
            "",
            "    void fix()      //remove multiple edges [O(m log(m))]",
            "    {",
            "        for(auto &v : scc)",
            "        {",
            "            sort(v.begin(), v.end());",
            "            v.erase(unique(v.begin(), v.end()), v.end());",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet for scc (normal version)"
    },
    "template_connectivity": {
        "prefix": "template_connectivity",
        "body": [
            "class connectivity_chan",
            "{",
            "    /*",
            "        n -> number of nodes",
            "        bridge -> contains all bridges",
            "        a -> number of cutpoints",
            "        cut[u] -> is u an articulation point",
            "        m -> n + number of biconnected components (bcc's indexed in [n, inf))",
            "        bcc -> stores bcc's (note that its of size m, and the first n elements are empty vectors)",
            "        b -> number of nodes in the block cut tree",
            "        block_node_id -> id of bct-node that a certain node belongs to",
            "        cut_node_id -> new id of a cut node",
            "        bct_comp -> just stores the set of original nodes that correspond to a certain node in the bct",
            "        bct -> the actual adjacency list for the bct",
            "",
            "        Block: BCC",
            "        All edges form equivalence classes, these are grouped into blocks (BCCs)",
            "        These blocks may share vertices but not edges",
            "        A bipartite graph (and tree), BCT is formed by creating a node for every block, every",
            "        cut-point and adding an edge from every cut-point to all the blocks it is a part of.",
            "    */",
            "public:",
            "    int n;",
            "    vector<vector<int>> adj;",
            "    int timer;",
            "    vector<int> tin, low;",
            "",
            "    vector<pair<int, int>> bridge;",
            "",
            "    int a;",
            "    vector<bool> cut;",
            "",
            "    int m;",
            "    vector<vector<int>> bcc;",
            "",
            "    int b;",
            "    vector<int> block_node_id;",
            "    vector<int> cut_node_id;",
            "    vector<vector<int>> bct_comp;    ",
            "    vector<vector<int>> bct;",
            "",
            "    connectivity_chan(const vector<vector<int>> &adj) : ",
            "    n(adj.size()), m(n), adj(adj), timer(0), tin(n, -1), low(n, -1), cut(n), bcc(n), ",
            "    block_node_id(n, -1), cut_node_id(n, -1) ",
            "    {",
            "        compute_connectivity();",
            "        make_block_cut_tree();",
            "    };",
            "",
            "    void compute_connectivity()",
            "    {",
            "        vector<bool> vis(n);",
            "        vector<int> stk;",
            "",
            "        auto dfs = [&](int u, int p, auto &&dfs) -> void",
            "        {",
            "            tin[u] = low[u] = timer ++;",
            "            vis[u] = true;",
            "            stk.push_back(u);",
            "",
            "            int ptimes = 0;",
            "            int children = 0;",
            "            for(auto v : adj[u])",
            "            {",
            "                if(v == p)",
            "                {",
            "                    ++ ptimes;",
            "                    continue;",
            "                }",
            "",
            "                if(vis[v])",
            "                    low[u] = min(low[u], tin[v]);",
            "                else",
            "                {",
            "                    ++ children;",
            "                    int s = stk.size();",
            "                    dfs(v, u, dfs);",
            "                    low[u] = min(low[u], low[v]);",
            "",
            "                    if((p == -1 and children > 1) or (p != -1 and tin[u] <= low[v]))",
            "                    {",
            "                        cut[u] = true;",
            "                        bcc.push_back(vector<int> ());",
            "                        bcc[m].push_back(u);",
            "                        while(stk.size() > s)",
            "                        {",
            "                            bcc[m].push_back(stk.back());",
            "                            stk.pop_back();",
            "                        }",
            "                        ++ m;",
            "                    }",
            "                }",
            "            ",
            "            }",
            "",
            "            if(p != -1 and ptimes <= 1 and low[u] > tin[p])",
            "                bridge.emplace_back(min(u, p), max(u, p));",
            "        };",
            "        for(int u = 0; u < n; u ++)",
            "            if(!vis[u])",
            "            {",
            "                dfs(u, -1, dfs);",
            "                bcc.push_back(vector<int> ());",
            "                while(!stk.empty())",
            "                {",
            "                    bcc[m].push_back(stk.back());",
            "                    stk.pop_back();",
            "                }",
            "                ++ m;",
            "            }",
            "        a = count(cut.begin(), cut.end(), true);",
            "    }",
            "",
            "    void make_block_cut_tree()",
            "    {",
            "        b = (m - n) + a;",
            "        bct_comp.assign(b, vector<int>());",
            "        bct.assign(b, vector<int>());",
            "",
            "        for(int i = n; i < m; i ++)",
            "        {",
            "            bct_comp[i - n] = bcc[i];",
            "            for(auto u : bct_comp[i - n])",
            "                block_node_id[u] = i - n;",
            "        }",
            "",
            "        vector<int> cut_list;",
            "        for(int i = 0; i < n; i ++)",
            "            if(cut[i])",
            "                cut_list.push_back(i);",
            "            ",
            "        for(int i = m - n; i < m - n + a; i ++)",
            "        {",
            "            bct_comp[i] = {cut_list[i - (m - n)]};",
            "            for(auto u : bct_comp[i])",
            "                cut_node_id[u] = i;",
            "        }",
            "",
            "        for(int i = 0; i < m - n; i ++)",
            "            for(auto u : bct_comp[i])",
            "                if(cut[u])",
            "                    bct[i].push_back(cut_node_id[u]), bct[cut_node_id[u]].push_back(i);",
            "    }",
            "};"
        ],
        "description": "Snippet for connectivity (normal version)"
    },
    "template_level_ancestor": {
        "prefix": "template_level_ancestor",
        "body": [
            "//wip",
            "class level_ancestor_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<int> tin;",
            "    vector<int> tout;",
            "    vector<int> heavy;",
            "",
            "    level_ancestor_chan(int n, int r, const vector<vector<int>> &tree) : ",
            "    n(n), heavy(n + 1), tin(n + 1), tout(n + 1)",
            "    {",
            "        auto adj = tree;",
            "        vector<int> sz(n + 1, 0);",
            "        auto dfs1 = [&](int u, int p, auto &&dfs) -> void",
            "        {",
            "            sz[u] = 1;",
            "            if(p != 0)",
            "                adj[u].erase(find(adj[u].begin(), adj[u].end(), p));",
            "            for(auto v : adj[u])",
            "                dfs(v, u, dfs), sz[u] += sz[v];",
            "            if(!adj[u].empty())",
            "            {",
            "                auto mit = *max_element(adj[u].begin(), adj[u].end(), [&](int v1, int v2) {return sz[v1] < sz[v2];});",
            "                swap(*adj[u].begin(), mit);",
            "            }",
            "        };",
            "        dfs1(r, 0, dfs1);",
            "",
            "        int timer = 0;",
            "        auto dfs2 = [&](int u, int p, auto &&dfs) -> void",
            "        {",
            "            tin[]",
            "        };",
            "    };",
            "",
            "    bool is_anc(int a, int u)",
            "    {",
            "        return tin[a] <= tin[u] and tout[u] <= tout[a];",
            "    }",
            "",
            "    int lca(int u, int v)",
            "    {",
            "",
            "    }",
            "",
            "    int get_ancestor(int u, int k)",
            "    {",
            "",
            "    }",
            "};"
        ],
        "description": "Snippet for level_ancestor (normal version)"
    },
    "template_binary_lifter": {
        "prefix": "template_binary_lifter",
        "body": [
            "class binary_lifter_chan",
            "{",
            "    /*",
            "    tc: O(n logn) preprocessing, O(logn) query",
            "    ml: O(n logn)",
            "",
            "    info:",
            "        - 0 indexed",
            "        - n -> number of nodes",
            "        - dep[u] -> depth of node u",
            "        - tin[u], tout[u] -> intime, outtime of node u",
            "        - up[u][i] -> stores 2^ith ancestor of u",
            "    */",
            "public:",
            "    int n, L, timer;",
            "    vector<int> dep, tin, tout;",
            "    vector<vector<int>> up;",
            "",
            "    binary_lifter_chan(int n, int r, const vector<vector<int>> &adj) : ",
            "    n(n), L(ceil(log2(n)) + 1), timer(0), dep(n), tin(n), tout(n), up(n, vector<int> (L, r))",
            "    {",
            "        timer = 0;",
            "        dep[r] = 0;",
            "        dfs(r, r, adj);",
            "    }",
            "",
            "    void dfs(int u, int p, const vector<vector<int>> &adj)",
            "    {",
            "        tin[u] = ++ timer;",
            "        up[u][0] = p;",
            " ",
            "        for(int i = 1; i < L; ++i)",
            "            up[u][i] = up[up[u][i - 1]][i - 1];",
            " ",
            "        for(auto v : adj[u])",
            "            if (v != p)",
            "                dep[v] = dep[u] + 1, dfs(v, u, adj);",
            "",
            "        tout[u] = ++ timer;",
            "    }",
            "",
            "    int get_kth(int v, int k)",
            "    {",
            "        if(k != 0)",
            "            for(int i = L - 1; i >= 0 and v > 0; i --)",
            "                if((1 << i) <= k)",
            "                    k -= (1 << i), v = up[v][i];",
            "        return v;",
            "    }",
            "",
            "    bool is_anc(int anc, int v)",
            "    {",
            "        return tin[anc] <= tin[v] and tout[v] <= tout[anc];",
            "    }",
            "",
            "    int lca(int u, int v)",
            "    {",
            "        if (is_anc(u, v))",
            "            return u;",
            "        if (is_anc(v, u))",
            "            return v;",
            "        for (int i = L - 1; i >= 0; --i) ",
            "            if (!is_anc(up[u][i], v))",
            "                u = up[u][i];",
            "        return up[u][0];",
            "    }",
            "};"
        ],
        "description": "Snippet for binary_lifter (normal version)"
    },
    "template_offline_lca": {
        "prefix": "template_offline_lca",
        "body": [
            "vector<int> offline_lca_chan(int n, int r, const vector<vector<int>> &adj, vector<pair<int, int>> query)",
            "{",
            "    /*",
            "        info:",
            "            - 0 indexed",
            "        vars:",
            "            - n : number of nodes",
            "            - r : root",
            "    */",
            "    ",
            "",
            "    //dsu",
            "    vector<int> par(n), siz(n, 1);",
            "    iota(par.begin(), par.end(), 0);",
            "    auto get = [&](int u, auto &&get) -> int",
            "    {",
            "        return (par[u] == u ? u : par[u] = get(par[u], get));",
            "    };",
            "    auto unite = [&](int u, int v) -> void",
            "    {",
            "        u = get(u, get), v = get(v, get);",
            "        if(u == v)",
            "            return;",
            "        if(siz[u] < siz[v])",
            "            swap(u, v);",
            "        par[v] = u, siz[u] += siz[v];",
            "    };",
            "",
            "    assert(!query.empty());",
            "    int m = query.size();",
            "    ",
            "    vector<int> ans(m);",
            "    vector<bool> see(m);",
            "    vector<vector<int>> store(n);",
            "",
            "    for(int i = 0; i < m; i ++)",
            "    {",
            "        auto [u, v] = query[i];",
            "        store[u].push_back(i), store[v].push_back(i);",
            "    }",
            "",
            "    auto dfs = [&](int u, int p, auto &&dfs) -> void",
            "    {",
            "        for(auto i : store[u])",
            "        {",
            "            if(see[i])",
            "                ans[i] = get(query[i].first == u ? query[i].second : query[i].first, get);",
            "            see[i] = true;",
            "        }",
            "",
            "        for(auto v : adj[u])",
            "            if(v != p)",
            "                dfs(v, u, dfs);",
            "",
            "        if(p != 0)",
            "            unite(u, p);",
            "    };",
            "    dfs(r, 0, dfs);",
            "    ",
            "    return ans;",
            "};"
        ],
        "description": "Snippet for offline_lca (normal version)"
    },
    "template_virtual_tree": {
        "prefix": "template_virtual_tree",
        "body": [
            "template <typename L>",
            "vector<pair<int, int>> virtual_tree_chan(vector<int> key, const vector<int> &tin, const vector<int> &tout, L &lca)",
            "{",
            "    /*",
            "        info:",
            "            - index agnostic",
            "    */",
            "    assert(!key.empty());",
            "    sort(key.begin(), key.end(), [&](int a, int b)  { return tin[a] < tin[b]; });",
            "",
            "    vector<int> l;",
            "    for (int i = 0; i < key.size() - 1; i++)",
            "        l.push_back(lca.LCA(key[i], key[i + 1]));",
            "    ",
            "    for (auto p : l)",
            "        key.push_back(p);",
            "    sort(key.begin(), key.end(), [&](int a, int b)  { return tin[a] < tin[b]; });",
            "    key.erase(unique(key.begin(), key.end()), key.end());",
            "    reverse(key.begin(), key.end());",
            "",
            "    // stk contains path from root to current node, key contains unvisited nodes",
            "    stack<int> stk;",
            "    vector<pair<int, int>> edge;",
            "",
            "    stk.push(key.back());",
            "    key.pop_back();",
            "",
            "    while (!stk.empty())",
            "    {",
            "        int u = stk.top();",
            "        if (!key.empty() and tin[u] <= tin[key.back()] and tout[key.back()] <= tout[u])",
            "        {",
            "            edge.push_back(make_pair(u, key.back()));",
            "            stk.push(key.back());",
            "            key.pop_back();",
            "            continue;",
            "        }",
            "        stk.pop();",
            "    }",
            "",
            "    return edge;",
            "}"
        ],
        "description": "Snippet for virtual_tree (normal version)"
    },
    "template_centroid": {
        "prefix": "template_centroid",
        "body": [
            "",
            "class centroid_decomposition_chan",
            "{",
            "    /*",
            "        info:",
            "            - 0-indexed",
            "            - roots the tree at `root`",
            "            - finally, par and cadj define the centroid tree",
            "            - parent of root is -1",
            "    */",
            "public:",
            "    int n;",
            "    int root;",
            "",
            "    vector<int> par;",
            "    vector<vector<int>> cadj;",
            "",
            "    centroid_decomposition_chan(int n, const vector<vector<int>> &adj) : n(n), par(n, -1), cadj(n) ",
            "    {",
            "        vector<bool> mark(n, false);",
            "        vector<int> sub(n);",
            "        auto find_centroid = [&](int u) -> int",
            "        {",
            "            assert(!mark[u]);",
            "            int cnt = 0;",
            "            vector<int> seen;",
            "            auto dfs = [&](int u, int p, auto &&dfs) -> void",
            "            {",
            "                ++ cnt;",
            "                sub[u] = 1;",
            "                for(auto v : adj[u])",
            "                    if(v != p and !mark[v])",
            "                        dfs(v, u, dfs), sub[u] += sub[v];",
            "            };",
            "            dfs(u, 0, dfs);",
            "",
            "            int cen = -1;",
            "            auto dfs2 = [&](int u, int p, auto &&dfs2) -> void",
            "            {",
            "                int mx = cnt - sub[u];",
            "                for(auto v : adj[u])",
            "                    if(v != p and !mark[v])",
            "                    {",
            "                        dfs2(v, u, dfs2);",
            "                        mx = max(mx, sub[v]);",
            "                    }",
            "                if(mx <= cnt/2)",
            "                    cen = u;",
            "            };",
            "            dfs2(u, 0, dfs2);",
            "",
            "            assert(cen != -1);",
            "            return cen;",
            "        };",
            "",
            "        auto dfs = [&](int u, auto &&dfs) -> void",
            "        {",
            "            for(auto v : adj[u])",
            "                if(!mark[v])",
            "                {",
            "                    int c = find_centroid(v);",
            "                    cadj[u].push_back(c);",
            "                    par[c] = u;",
            "                    mark[c] = true;",
            "                    dfs(c, dfs);",
            "                }",
            "        };",
            "        root = find_centroid(0);",
            "        mark[root] = true;",
            "        dfs(root, dfs);",
            "    };",
            "};"
        ],
        "description": "Snippet for centroid (normal version)"
    },
    "template_heavy_light": {
        "prefix": "template_heavy_light",
        "body": [
            "template <typename I, typename T, template<typename, typename> typename S, const bool on_edge>",
            "class heavy_light_chan",
            "{",
            "    /*",
            "        info:",
            "            - 0 indexed",
            "            - range [pos[u], out[u]) represents subtree of u",
            "        vars:",
            "            - I: Info struct of segment tree",
            "            - T: Lazy Tag struct of segment tree",
            "            - S: segment tree class (S must support S<I, T>)",
            "            - r = tree root",
            "            - on_edge = true => values on edges. Internally, value of edge is stored at lower node.",
            "        warning:",
            "            - handle segtree initialization correctly",
            "            - monoid operations must be commutative here",
            "                (implement directed path queries later)",
            "    */",
            "public:",
            "    int n, r;",
            "    vector<int> par, heavy, dep, root, pos, out;",
            "    S<I, T> tree;",
            "",
            "    heavy_light_chan(int n, int r, vector<vector<int>> adj) :",
            "    n(n), r(r), par(n, -1), heavy(n, -1), dep(n), root(n), pos(n), out(n),",
            "    tree(n + 1)",
            "    {",
            "        assert(r < n);",
            "",
            "        auto dfs_sz = [&](int u, auto &&dfs) -> int",
            "        {",
            "            int ss = 1, m = 0;",
            "            for(auto &v : adj[u])",
            "                if(v != par[u])",
            "                {",
            "                    par[v] = u, dep[v] = dep[u] + 1;",
            "                    int s = dfs(v, dfs);",
            "                    ss += s;",
            "                    if(s > m)",
            "                        heavy[u] = v, m = s, swap(adj[u][0], v);",
            "                }",
            "            return ss;",
            "        };",
            "        int timer = 0;",
            "        auto dfs_hld = [&](int u, auto &&dfs) -> void",
            "        {",
            "            pos[u] = timer ++;",
            "            for(auto v : adj[u])",
            "                if(v != par[u])",
            "                    root[v] = (heavy[u] == v ? root[u] : v), dfs(v, dfs);",
            "            out[u] = timer;",
            "        };",
            "        par[r] = -1, dep[r] = 0, root[r] = r;",
            "        dfs_sz(r, dfs_sz), dfs_hld(r, dfs_hld);",
            "    };",
            "",
            "    int lca(int u, int v)",
            "    {",
            "        for (; root[u] != root[v]; v = par[root[v]])",
            "            if (dep[root[u]] > dep[root[v]])",
            "                swap(u, v);",
            "        return (dep[u] < dep[v] ? u : v);",
            "    }",
            "",
            "    template <typename O>",
            "    void process_path(int u, int v, O op)",
            "    {",
            "        for (; root[u] != root[v]; v = par[root[v]])",
            "        {",
            "            if (dep[root[u]] > dep[root[v]])",
            "                swap(u, v);",
            "            op(pos[root[v]], pos[v]);",
            "        }",
            "        if (dep[u] > dep[v])",
            "            swap(u, v);",
            "        ",
            "        if(!on_edge)",
            "            op(pos[u], pos[v]);",
            "        else if(u != v)",
            "            op(pos[u] + 1, pos[v]);",
            "    }",
            "    ",
            "    void set(int v, const I &info)",
            "    {",
            "        tree.set(pos[v], info);",
            "    }",
            "    void modify_path(int u, int v, const T &tag)",
            "    {",
            "        process_path(u, v, [this, &tag](int l, int r)  {tree.modify(l, r, tag);});",
            "    }",
            "    void modify_subtree(int u, const T &tag)",
            "    {",
            "        if(!on_edge)",
            "            tree.modify(pos[u], out[u] - 1, tag);",
            "        else if(pos[u] < out[u] - 1)",
            "            tree.modify(pos[u] + 1, out[u] - 1, tag);",
            "    }",
            "",
            "    I get(int v)",
            "    {",
            "        return tree.get(pos[v]);",
            "    }",
            "    I query_path(int u, int v)",
            "    {",
            "        I res = I();",
            "        process_path(u, v, [this, &res](int l, int r)    {res = res.unite(tree.query(l, r));});",
            "        return res;",
            "    }",
            "    I query_subtree(int u)",
            "    {",
            "        if(on_edge)",
            "            return (pos[u] < out[u] - 1 ? tree.query(pos[u] + 1, out[u] - 1) : I());   ",
            "        return tree.query(pos[u], out[u] - 1);",
            "    }",
            "};"
        ],
        "description": "Snippet for heavy_light (normal version)"
    },
    "template_bipartite": {
        "prefix": "template_bipartite",
        "body": [
            "class bipartite_chan",
            "{",
            "    /*",
            "        tc: O(E sqrt(V))",
            "        mc: O(V + E)",
            "",
            "        vars:",
            "            n, m: size of left and right partitions",
            "            adj: left to right edges ONLY",
            "        info:",
            "            Both partitions are individually 0 indexed",
            "            After calling max_matching():",
            "                - matching = size of max matching",
            "                - l[u] = matched right node for u (l[u] = -1 => unmatched)",
            "                - r[u] = matched left node for u (r[u] = -1 => unmatched)",
            "            MVC is found by:",
            "                - orienting matched edges from right to left, unmatched opposite",
            "                - running dfs from all unmatched left side nodes",
            "                - (unvis nodes on the left) + (visited nodes on right) = mvc",
            "            MIS is complement of MVC",
            "    */",
            "public:",
            "    int n, m;",
            "    int matching = 0;",
            "    vector<vector<int>> adj;",
            "    vector<int> l, r, lvl;",
            "    bipartite_chan(int n, int m, const vector<vector<int>> &adj) : ",
            "        n(n), m(m), l(n, -1), r(m, -1), adj(adj) {};",
            "",
            "    // void Add(int u, int v)  { adj[u].push_back(v); }",
            "    bool dfs(int u)",
            "    {",
            "        int t = exchange(lvl[u], -1) + 1;",
            "        for (int v : adj[u])",
            "            if (r[v] == -1 or (lvl[r[v]] == t and dfs(r[v])))",
            "                return l[u] = v, r[v] = u, 1;",
            "        return 0;",
            "    }",
            "",
            "    int max_matching()",
            "    {",
            "        matching = 0;   ",
            "        vector<int> q(n);",
            "        for (int s = 0, t = 0;; s = t = 0)",
            "        {",
            "            lvl = vector<int>(n);   bool f = 0;",
            "            for(int i = 0; i < n; i ++) ",
            "                if (l[i] == -1) ",
            "                    lvl[i] = 1, q[t ++] = i;",
            "            ",
            "            while (s < t)",
            "            {",
            "                int u = q[ s++];",
            "                for (int v : adj[u])",
            "                {",
            "                    int x = r[v];",
            "                    if (x == -1)",
            "                        f = 1;",
            "                    else if (!lvl[x])",
            "                        lvl[x] = lvl[u] + 1, q[t++] = x;",
            "                }",
            "            }",
            "",
            "            if (!f)",
            "                break;",
            "            ",
            "            for(int i = 0; i < n; i ++) ",
            "                if (l[i] == -1) ",
            "                    matching += dfs(i);",
            "        }",
            "        return matching;",
            "    }",
            "",
            "    vector<pair<int, int>> max_matching_edges()",
            "    {",
            "        vector<pair<int, int>> mme;",
            "        for(int u = 0; u < n; u ++)",
            "            if(l[u] != -1)",
            "                mme.push_back(make_pair(u, l[u]));",
            "        return mme;",
            "    }",
            "    ",
            "    pair<vector<int>, vector<int>> min_vertex_cover()",
            "    {",
            "        vector<bool> lv(n, false), rv(m, false);",
            "        ",
            "        auto dfs = [&](int u, auto &&dfs) -> void",
            "        {",
            "            lv[u] = true;",
            "            for(auto v : adj[u])",
            "                if(r[v] != u and !rv[v])",
            "                {",
            "                    rv[v] = true;",
            "                    if(r[v] != -1 and !lv[r[v]])",
            "                        dfs(r[v], dfs);",
            "                }",
            "        };",
            "        for(int u = 0; u < n; u ++)",
            "            if(l[u] == -1 and !lv[u])",
            "                dfs(u, dfs);",
            "",
            "        vector<int> lc, rc;",
            "        for(int u = 0; u < n; u ++)",
            "            if(!lv[u])",
            "                lc.push_back(u);",
            "        for(int u = 0; u < m; u ++)",
            "            if(rv[u])",
            "                rc.push_back(u);",
            "        ",
            "        assert(matching == (int)lc.size() + (int)rc.size());",
            "        return {lc, rc};",
            "    }",
            "};"
        ],
        "description": "Snippet for bipartite (normal version)"
    },
    "template_gaussian_elimination": {
        "prefix": "template_gaussian_elimination",
        "body": [
            "class gauss_chan",
            "{",
            "public:",
            "    int d, sz;",
            "    vector<int> basis;",
            "",
            "    gauss_chan (int d) : d(d), sz(0), basis(d) {};",
            "",
            "    void insert(int mask)",
            "    {",
            "        for(int i = 0; i < d; i ++) if(mask & (1 << i))",
            "        {",
            "            if(basis[i] == 0)",
            "            {",
            "                basis[i] = mask;",
            "                ++ sz;",
            "                break;",
            "            }",
            "            mask ^= basis[i];",
            "        }",
            "    }",
            "",
            "    void query()",
            "    {",
            "        //",
            "    }",
            "};"
        ],
        "description": "Snippet for gaussian_elimination (normal version)"
    },
    "template_mod_int_variable": {
        "prefix": "template_mod_int_variable",
        "body": [
            "",
            "namespace atcoder",
            "{",
            "",
            "    namespace internal",
            "    {",
            "",
            "        // @param m `1 <= m`",
            "        // @return x mod m",
            "        constexpr long long safe_mod(long long x, long long m)",
            "        {",
            "            x %= m;",
            "            if (x < 0)",
            "                x += m;",
            "            return x;",
            "        }",
            "",
            "        // Fast modular multiplication by barrett reduction",
            "        // Reference: https://en.wikipedia.org/wiki/Barrett_reduction",
            "        // NOTE: reconsider after Ice Lake",
            "        struct barrett",
            "        {",
            "            unsigned int _m;",
            "            unsigned long long im;",
            "",
            "            // @param m `1 <= m`",
            "            explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}",
            "",
            "            // @return m",
            "            unsigned int umod() const { return _m; }",
            "",
            "            // @param a `0 <= a < m`",
            "            // @param b `0 <= b < m`",
            "            // @return `a * b % m`",
            "            unsigned int mul(unsigned int a, unsigned int b) const",
            "            {",
            "                // [1] m = 1",
            "                // a = b = im = 0, so okay",
            "",
            "                // [2] m >= 2",
            "                // im = ceil(2^64 / m)",
            "                // -> im * m = 2^64 + r (0 <= r < m)",
            "                // let z = a*b = c*m + d (0 <= c, d < m)",
            "                // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im",
            "                // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2",
            "                // ((ab * im) >> 64) == c or c + 1",
            "                unsigned long long z = a;",
            "                z *= b;",
            "#ifdef _MSC_VER",
            "                unsigned long long x;",
            "                _umul128(z, im, &x);",
            "#else",
            "                unsigned long long x =",
            "                    (unsigned long long)(((unsigned __int128)(z)*im) >> 64);",
            "#endif",
            "                unsigned long long y = x * _m;",
            "                return (unsigned int)(z - y + (z < y ? _m : 0));",
            "            }",
            "        };",
            "",
            "        // @param n `0 <= n`",
            "        // @param m `1 <= m`",
            "        // @return `(x ** n) % m`",
            "        constexpr long long pow_mod_constexpr(long long x, long long n, int m)",
            "        {",
            "            if (m == 1)",
            "                return 0;",
            "            unsigned int _m = (unsigned int)(m);",
            "            unsigned long long r = 1;",
            "            unsigned long long y = safe_mod(x, m);",
            "            while (n)",
            "            {",
            "                if (n & 1)",
            "                    r = (r * y) % _m;",
            "                y = (y * y) % _m;",
            "                n >>= 1;",
            "            }",
            "            return r;",
            "        }",
            "",
            "        // Reference:",
            "        // M. Forisek and J. Jancina,",
            "        // Fast Primality Testing for Integers That Fit into a Machine Word",
            "        // @param n `0 <= n`",
            "        constexpr bool is_prime_constexpr(int n)",
            "        {",
            "            if (n <= 1)",
            "                return false;",
            "            if (n == 2 || n == 7 || n == 61)",
            "                return true;",
            "            if (n % 2 == 0)",
            "                return false;",
            "            long long d = n - 1;",
            "            while (d % 2 == 0)",
            "                d /= 2;",
            "            constexpr long long bases[3] = {2, 7, 61};",
            "            for (long long a : bases)",
            "            {",
            "                long long t = d;",
            "                long long y = pow_mod_constexpr(a, t, n);",
            "                while (t != n - 1 && y != 1 && y != n - 1)",
            "                {",
            "                    y = y * y % n;",
            "                    t <<= 1;",
            "                }",
            "                if (y != n - 1 && t % 2 == 0)",
            "                {",
            "                    return false;",
            "                }",
            "            }",
            "            return true;",
            "        }",
            "        template <int n>",
            "        constexpr bool is_prime = is_prime_constexpr(n);",
            "",
            "        // @param b `1 <= b`",
            "        // @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g",
            "        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b)",
            "        {",
            "            a = safe_mod(a, b);",
            "            if (a == 0)",
            "                return {b, 0};",
            "",
            "            // Contracts:",
            "            // [1] s - m0 * a = 0 (mod b)",
            "            // [2] t - m1 * a = 0 (mod b)",
            "            // [3] s * |m1| + t * |m0| <= b",
            "            long long s = b, t = a;",
            "            long long m0 = 0, m1 = 1;",
            "",
            "            while (t)",
            "            {",
            "                long long u = s / t;",
            "                s -= t * u;",
            "                m0 -= m1 * u; // |m1 * u| <= |m1| * s <= b",
            "",
            "                // [3]:",
            "                // (s - t * u) * |m1| + t * |m0 - m1 * u|",
            "                // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)",
            "                // = s * |m1| + t * |m0| <= b",
            "",
            "                auto tmp = s;",
            "                s = t;",
            "                t = tmp;",
            "                tmp = m0;",
            "                m0 = m1;",
            "                m1 = tmp;",
            "            }",
            "            // by [3]: |m0| <= b/g",
            "            // by g != b: |m0| < b/g",
            "            if (m0 < 0)",
            "                m0 += b / s;",
            "            return {s, m0};",
            "        }",
            "",
            "        // Compile time primitive root",
            "        // @param m must be prime",
            "        // @return primitive root (and minimum in now)",
            "        constexpr int primitive_root_constexpr(int m)",
            "        {",
            "            if (m == 2)",
            "                return 1;",
            "            if (m == 167772161)",
            "                return 3;",
            "            if (m == 469762049)",
            "                return 3;",
            "            if (m == 754974721)",
            "                return 11;",
            "            if (m == 998244353)",
            "                return 3;",
            "            int divs[20] = {};",
            "            divs[0] = 2;",
            "            int cnt = 1;",
            "            int x = (m - 1) / 2;",
            "            while (x % 2 == 0)",
            "                x /= 2;",
            "            for (int i = 3; (long long)(i)*i <= x; i += 2)",
            "            {",
            "                if (x % i == 0)",
            "                {",
            "                    divs[cnt++] = i;",
            "                    while (x % i == 0)",
            "                    {",
            "                        x /= i;",
            "                    }",
            "                }",
            "            }",
            "            if (x > 1)",
            "            {",
            "                divs[cnt++] = x;",
            "            }",
            "            for (int g = 2;; g++)",
            "            {",
            "                bool ok = true;",
            "                for (int i = 0; i < cnt; i++)",
            "                {",
            "                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1)",
            "                    {",
            "                        ok = false;",
            "                        break;",
            "                    }",
            "                }",
            "                if (ok)",
            "                    return g;",
            "            }",
            "        }",
            "        template <int m>",
            "        constexpr int primitive_root = primitive_root_constexpr(m);",
            "",
            "        // @param n `n < 2^32`",
            "        // @param m `1 <= m < 2^32`",
            "        // @return sum_{i=0}^{n-1} floor((ai + b) / m) (mod 2^64)",
            "        unsigned long long floor_sum_unsigned(unsigned long long n,",
            "                                              unsigned long long m,",
            "                                              unsigned long long a,",
            "                                              unsigned long long b)",
            "        {",
            "            unsigned long long ans = 0;",
            "            while (true)",
            "            {",
            "                if (a >= m)",
            "                {",
            "                    ans += n * (n - 1) / 2 * (a / m);",
            "                    a %= m;",
            "                }",
            "                if (b >= m)",
            "                {",
            "                    ans += n * (b / m);",
            "                    b %= m;",
            "                }",
            "",
            "                unsigned long long y_max = a * n + b;",
            "                if (y_max < m)",
            "                    break;",
            "                // y_max < m * (n + 1)",
            "                // floor(y_max / m) <= n",
            "                n = (unsigned long long)(y_max / m);",
            "                b = (unsigned long long)(y_max % m);",
            "                std::swap(m, a);",
            "            }",
            "            return ans;",
            "        }",
            "",
            "    } // namespace internal",
            "",
            "} // namespace atcoder",
            "namespace atcoder",
            "{",
            "",
            "    namespace internal",
            "    {",
            "",
            "#ifndef _MSC_VER",
            "        template <class T>",
            "        using is_signed_int128 =",
            "            typename std::conditional<std::is_same<T, __int128_t>::value ||",
            "                                          std::is_same<T, __int128>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_unsigned_int128 =",
            "            typename std::conditional<std::is_same<T, __uint128_t>::value ||",
            "                                          std::is_same<T, unsigned __int128>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using make_unsigned_int128 =",
            "            typename std::conditional<std::is_same<T, __int128_t>::value,",
            "                                      __uint128_t,",
            "                                      unsigned __int128>;",
            "",
            "        template <class T>",
            "        using is_integral = typename std::conditional<std::is_integral<T>::value ||",
            "                                                          is_signed_int128<T>::value ||",
            "                                                          is_unsigned_int128<T>::value,",
            "                                                      std::true_type,",
            "                                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_signed_int = typename std::conditional<(is_integral<T>::value &&",
            "                                                         std::is_signed<T>::value) ||",
            "                                                            is_signed_int128<T>::value,",
            "                                                        std::true_type,",
            "                                                        std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_unsigned_int =",
            "            typename std::conditional<(is_integral<T>::value &&",
            "                                       std::is_unsigned<T>::value) ||",
            "                                          is_unsigned_int128<T>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using to_unsigned = typename std::conditional<",
            "            is_signed_int128<T>::value,",
            "            make_unsigned_int128<T>,",
            "            typename std::conditional<std::is_signed<T>::value,",
            "                                      std::make_unsigned<T>,",
            "                                      std::common_type<T>>::type>::type;",
            "",
            "#else",
            "",
            "        template <class T>",
            "        using is_integral = typename std::is_integral<T>;",
            "",
            "        template <class T>",
            "        using is_signed_int =",
            "            typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_unsigned_int =",
            "            typename std::conditional<is_integral<T>::value &&",
            "                                          std::is_unsigned<T>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using to_unsigned = typename std::conditional<is_signed_int<T>::value,",
            "                                                      std::make_unsigned<T>,",
            "                                                      std::common_type<T>>::type;",
            "",
            "#endif",
            "",
            "        template <class T>",
            "        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
            "",
            "        template <class T>",
            "        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
            "",
            "        template <class T>",
            "        using to_unsigned_t = typename to_unsigned<T>::type;",
            "",
            "    } // namespace internal",
            "",
            "} // namespace atcoder",
            "namespace atcoder",
            "{",
            "",
            "    namespace internal",
            "    {",
            "",
            "        struct modint_base",
            "        {",
            "        };",
            "        struct static_modint_base : modint_base",
            "        {",
            "        };",
            "",
            "        template <class T>",
            "        using is_modint = std::is_base_of<modint_base, T>;",
            "        template <class T>",
            "        using is_modint_t = std::enable_if_t<is_modint<T>::value>;",
            "",
            "    } // namespace internal",
            "",
            "    template <int m, std::enable_if_t<(1 <= m)> * = nullptr>",
            "    struct static_modint : internal::static_modint_base",
            "    {",
            "        using mint = static_modint;",
            "",
            "    public:",
            "        static constexpr int mod() { return m; }",
            "        static mint raw(int v)",
            "        {",
            "            mint x;",
            "            x._v = v;",
            "            return x;",
            "        }",
            "",
            "        static_modint() : _v(0) {}",
            "        template <class T, internal::is_signed_int_t<T> * = nullptr>",
            "        static_modint(T v)",
            "        {",
            "            long long x = (long long)(v % (long long)(umod()));",
            "            if (x < 0)",
            "                x += umod();",
            "            _v = (unsigned int)(x);",
            "        }",
            "        template <class T, internal::is_unsigned_int_t<T> * = nullptr>",
            "        static_modint(T v)",
            "        {",
            "            _v = (unsigned int)(v % umod());",
            "        }",
            "",
            "        unsigned int val() const { return _v; }",
            "",
            "        mint &operator++()",
            "        {",
            "            _v++;",
            "            if (_v == umod())",
            "                _v = 0;",
            "            return *this;",
            "        }",
            "        mint &operator--()",
            "        {",
            "            if (_v == 0)",
            "                _v = umod();",
            "            _v--;",
            "            return *this;",
            "        }",
            "        mint operator++(int)",
            "        {",
            "            mint result = *this;",
            "            ++*this;",
            "            return result;",
            "        }",
            "        mint operator--(int)",
            "        {",
            "            mint result = *this;",
            "            --*this;",
            "            return result;",
            "        }",
            "",
            "        mint &operator+=(const mint &rhs)",
            "        {",
            "            _v += rhs._v;",
            "            if (_v >= umod())",
            "                _v -= umod();",
            "            return *this;",
            "        }",
            "        mint &operator-=(const mint &rhs)",
            "        {",
            "            _v -= rhs._v;",
            "            if (_v >= umod())",
            "                _v += umod();",
            "            return *this;",
            "        }",
            "        mint &operator*=(const mint &rhs)",
            "        {",
            "            unsigned long long z = _v;",
            "            z *= rhs._v;",
            "            _v = (unsigned int)(z % umod());",
            "            return *this;",
            "        }",
            "        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "",
            "        mint operator+() const { return *this; }",
            "        mint operator-() const { return mint() - *this; }",
            "",
            "        mint pow(long long n) const",
            "        {",
            "            assert(0 <= n);",
            "            mint x = *this, r = 1;",
            "            while (n)",
            "            {",
            "                if (n & 1)",
            "                    r *= x;",
            "                x *= x;",
            "                n >>= 1;",
            "            }",
            "            return r;",
            "        }",
            "        mint inv() const",
            "        {",
            "            if (prime)",
            "            {",
            "                assert(_v);",
            "                return pow(umod() - 2);",
            "            }",
            "            else",
            "            {",
            "                auto eg = internal::inv_gcd(_v, m);",
            "                assert(eg.first == 1);",
            "                return eg.second;",
            "            }",
            "        }",
            "",
            "        friend mint operator+(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) += rhs;",
            "        }",
            "        friend mint operator-(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) -= rhs;",
            "        }",
            "        friend mint operator*(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) *= rhs;",
            "        }",
            "        friend mint operator/(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) /= rhs;",
            "        }",
            "        friend bool operator==(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v == rhs._v;",
            "        }",
            "        friend bool operator!=(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v != rhs._v;",
            "        }",
            "",
            "    private:",
            "        unsigned int _v;",
            "        static constexpr unsigned int umod() { return m; }",
            "        static constexpr bool prime = internal::is_prime<m>;",
            "    };",
            "",
            "    template <int id>",
            "    struct dynamic_modint : internal::modint_base",
            "    {",
            "        using mint = dynamic_modint;",
            "",
            "    public:",
            "        static int mod() { return (int)(bt.umod()); }",
            "        static void set_mod(int m)",
            "        {",
            "            assert(1 <= m);",
            "            bt = internal::barrett(m);",
            "        }",
            "        static mint raw(int v)",
            "        {",
            "            mint x;",
            "            x._v = v;",
            "            return x;",
            "        }",
            "",
            "        dynamic_modint() : _v(0) {}",
            "        template <class T, internal::is_signed_int_t<T> * = nullptr>",
            "        dynamic_modint(T v)",
            "        {",
            "            long long x = (long long)(v % (long long)(mod()));",
            "            if (x < 0)",
            "                x += mod();",
            "            _v = (unsigned int)(x);",
            "        }",
            "        template <class T, internal::is_unsigned_int_t<T> * = nullptr>",
            "        dynamic_modint(T v)",
            "        {",
            "            _v = (unsigned int)(v % mod());",
            "        }",
            "",
            "        unsigned int val() const { return _v; }",
            "",
            "        mint &operator++()",
            "        {",
            "            _v++;",
            "            if (_v == umod())",
            "                _v = 0;",
            "            return *this;",
            "        }",
            "        mint &operator--()",
            "        {",
            "            if (_v == 0)",
            "                _v = umod();",
            "            _v--;",
            "            return *this;",
            "        }",
            "        mint operator++(int)",
            "        {",
            "            mint result = *this;",
            "            ++*this;",
            "            return result;",
            "        }",
            "        mint operator--(int)",
            "        {",
            "            mint result = *this;",
            "            --*this;",
            "            return result;",
            "        }",
            "",
            "        mint &operator+=(const mint &rhs)",
            "        {",
            "            _v += rhs._v;",
            "            if (_v >= umod())",
            "                _v -= umod();",
            "            return *this;",
            "        }",
            "        mint &operator-=(const mint &rhs)",
            "        {",
            "            _v += mod() - rhs._v;",
            "            if (_v >= umod())",
            "                _v -= umod();",
            "            return *this;",
            "        }",
            "        mint &operator*=(const mint &rhs)",
            "        {",
            "            _v = bt.mul(_v, rhs._v);",
            "            return *this;",
            "        }",
            "        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "",
            "        mint operator+() const { return *this; }",
            "        mint operator-() const { return mint() - *this; }",
            "",
            "        mint pow(long long n) const",
            "        {",
            "            assert(0 <= n);",
            "            mint x = *this, r = 1;",
            "            while (n)",
            "            {",
            "                if (n & 1)",
            "                    r *= x;",
            "                x *= x;",
            "                n >>= 1;",
            "            }",
            "            return r;",
            "        }",
            "        mint inv() const",
            "        {",
            "            auto eg = internal::inv_gcd(_v, mod());",
            "            assert(eg.first == 1);",
            "            return eg.second;",
            "        }",
            "",
            "        friend mint operator+(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) += rhs;",
            "        }",
            "        friend mint operator-(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) -= rhs;",
            "        }",
            "        friend mint operator*(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) *= rhs;",
            "        }",
            "        friend mint operator/(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) /= rhs;",
            "        }",
            "        friend bool operator==(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v == rhs._v;",
            "        }",
            "        friend bool operator!=(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v != rhs._v;",
            "        }",
            "",
            "    private:",
            "        unsigned int _v;",
            "        static internal::barrett bt;",
            "        static unsigned int umod() { return bt.umod(); }",
            "    };",
            "    template <int id>",
            "    internal::barrett dynamic_modint<id>::bt(998244353);",
            "",
            "    using modint998244353 = static_modint<998244353>;",
            "    using modint1000000007 = static_modint<1000000007>;",
            "    using modint = dynamic_modint<-1>;",
            "",
            "    namespace internal",
            "    {",
            "",
            "        template <class T>",
            "        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;",
            "",
            "        template <class T>",
            "        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;",
            "",
            "        template <class>",
            "        struct is_dynamic_modint : public std::false_type",
            "        {",
            "        };",
            "        template <int id>",
            "        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type",
            "        {",
            "        };",
            "",
            "        template <class T>",
            "        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;",
            "",
            "    } // namespace internal",
            "",
            "} // namespace atcoder",
            "",
            "using mint = atcoder::dynamic_modint<-1>;",
            "// mint::set_mod(variable_mod)"
        ],
        "description": "Snippet for mod_int_variable (normal version)"
    },
    "template_mod_int": {
        "prefix": "template_mod_int",
        "body": [
            "template <const int &MOD>",
            "struct modular_int",
            "{",
            "    int val;",
            "",
            "    modular_int(int64_t v = 0)",
            "    {",
            "        if (v < 0)",
            "            v = v % MOD + MOD;",
            "        if (v >= MOD)",
            "            v %= MOD;",
            "        val = int(v);",
            "    }",
            "",
            "    modular_int(uint64_t v)",
            "    {",
            "        if (v >= MOD)",
            "            v %= MOD;",
            "        val = int(v);",
            "    }",
            "",
            "    modular_int(int v) : modular_int(int64_t(v)) {}",
            "    modular_int(unsigned v) : modular_int(uint64_t(v)) {}",
            "",
            "    explicit operator int() const { return val; }",
            "    explicit operator unsigned() const { return val; }",
            "    explicit operator int64_t() const { return val; }",
            "    explicit operator uint64_t() const { return val; }",
            "    explicit operator double() const { return val; }",
            "    explicit operator long double() const { return val; }",
            "",
            "    modular_int &operator+=(const modular_int &other)",
            "    {",
            "        val -= MOD - other.val;",
            "        if (val < 0)",
            "            val += MOD;",
            "        return *this;",
            "    }",
            "",
            "    modular_int &operator-=(const modular_int &other)",
            "    {",
            "        val -= other.val;",
            "        if (val < 0)",
            "            val += MOD;",
            "        return *this;",
            "    }",
            "",
            "    static unsigned fast_mod(uint64_t x, unsigned m = MOD)",
            "    {",
            "#if !defined(_WIN32) || defined(_WIN64)",
            "        return unsigned(x % m);",
            "#endif",
            "        // Optimized mod for Codeforces 32-bit machines.",
            "        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.",
            "        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);",
            "        unsigned quot, rem;",
            "        asm(\"divl %4\\\\n\"",
            "            : \"=a\"(quot), \"=d\"(rem)",
            "            : \"d\"(x_high), \"a\"(x_low), \"r\"(m));",
            "        return rem;",
            "    }",
            "",
            "    modular_int &operator*=(const modular_int &other)",
            "    {",
            "        val = fast_mod(uint64_t(val) * other.val);",
            "        return *this;",
            "    }",
            "",
            "    modular_int &operator/=(const modular_int &other)",
            "    {",
            "        return *this *= other.inv();",
            "    }",
            "",
            "    friend modular_int operator+(const modular_int &a, const modular_int &b) { return modular_int(a) += b; }",
            "    friend modular_int operator-(const modular_int &a, const modular_int &b) { return modular_int(a) -= b; }",
            "    friend modular_int operator*(const modular_int &a, const modular_int &b) { return modular_int(a) *= b; }",
            "    friend modular_int operator/(const modular_int &a, const modular_int &b) { return modular_int(a) /= b; }",
            "",
            "    modular_int &operator++()",
            "    {",
            "        val = val == MOD - 1 ? 0 : val + 1;",
            "        return *this;",
            "    }",
            "",
            "    modular_int &operator--()",
            "    {",
            "        val = val == 0 ? MOD - 1 : val - 1;",
            "        return *this;",
            "    }",
            "",
            "    modular_int operator++(int)",
            "    {",
            "        modular_int before = *this;",
            "        ++*this;",
            "        return before;",
            "    }",
            "    modular_int operator--(int)",
            "    {",
            "        modular_int before = *this;",
            "        --*this;",
            "        return before;",
            "    }",
            "",
            "    modular_int operator-() const",
            "    {",
            "        return val == 0 ? 0 : MOD - val;",
            "    }",
            "",
            "    friend bool operator==(const modular_int &a, const modular_int &b) { return a.val == b.val; }",
            "    friend bool operator!=(const modular_int &a, const modular_int &b) { return a.val != b.val; }",
            "    friend bool operator<(const modular_int &a, const modular_int &b) { return a.val < b.val; }",
            "    friend bool operator>(const modular_int &a, const modular_int &b) { return a.val > b.val; }",
            "    friend bool operator<=(const modular_int &a, const modular_int &b) { return a.val <= b.val; }",
            "    friend bool operator>=(const modular_int &a, const modular_int &b) { return a.val >= b.val; }",
            "",
            "    static const int SAVE_INV = int(1e6) + 5;",
            "    static modular_int save_inv[SAVE_INV];",
            "",
            "    static void prepare_inv()",
            "    {",
            "        // Ensures that MOD is prime, which is necessary for the inverse algorithm below.",
            "        for (int64_t p = 2; p * p <= MOD; p += p % 2 + 1)",
            "            assert(MOD % p != 0);",
            "",
            "        save_inv[0] = 0;",
            "        save_inv[1] = 1;",
            "",
            "        for (int i = 2; i < SAVE_INV; i++)",
            "            save_inv[i] = save_inv[MOD % i] * (MOD - MOD / i);",
            "    }",
            "",
            "    modular_int inv() const",
            "    {",
            "        if (save_inv[1] == 0)",
            "            prepare_inv();",
            "",
            "        if (val < SAVE_INV)",
            "            return save_inv[val];",
            "",
            "        modular_int product = 1;",
            "        int v = val;",
            "",
            "        do",
            "        {",
            "            product *= MOD - MOD / v;",
            "            v = MOD % v;",
            "        } while (v >= SAVE_INV);",
            "",
            "        return product * save_inv[v];",
            "    }",
            "",
            "    modular_int pow(int64_t p) const",
            "    {",
            "        if (p < 0)",
            "            return inv().pow(-p);",
            "",
            "        modular_int a = *this, result = 1;",
            "",
            "        while (p > 0)",
            "        {",
            "            if (p & 1)",
            "                result *= a;",
            "",
            "            p >>= 1;",
            "",
            "            if (p > 0)",
            "                a *= a;",
            "        }",
            "",
            "        return result;",
            "    }",
            "",
            "    friend ostream &operator<<(ostream &os, const modular_int &m)",
            "    {",
            "        return os << m.val;",
            "    }",
            "};",
            "template <const int &MOD>",
            "modular_int<MOD> modular_int<MOD>::save_inv[modular_int<MOD>::SAVE_INV];",
            "const int MOD = 998244353;",
            "using mint = modular_int<MOD>;",
            "void __print(mint x) { cerr << x; }"
        ],
        "description": "Snippet for mod_int (normal version)"
    },
    "template_combinatorics": {
        "prefix": "template_combinatorics",
        "body": [
            "template<typename T, const int P>",
            "class combinatorics",
            "{",
            "public:",
            "    int n;",
            "    vector<T> inv, fac, ifac, pw;",
            "    combinatorics (int n) : n(n), inv(n), fac(n), ifac(n), pw(n)",
            "    {",
            "        fac[0] = inv[0] = ifac[0] = pw[0] = T(1);",
            " ",
            "        for(int i = 1; i <= n; i ++)",
            "            inv[i] = T(1)/T(i), fac[i] = fac[i - 1] * T(i), ifac[i] = ifac[i - 1] * inv[i], pw[i] = pw[i - 1] * T(P);",
            "    }",
            "",
            "    T ncr(int n, int r)",
            "    {",
            "        if(n < r or r < 0)",
            "            return 0;",
            "        return fac[n] * ifac[r] * ifac[n - r];",
            "    }",
            "};"
        ],
        "description": "Snippet for combinatorics (normal version)"
    },
    "template_convex_hull_trick": {
        "prefix": "template_convex_hull_trick",
        "body": [
            "class cht_chan",
            "{",
            "public:",
            "    /*",
            "        tc: O(log(n)) per insertion amortized, O(log(n)) per query",
            "        ml: O(n)",
            "",
            "        info:",
            "            1. inserts lines of form Ax + B",
            "            2. returns inserted line with maximum value of Ax + B for queried x ",
            "    */",
            "\tstatic const int64_t INF=1e18;",
            "\tstruct Line",
            "\t{",
            "\t\tint64_t a, b; //y = ax + b",
            "\t\tdouble xLeft; //Stores the llersection wiith previous line in the convex hull. First line has -INF",
            "",
            "\t\tenum Type {line, maxQuery, minQuery} type;",
            "\t\tint64_t val;",
            "",
            "\t\texplicit Line(int64_t aa=0, int64_t bb=0): a(aa), b(bb), xLeft(-INF), type(Type::line), val(0) {}",
            "",
            "\t\tint64_t valueAt(int64_t x) const",
            "\t\t{",
            "\t\t\treturn a*x + b;",
            "\t\t}",
            "\t\tfriend bool isParallel(const Line &l1, const Line &l2)",
            "\t\t{",
            "\t\t\treturn l1.a == l2.a;",
            "\t\t}",
            "\t\tfriend double llersectX(const Line &l1, const Line &l2)",
            "\t\t{",
            "\t\t\treturn isParallel(l1, l2)?INF:1.0*(l2.b-l1.b)/(l1.a-l2.a);",
            "\t\t}",
            "\t\tbool operator<(const Line& l2) const",
            "\t\t{",
            "\t\t\tif(l2.type == line)",
            "\t\t\t\treturn this->a < l2.a;",
            "\t\t\tif(l2.type == maxQuery)",
            "\t\t\t\treturn this->xLeft < l2.val;",
            "\t\t\tif(l2.type == minQuery)",
            "\t\t\t\treturn this->xLeft > l2.val;",
            "            return 0;",
            "\t\t}",
            "\t};",
            "",
            "\tbool isMax;",
            "\tset<Line> hull;",
            "",
            "\tbool hasPrev(set<Line>::iterator it)",
            "\t{",
            "\t\treturn it!=hull.begin();",
            "\t}\t",
            "\tbool hasNext(set<Line>::iterator it)",
            "\t{",
            "\t\treturn it!=hull.end() && next(it)!=hull.end();",
            "\t}",
            "\tbool irrelevant(const Line &l1, const Line &l2, const Line &l3)",
            "\t{",
            "\t\treturn llersectX(l1, l3) <= llersectX(l1, l2);",
            "\t}",
            "\tbool irrelevant(set<Line>::iterator it)",
            "\t{",
            "\t\treturn hasPrev(it) && hasNext(it) && ( ",
            "\t\t\t(isMax && irrelevant(*prev(it), *it, *next(it))) ",
            "\t\t\t|| (!isMax && irrelevant(*next(it), *it, *prev(it))));",
            "\t}",
            "\t//Updates xValue of line polled by it",
            "\tset<Line>::iterator updateLeftBorder(set<Line>::iterator it)",
            "\t{",
            "\t\tif(isMax && !hasPrev(it) || !isMax && !hasNext(it))",
            "\t\t\treturn it;",
            "\t\tdouble val=llersectX(*it, isMax?(*prev(it)):(*next(it)));",
            "\t\tLine temp(*it);",
            "\t\tit=hull.erase(it);",
            "\t\ttemp.xLeft=val;",
            "\t\tit=hull.insert(it, temp);",
            "\t\treturn it;",
            "\t}",
            "",
            "\texplicit cht_chan(bool isMax): isMax(isMax) {}",
            "",
            "\tvoid add_line(int64_t a, int64_t b) //Add ax + b in logN time",
            "\t{",
            "\t\tLine l3=Line(a, b);",
            "\t\tauto it=hull.lower_bound(l3);",
            "",
            "\t\t//If parallel liune is already in set, one of the lines becomes irrelevant",
            "\t\tif(it!=hull.end() && isParallel(*it, l3))",
            "\t\t{",
            "\t\t\tif(isMax && it->b<b || !isMax && it->b>b)",
            "\t\t\t\tit=hull.erase(it);",
            "\t\t\telse",
            "\t\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tit=hull.insert(it, l3);",
            "\t\tif(irrelevant(it))",
            "\t\t{",
            "\t\t\thull.erase(it);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\t//Remove lines which became irrelevant after inserting",
            "\t\twhile(hasPrev(it) && irrelevant(prev(it)))",
            "\t\t\thull.erase(prev(it));",
            "\t\twhile(hasNext(it) && irrelevant(next(it)))",
            "\t\t\thull.erase(next(it));",
            "",
            "\t\t//Update xLine",
            "\t\tit=updateLeftBorder(it);",
            "\t\tif(hasPrev(it))",
            "\t\t\tupdateLeftBorder(prev(it));",
            "\t\tif(hasNext(it))",
            "\t\t\tupdateLeftBorder(next(it));",
            "\t}",
            "",
            "\tint64_t get_opt(int64_t x)",
            "\t{",
            "\t\tLine q;",
            "\t\tq.val=x;",
            "\t\tq.type = isMax?Line::Type::maxQuery : Line::Type::minQuery;",
            "",
            "\t\tauto bestLine=hull.lower_bound(q);",
            "\t\tif(isMax)",
            "\t\t\t--bestLine;",
            "\t\treturn bestLine->valueAt(x);",
            "\t}",
            "};"
        ],
        "description": "Snippet for convex_hull_trick (normal version)"
    },
    "template_manachers": {
        "prefix": "template_manachers",
        "body": [
            "template <typename T>",
            "vector<int> manachers_chan(const T &s)",
            "{",
            "    /*",
            "        tc: O(|s|)",
            "        mc: O(|s|)",
            "",
            "        info:",
            "            0-indexed",
            "            res[2 * i]  = odd RADIUS in position i",
            "            res[2 * i + 1] = even RADIUS between positions i and i + 1",
            "        ",
            "        ex:",
            "            s = \"abaa\" -> res = {0, 0, 1, 0, 0, 1, 0};",
            "        ",
            "        author notes:",
            "            in other words, for every z from 0 to 2 * n - 2:",
            "            calculate i = (z + 1) >> 1 and j = z >> 1",
            "            now there is a palindrome from i - res[z] to j + res[z]",
            "            (watch out for i > j and res[z] = 0)",
            "    */",
            "    int n = (int)s.size();",
            "    if (n == 0)",
            "        return vector<int>();",
            "        ",
            "    vector<int> res(2 * n - 1, 0);",
            "    int l = -1, r = -1;",
            "    for (int z = 0; z < 2 * n - 1; z ++)",
            "    {",
            "        int i = (z + 1) >> 1, j = z >> 1;",
            "        int p = (i >= r ? 0 : min(r - i, res[2 * (l + r) - z]));",
            "",
            "        while (j + p + 1 < n and i - p - 1 >= 0 and (s[j + p + 1] == s[i - p - 1]))",
            "            p ++;",
            "",
            "        if (j + p > r)",
            "            l = i - p, r = j + p;",
            "        res[z] = p;",
            "    }",
            "",
            "    return res;",
            "}"
        ],
        "description": "Snippet for manachers (normal version)"
    },
    "template_trie": {
        "prefix": "template_trie",
        "body": [
            "template<const int C>",
            "class static_node_chan",
            "{",
            "public:",
            "    int sub = 0;",
            "    int leaf = 0;",
            "    array<int, C> next;",
            "};",
            "class dynamic_node_chan",
            "{",
            "public: ",
            "    int sub = 0;",
            "    int leaf = 0;",
            "    map<int, int> next;",
            "};",
            "",
            "template<typename S, typename T, typename I>",
            "class trie_chan",
            "{",
            "public:",
            "    int r = 0, p = 0;",
            "    vector<T> t;",
            "    I ind;",
            "",
            "    trie_chan(int n, I ind) : t(n), ind(ind) {};",
            "",
            "    void insert(const vector<S> &s)",
            "    {",
            "        int v = r;",
            "        for(auto x : s)",
            "        {",
            "            ++ t[v].sub;",
            "",
            "            int f = ind(x);",
            "         ",
            "            if(t[v].next[f] == 0)",
            "                t[v].next[f] = ++ p;",
            "            v = t[v].next[f];",
            "        }",
            "        ++ t[v].sub, ++ t[v].leaf;",
            "    }",
            "};"
        ],
        "description": "Snippet for trie (normal version)"
    },
    "template_suffix_tree": {
        "prefix": "template_suffix_tree",
        "body": [
            "class suffix_tree_chan",
            "{",
            "    /*",
            "    tc: O(n)",
            "    mc: O(n)",
            "",
            "    info:",
            "        0 indexed",
            "        pass it 0 indexed suffix array and lcp array",
            "        constructs suffix tree with the following properties:",
            "            1. node i (< n) represents suffix i (length = n - 1)",
            "            2. for every suffix there exists node in the suffix tree (even if it has only child)",
            "            3. if u > v, then u cannot be in the subtree of v",
            "            4. adj[u] contains downward edges from node u, sorted lexicography in order of strings on their labels",
            "            5. `root` is root node",
            "            6. dep[u] contains length of path from root to node u, used for edge labels",
            "            7. rep[u] = some i such that leaf for suffix i is in subtree of u ",
            "            8. m is the total number of nodes in the suffix tree (so m - n is the number of new internal nodes)",
            "",
            "        warning:",
            "            sa gets modified so dont pass by reference",
            "    */",
            "public:",
            "    int n, m, root;",
            "    vector<int> dep, rep;",
            "    vector<vector<int>> adj;",
            "",
            "    suffix_tree_chan(int n, vector<int> sa, vector<int> lcp) : ",
            "    n(n), m(n), dep(2 * n + 1), rep(2 * n + 1), adj(2 * n + 1)",
            "    {",
            "        vector<int> l(n), r(n);",
            "        for(int i = 0; i < n; i ++) ",
            "            l[i] = r[i] = rep[i] = i, dep[i] = n - i;",
            "        ",
            "        vector<vector<int>> q(n);",
            "        for(int i = 0; i < n - 1; i ++)",
            "            q[lcp[i]].push_back(i);",
            "        ",
            "        for(int d = n - 1; d >= 0; d --)",
            "            for(auto i : q[d])",
            "            {",
            "                int u;",
            "                if(dep[sa[i]] == d)",
            "                    u = sa[i], adj[u].push_back(sa[i + 1]);",
            "                else if(dep[sa[i + 1]] == d)",
            "                    u = sa[i + 1], adj[u].push_back(sa[i]);",
            "                else",
            "                    u = m ++, rep[u] = rep[sa[i]], adj[u] = {sa[i], sa[i + 1]};",
            "                ",
            "                dep[u] = d;",
            "                l[r[i + 1]] = l[i], r[l[i]] = r[i + 1];",
            "                sa[l[i]] = sa[r[i + 1]] = u;",
            "            }",
            "",
            "        root = sa[0];",
            "        if(dep[root] != 0)",
            "            root = m ++, dep[root] = 0, adj[root] = {sa[0]};",
            "    };",
            "};"
        ],
        "description": "Snippet for suffix_tree (normal version)"
    },
    "template_kmp": {
        "prefix": "template_kmp",
        "body": [
            "template <typename T>",
            "vector<int> kmp_table(const T &s)",
            "{",
            "    /*",
            "        tc: O(|s|)",
            "        mc: O(|s|)",
            "",
            "        info:",
            "            p[i] = longest suffix of substring s[0, 1, .. i] which is also a suffix ",
            "    */",
            "    int n = s.size();",
            "    vector<int> p(n, 0);",
            "    int k = 0;",
            "    for (int i = 1; i < n; i ++)",
            "    {",
            "        while (k > 0 && !(s[i] == s[k]))",
            "            k = p[k - 1];",
            "        if (s[i] == s[k])",
            "            k ++;",
            "        p[i] = k;",
            "    }",
            "    return p;",
            "}",
            "",
            "template <typename T>",
            "vector<int> kmp_search(const T &s, const T &w, const vector<int> &p)",
            "{",
            "    /*",
            "        tc: O(|s| + |w|)",
            "        mc: O(|w|)",
            "",
            "        info:",
            "            finds 0-indexed positions of occurences of s in w",
            "            p is kmp table of s",
            "    */",
            "    int n = s.size(), m = w.size();",
            "    assert(n >= 1 && (int)p.size() == n);",
            "    vector<int> res;",
            "    int k = 0;",
            "    for (int i = 0; i < m; i ++)",
            "    {",
            "        while (k > 0 && (k == n || !(w[i] == s[k])))",
            "            k = p[k - 1];",
            "        if (w[i] == s[k])",
            "            k ++;",
            "        if (k == n)",
            "            res.push_back(i - n + 1);",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Snippet for kmp (normal version)"
    },
    "template_z": {
        "prefix": "template_z",
        "body": [
            "template <typename T>",
            "vector<int> z_chan(const T &s)",
            "{",
            "    int n = s.size();",
            "    vector<int> z(n, n);",
            "    int l = 0, r = 0;",
            "    for (int i = 1; i < n; i++)",
            "    {",
            "        z[i] = (i > r ? 0 : min(r - i + 1, z[i - l]));",
            "        while (i + z[i] < n && s[z[i]] == s[i + z[i]])",
            "            z[i]++;",
            "",
            "        if (i + z[i] - 1 > r)",
            "            l = i, r = i + z[i] - 1;",
            "    }",
            "    return z;",
            "}"
        ],
        "description": "Snippet for z (normal version)"
    },
    "template_suffix_array": {
        "prefix": "template_suffix_array",
        "body": [
            "template <class T>",
            "array<vector<int>, 3> suffix_array_chan(const T &s, int max_num)",
            "{",
            "    /*",
            "        tc: O(|s|.log(|s|) + max_num)",
            "        mc: O(|s| + max_num)",
            "",
            "        info:",
            "            must pass s such that s[i] works as array index",
            "            returns {suffix array, inverse suffix array, lcp array}",
            "    */",
            "    int n = (int)size(s);",
            "    vector<int> sa(n), sa_inv(begin(s), end(s)), lcp(max(0, n - 1));",
            "    iota(begin(sa), end(sa), 0);",
            "    ",
            "    for (int ln = 0; ln < n; ln = max(1, 2 * ln))",
            "    {",
            "        vector<int> tmp(n), freq(max_num);",
            "        iota(begin(tmp), begin(tmp) + ln, n - ln);",
            "        copy_if(begin(sa), end(sa), begin(tmp) + ln, [&](int &x) { return (x -= ln) >= 0; });",
            "        for (int x : sa_inv)    freq[x]++;",
            "        ",
            "        partial_sum(begin(freq), end(freq), begin(freq));",
            "        for_each(rbegin(tmp), rend(tmp), [&](int x) { sa[--freq[sa_inv[x]]] = x; });",
            "        swap(sa_inv, tmp);",
            "        max_num = 1, sa_inv[sa[0]] = 0;",
            "        ",
            "        auto prev_inv = [&](int i) { return pair(tmp[i], i + ln < n ? tmp[i + ln] : -1); };",
            "        for (int i = 1; i < (n); i++)",
            "        {",
            "            max_num += prev_inv(sa[i - 1]) != prev_inv(sa[i]);",
            "            sa_inv[sa[i]] = max_num - 1;",
            "        }",
            "        if (max_num == n)",
            "            break;",
            "    }",
            "",
            "    int sz = 0;",
            "    for (int i = 0; i < (n); i++)",
            "    {",
            "        if (sz > 0)",
            "            sz--;",
            "        if (sa_inv[i] == 0)",
            "            continue;",
            "        for (int j = sa[sa_inv[i] - 1]; max(i, j) + sz < n && s[i + sz] == s[j + sz];)",
            "            sz++;",
            "        lcp[sa_inv[i] - 1] = sz;",
            "    }",
            "    return {sa, sa_inv, lcp};",
            "}"
        ],
        "description": "Snippet for suffix_array (normal version)"
    },
    "template_mo": {
        "prefix": "template_mo",
        "body": [
            "template <const int B, const int mode = 1>",
            "class mo_chan",
            "{",
            "    /*",
            "        info:",
            "            - 0 indexed",
            "            - mode = 1 for the regular query order, mode = 2 for the fancier one",
            "        usage:",
            "            - one provides external add(array index)/delete(array index)/query(query index) functions  ",
            "            - naturally, you'll have to maintain the window aggregate externally too",
            "            - so for range sum queries, the external helpers are:",
            "                int64_t sum = 0;",
            "                auto add = [&](int i) -> void",
            "                {",
            "                    sum += a[i];",
            "                };",
            "                auto rem = [&](int i) -> void",
            "                {",
            "                    sum -= a[i];",
            "                };",
            "                vector<int64_t> ans(q);",
            "                auto query = [&](int i) -> void",
            "                {",
            "                    ans[i] = sum;",
            "                };",
            "    */",
            "public:",
            "    int n, q;",
            "    vector<array<int, 3>> qr;",
            "",
            "    mo_chan(int n, const vector<pair<int, int>> &queries) : n(n), q(queries.size()) ",
            "    {",
            "        for(int i = 0; i < q; i ++)",
            "        {",
            "            auto [l, r] = queries[i];",
            "            qr.push_back({l, r, i});",
            "        }",
            "",
            "        auto lmb1 = [&](array<int, 3> a, array<int, 3> b) -> bool",
            "        {",
            "            a[0] /= B, b[0] /= B;",
            "            return a < b;",
            "        };",
            "        auto lmb2 = [&](array<int, 3> a, array<int, 3> b) -> bool",
            "        {",
            "            a[0] /= B, b[0] /= B;",
            "            if(a[0] == b[0])",
            "            {",
            "                if(a[0] & 1)",
            "                    return a[1] > b[1];",
            "                else",
            "                    return b[1] > a[1];",
            "            }",
            "            return a[0] < b[0];",
            "        };",
            "        ",
            "        if(mode == 1)",
            "            sort(qr.begin(), qr.end(), lmb1);",
            "        else",
            "            sort(qr.begin(), qr.end(), lmb2);",
            "    };",
            "",
            "    void process(auto add, auto rem, auto query)",
            "    {",
            "        int l = 0, r = -1;",
            "        for(auto [nl, nr, qi] : qr)",
            "        {",
            "            while(l > nl)",
            "                add(-- l);",
            "            while(r < nr)",
            "                add(++ r);",
            "            while(l < nl)",
            "                rem(l ++);",
            "            while(r > nr)",
            "                rem(r --);",
            "            query(qi);",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet for mo (normal version)"
    },
    "template_sparse_table": {
        "prefix": "template_sparse_table",
        "body": [
            "template <typename T>",
            "class sparse_table_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<vector<T>> mat;",
            "    sparse_table_chan(const vector<T> &a)",
            "    {",
            "        n = a.size();",
            "        int max_log = 32 - __builtin_clz(n);",
            "        mat.resize(max_log);",
            "        mat[0] = a;",
            "        for (int j = 1; j < max_log; j++)",
            "        {",
            "            mat[j].resize(n - (1 << j) + 1);",
            "            for (int i = 0; i <= n - (1 << j); i++)",
            "                mat[j][i] = mat[j - 1][i].unite(mat[j - 1][i + (1 << (j - 1))]);",
            "        }",
            "    }",
            "    T query(int from, int to) const",
            "    {",
            "        assert(0 <= from && from <= to && to <= n - 1);",
            "        int lg = 32 - __builtin_clz(to - from + 1) - 1;",
            "        return mat[lg][from].unite(mat[lg][to - (1 << lg) + 1]);",
            "    }",
            "};"
        ],
        "description": "Snippet for sparse_table (normal version)"
    },
    "template_block_decomposition": {
        "prefix": "template_block_decomposition",
        "body": [
            "class element_chan",
            "{",
            "public:",
            "};",
            "class block_chan",
            "{",
            "public:",
            "};",
            "",
            "template<typename E, typename T, const int B>",
            "class block_decomposition_chan",
            "{",
            "    /*",
            "        info:",
            "            - 0 indexed",
            "            - E is the type of elements in the array",
            "            - T is the type of the blocks ",
            "            - B is the block size",
            "            - when passing in vector<E> (length = n) and vector<T>, make sure to have the size of vector<T> be at least ceil(n/B)",
            "            - for several queries, using process() will be rather awkward, so just implement your own external function  ",
            "    */",
            "public:",
            "    int ceil_div(int x, int y)",
            "    {",
            "        return (x + y - 1)/y;",
            "    }",
            "    int block_id(int i)",
            "    {",
            "        return i/B;",
            "    }",
            "    int lb(int bid)",
            "    {",
            "        return bid * B;",
            "    }",
            "    int rb(int bid)",
            "    {",
            "        return min(n, (bid + 1) * B - 1);",
            "    }",
            "",
            "public:",
            "    int n;",
            "    vector<E> element;",
            "    vector<T> block;",
            "",
            "    block_decomposition_chan(int n, vector<E> a, vector<T> b) : n(n), element(a), block(b)",
            "    {",
            "    };",
            "",
            "    void process(int l, int r, auto block_brute, auto block_quick)",
            "    {",
            "        assert(1 <= l and l <= r and r <= n);",
            "        int bl = block_id(l), br = block_id(r);",
            "        if(bl == br)",
            "            block_brute(l, r);",
            "        else",
            "        {",
            "            block_brute(l, rb(bl));",
            "            for(int b = bl + 1; b < br; b ++)",
            "                block_quick(b);",
            "            block_brute(lb(br), r);",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet for block_decomposition (normal version)"
    },
    "template_monoid_stack": {
        "prefix": "template_monoid_stack",
        "body": [
            "template<typename T>",
            "class monoid_stack_chan",
            "{",
            "public:",
            "    vector<pair<T, T>> stk;",
            "    int size()",
            "    {",
            "        return stk.size();",
            "    }",
            "",
            "    bool empty()",
            "    {",
            "        return stk.empty();",
            "    }",
            "",
            "    void push(T x)",
            "    {",
            "        stk.push_back({x, x.unite(sum())});",
            "    }",
            "",
            "    void pop()",
            "    {",
            "        assert(!stk.empty());",
            "        stk.pop_back();",
            "    }",
            "",
            "    T top()",
            "    {",
            "        assert(!stk.empty());",
            "        return stk.back().first;",
            "    }",
            "",
            "    T sum(int i = -1)",
            "    {",
            "        if(i == -1) ",
            "            i = size() - 1;",
            "        if(i == -1)",
            "            return T();",
            "        return stk[i].second;",
            "    }",
            "",
            "    void rswap(monoid_stack_chan &other)",
            "    {",
            "        swap(stk, other.stk);",
            "    }",
            "};"
        ],
        "description": "Snippet for monoid_stack (normal version)"
    },
    "template_monoid_deque": {
        "prefix": "template_monoid_deque",
        "body": [
            "template<template<typename> typename S, typename T>",
            "class monoid_deque_chan",
            "{",
            "public:",
            "    S<T> l, r, t;",
            "",
            "    int size()",
            "    {",
            "        return l.size() + r.size();",
            "    }",
            "    bool empty()",
            "    {",
            "        return (l.empty() and r.empty());",
            "    }",
            "",
            "    void rebalance()",
            "    {",
            "        bool f = false;",
            "",
            "        if(r.empty())",
            "            f = true, l.rswap(r);",
            "        ",
            "        int sz = r.size() / 2;",
            "        while(sz -- )",
            "            t.push(r.top()), r.pop();",
            "        while(!r.empty())",
            "            l.push(r.top()), r.pop();",
            "        while(!t.empty())",
            "            r.push(t.top()), t.pop();",
            "        ",
            "        if(f)",
            "            l.rswap(r);",
            "    }",
            "",
            "    void push_front(T x)",
            "    {",
            "        l.push(x);",
            "    }",
            "    void push_back(T x)",
            "    {",
            "        r.push(x);",
            "    }",
            "",
            "    void pop_front()",
            "    {",
            "        assert(!empty());",
            "        if(l.empty())",
            "            rebalance();",
            "        l.pop();",
            "    }",
            "    void pop_back()",
            "    {",
            "        assert(!empty());",
            "        if(r.empty())",
            "            rebalance();",
            "        r.pop();",
            "    }",
            "",
            "    T sum()",
            "    {",
            "        return l.sum().unite(r.sum());",
            "    }",
            "",
            "    T front()",
            "    {",
            "        assert(!empty());",
            "        if(l.empty())   ",
            "            rebalance();",
            "        return l.top();",
            "    }",
            "    ",
            "    T back()",
            "    {",
            "        assert(!empty());",
            "        if(r.empty())",
            "            return l.top(0);",
            "        return r.top();",
            "    }",
            "",
            "    void rswap(monoid_deque_chan &other)",
            "    {",
            "        l.rswap(other.l);",
            "        r.rswap(other.r);",
            "        t.rswap(other.t);",
            "    }",
            "};"
        ],
        "description": "Snippet for monoid_deque (normal version)"
    },
    "template_dsu": {
        "prefix": "template_dsu",
        "body": [
            "class dsu_chan",
            "{",
            "    /*",
            "        tc: ",
            "            O(n a(n)) amortized",
            "            O(n log(n)) for rollbackable",
            "",
            "        info:",
            "            par[u] stores leader of u",
            "            siz[u] stores size of component with leader u",
            "",
            "        modify:",
            "            to make rollbackable, we do not make modifications in get() [which makes the get() function O(log(N))] ",
            "            and store change info in unite()",
            "    */",
            "public:",
            "    int n;",
            "    vector<int> par;",
            "    vector<int> siz;",
            "    dsu_chan(int n) : n(n), par(n), siz(n, 1)",
            "    {",
            "        iota(par.begin(), par.end(), 0);",
            "    };",
            "    ",
            "    int get(int x)",
            "    {",
            "        return (par[x] == x ? x : par[x] = get(par[x]));",
            "    }",
            "",
            "    void unite(int x, int y)",
            "    {",
            "        x = get(x), y = get(y);",
            "        if(x == y)",
            "            return;",
            "        if(siz[x] > siz[y]) swap(x, y);",
            "        par[x] = y, siz[y] += siz[x];",
            "    }",
            "",
            "    vector<vector<int>> group()",
            "    {",
            "        vector<vector<int>> g(n);",
            "        for(int u = 0; u < n; u ++)",
            "            g[get(u)].push_back(u);",
            "        return g;",
            "    }",
            "};"
        ],
        "description": "Snippet for dsu (normal version)"
    },
    "template_fenwick_tree": {
        "prefix": "template_fenwick_tree",
        "body": [
            "class node_chan",
            "{",
            "public:",
            "    int v = 0;",
            "",
            "    inline void operator+=(node_chan &other)",
            "    {",
            "        v += other.v;",
            "    }",
            "    inline bool operator<(node_chan &other)",
            "    {",
            "        return v < other.v;",
            "    }",
            "};",
            "template <typename T>",
            "class fenwick_tree_chan",
            "{",
            "public:",
            "    vector<T> fenw;",
            "    int n;",
            "    int pw;",
            "",
            "    fenwick_tree_chan() : n(0) {}",
            "    fenwick_tree_chan(int n) : n(n)",
            "    {",
            "        fenw.resize(n);",
            "        pw = (n == 0 ? 0 : 1ULL << (63 - __builtin_clzll(unsigned(n))));",
            "    }",
            "",
            "    // a[x] += v;",
            "    void modify(int x, T v)",
            "    {",
            "        assert(0 <= x && x < n);",
            "        while (x < n)",
            "        {",
            "            fenw[x] += v;",
            "            x |= x + 1;",
            "        }",
            "    }",
            "",
            "    /// sum of prefix [0, .. x] ",
            "    T query(int x)",
            "    {",
            "        ++ x;",
            "        assert(0 <= x && x <= n);",
            "        T v{};",
            "        while (x > 0)",
            "        {",
            "            v += fenw[x - 1];",
            "            x &= x - 1;",
            "        }",
            "        return v;",
            "    }",
            "",
            "    // Returns the length of the longest prefix (0 indexed) with sum <= c",
            "    int max_prefix(T c)",
            "    {",
            "        T v{};",
            "        int at = 0;",
            "        for (int len = pw; len > 0; len >>= 1)",
            "        {",
            "            if (at + len <= n)",
            "            {",
            "                auto nv = v;",
            "                nv += fenw[at + len - 1];",
            "                if (!(c < nv))",
            "                {",
            "                    v = nv;",
            "                    at += len;",
            "                }",
            "            }",
            "        }",
            "        assert(0 <= at && at <= n);",
            "        return at;",
            "    }",
            "};"
        ],
        "description": "Snippet for fenwick_tree (normal version)"
    },
    "template_disjoint_sparse_table": {
        "prefix": "template_disjoint_sparse_table",
        "body": [
            "template <typename T>",
            "class disjoint_sparse_table_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<vector<T>> mat;",
            "",
            "    disjoint_sparse_table_chan(const vector<T> &a)",
            "    {",
            "        n = static_cast<int>(a.size());",
            "        mat.push_back(a);",
            "        for (int p = 1; (1 << p) < n; p++)",
            "        {",
            "            mat.emplace_back(n);",
            "            for (int mid = 1 << p; mid < n; mid += 1 << (p + 1))",
            "            {",
            "                mat[p][mid - 1] = a[mid - 1];",
            "                for (int j = mid - 2; j >= mid - (1 << p); j--)",
            "                    mat[p][j] = a[j].unite(mat[p][j + 1]);",
            "                mat[p][mid] = a[mid];",
            "                for (int j = mid + 1; j < min(n, mid + (1 << p)); j++)",
            "                    mat[p][j] = mat[p][j - 1].unite(a[j]);",
            "            }",
            "        }",
            "    }",
            "",
            "    T query(int l, int r) const",
            "    {",
            "        assert(0 <= l && l < r && r <= n);",
            "        if (r - l == 1)",
            "            return mat[0][l];",
            "        int p = bit_width(unsigned(l ^ (r - 1))) - 1;",
            "        return mat[p][l].unite(mat[p][r - 1]);",
            "    }",
            "};"
        ],
        "description": "Snippet for disjoint_sparse_table (normal version)"
    },
    "template_offline_deletion": {
        "prefix": "template_offline_deletion",
        "body": [
            "template<typename T, typename Q, typename D>",
            "class offline_deletion_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<Q> ans;",
            "    vector<vector<T>> store;",
            "    D ds;",
            "",
            "    offline_deletion_chan(int n) : ",
            "    n(n), ans(4 * n + 5), store(4 * n + 5) {};",
            "",
            "    //put(L, R, life) puts element \"life\" into segment [L, R]",
            "    void put(int L, int R, T life)",
            "    {",
            "        auto rec = [&](int v, int l, int r, auto &&rec) -> void",
            "        {",
            "            if(l > r or r < L or R < l)",
            "                return;",
            "",
            "            if(L <= l and r <= R)",
            "            {",
            "                store[v].push_back(life);",
            "                return;",
            "            }",
            "            ",
            "            int mid = (l + r)/2;",
            "            put(v * 2, l, mid, rec);",
            "            put(v * 2 + 1, mid + 1, r, rec);",
            "        };",
            "        rec(1, 1, n, rec);",
            "    }",
            "",
            "    void compute()",
            "    {",
            "        auto dfs = [&](int v, int l, int r, auto &&dfs) -> void",
            "        {",
            "            if(l > r)",
            "                return;",
            "",
            "            for(auto point : store[v])",
            "                ds.Insert(point);",
            "",
            "            if(l == r)",
            "                ans[l] = ds.Query();",
            "            else",
            "            {",
            "                int mid = (l + r)/2;",
            "                dfs(v * 2, l, mid, dfs);",
            "                dfs(v * 2 + 1, mid + 1, r, dfs);",
            "            }",
            "            ",
            "            for(auto point : store[v])",
            "                ds.Rollback();",
            "        };",
            "        dfs(1, 1, n, dfs);",
            "    }",
            "};"
        ],
        "description": "Snippet for offline_deletion (normal version)"
    },
    "template_cartesian_tree": {
        "prefix": "template_cartesian_tree",
        "body": [
            "template<typename T, typename C>",
            "vector<vector<int>> cartesian_tree(const vector<T> &p, C c = C())",
            "{",
            "    int n = p.size();",
            "",
            "    vector<int> l(n, -1);",
            "",
            "    vector<int> stk;",
            "    for(int i = n - 1; i >= 0; i --)",
            "    {",
            "        while(!stk.empty() and c(p[i], p[stk.back()]))",
            "            l[stk.back()] = i, stk.pop_back();",
            "        stk.push_back(i);",
            "    }",
            "    stk.clear();",
            "",
            "    vector<int> r(n, n);",
            "    for(int i = 0; i < n; i ++)",
            "    {",
            "        while(!stk.empty() and c(p[i], p[stk.back()]))",
            "            r[stk.back()] = i, stk.pop_back();",
            "        stk.push_back(i);",
            "    }",
            "    stk.clear();",
            "",
            "    vector<vector<int>> adj(n);",
            "    for(int i = 0; i < n; i ++)",
            "    {",
            "        int parent = -1;",
            "        if(l[i] != -1)",
            "            parent = l[i];",
            "        ",
            "        if(r[i] != -1)",
            "            if(parent == -1 or !c(p[parent], p[r[i]]))",
            "                parent = r[i];",
            "        ",
            "        if(parent != -1)",
            "            adj[parent].push_back(i);",
            "    }",
            "",
            "    return adj;",
            "}"
        ],
        "description": "Snippet for cartesian_tree (normal version)"
    },
    "template_krt": {
        "prefix": "template_krt",
        "body": [
            "class krt_chan",
            "{",
            "public:",
            "    int n;",
            "",
            "    vector<int> wg;",
            "    vector<vector<int>> krt;",
            "",
            "    krt_chan(int n, vector<array<int, 3>> edge, auto cmp) : n(n), wg(2 * n, -1), krt(2 * n)",
            "    {",
            "        int id = n;",
            "        vector<int> par(2 * n);",
            "        iota(par.begin(), par.end(), 0);",
            "",
            "        auto find = [&](int u, auto &&find) -> int",
            "        {",
            "            return (par[u] == u ? u : par[u] = find(par[u], find));",
            "        };",
            "        auto unite = [&](int u, int v, int w) -> void",
            "        {",
            "            u = find(u, find), v = find(v, find);",
            "            if(u == v)",
            "                return;",
            "            par[u] = par[v] = par[id] = id;",
            "            krt[id] = {u, v};",
            "            wg[id] = w;",
            "            id ++;",
            "        };",
            "",
            "        sort(edge.begin(), edge.end(), cmp);",
            "        for(auto [u, v, w] : edge)",
            "            unite(u, v, w);",
            "    };",
            "};"
        ],
        "description": "Snippet for krt (normal version)"
    },
    "template_monoid_queue": {
        "prefix": "template_monoid_queue",
        "body": [
            "template<template<typename> typename S, typename T>",
            "class monoid_queue_chan",
            "{",
            "public:",
            "    S<T> l, r;",
            "",
            "    int size()",
            "    {",
            "        return l.size() + r.size();",
            "    }",
            "",
            "    bool empty()",
            "    {",
            "        return (l.empty() and r.empty());",
            "    }",
            "",
            "    void rebalance()",
            "    {",
            "        while(!r.empty())",
            "            l.push(r.top()), r.pop();",
            "    }",
            "",
            "    void push(T x)",
            "    {",
            "        r.push(x);",
            "    }",
            "",
            "    void pop()",
            "    {",
            "        assert(!empty());",
            "        if(l.empty())   rebalance();",
            "        l.pop();",
            "    }",
            "",
            "    T sum()",
            "    {",
            "        return l.sum().unite(r.sum());",
            "    }",
            "",
            "    T front()",
            "    {",
            "        assert(!empty());",
            "        if(l.empty())   rebalance();",
            "        return l.top();",
            "    }",
            "    ",
            "    T back()",
            "    {",
            "        assert(!empty());",
            "        if(r.empty())",
            "            return l.top(0);",
            "        return r.top();",
            "    }",
            "};"
        ],
        "description": "Snippet for monoid_queue (normal version)"
    },
    "template_bitset": {
        "prefix": "template_bitset",
        "body": [
            "template<typename T, const int B>",
            "class bitset_chan",
            "{",
            "public:",
            "    using T_T = T;",
            "    static_assert(sizeof(T) * 8 == B, \"check block width\");",
            "    static_assert(std::is_same<T, uint64_t>::value, \"modify popcnt(), ctz(), clz()\");",
            "",
            "//static helper",
            "public:",
            "    static inline constexpr bool on(int i, T x) noexcept",
            "    {",
            "        return ((T(1) << i) & x) != 0;",
            "    }",
            "    static inline constexpr T prefix(int i) noexcept",
            "    {",
            "        return (i >= B) ? ~T(0) : ((T(1) << i) - T(1));",
            "    }",
            "    static inline constexpr T suffix(int i) noexcept",
            "    {",
            "        return ~prefix(B - i);",
            "    }",
            "    static inline constexpr T range(int l, int r) noexcept",
            "    {",
            "        return prefix(r) ^ prefix(l - 1);",
            "    }",
            "    static constexpr int popcnt(T x) noexcept",
            "    {",
            "        // return _mm_popcnt_u64(x);",
            "        return __builtin_popcountll(x);",
            "    }",
            "    static constexpr int clz(T x) noexcept",
            "    {",
            "        return __builtin_clzll(x);",
            "    }",
            "    static constexpr int ctz(T x) noexcept",
            "    {",
            "        return __builtin_ctzll(x);",
            "    }",
            "    static inline constexpr int block_id(int i) noexcept",
            "    {",
            "        return i / B;",
            "    }",
            " ",
            "//helper",
            "public:",
            "    inline T submask(int l, int r) const noexcept",
            "    {",
            "        int bx = block_id(l);",
            "        assert(bx == block_id(r));",
            "        return (b[bx] & range(l - bx * B + 1, r - bx * B + 1)); ",
            "    }",
            "    inline void trim() noexcept",
            "    {",
            "        b.back() &= prefix(n % B == 0 ? B : n % B);",
            "    }",
            " ",
            "//main",
            "public:",
            "    int n, m;",
            "    std::vector<T> b;",
            " ",
            "    bitset_chan(int n) : bitset_chan(n, false) {};",
            "    bitset_chan(int n, bool init) : n(n), m((n + B - 1)/B), b(m, init ? ~T(0) : T(0)) ",
            "    {",
            "        trim();",
            "    };",
            " ",
            "    inline void set(int i, bool val) noexcept",
            "    {",
            "        assert(0 <= i and i < n);",
            "        if(val)",
            "            b[i/B] |= (T(1) << (i % B));",
            "        else",
            "            b[i/B] &= ~(T(1) << (i % B));",
            "    }",
            " ",
            "    inline bool get(int i) const noexcept",
            "    {",
            "        assert(0 <= i and i < n);",
            "        return (b[i/B] & (T(1) << (i % B))) != 0;",
            "    }",
            " ",
            "    void reset() noexcept",
            "    {",
            "        std::fill(b.begin(), b.end(), T(0));",
            "    }",
            " ",
            "    //bitwise operations",
            "    void operator &= (const bitset_chan &other)",
            "    {",
            "        for(int i = 0; i < std::min(m, other.m); i ++)",
            "            b[i] &= other.b[i];",
            "        if(m > other.m)",
            "            std::fill(b.begin() + other.m, b.begin() + m, T(0));",
            "        // trim();",
            "    }",
            " ",
            "    void operator |= (const bitset_chan &other)",
            "    {",
            "        for(int i = 0; i < std::min(m, other.m); i ++)",
            "            b[i] |= other.b[i];",
            "        trim();",
            "    }",
            " ",
            "    void operator ^= (const bitset_chan &other)",
            "    {",
            "        for(int i = 0; i < std::min(m, other.m); i ++)",
            "            b[i] ^= other.b[i];",
            "        trim();",
            "    }",
            " ",
            "    void operator <<= (int x)",
            "    {",
            "        if(x == 0)",
            "            return;",
            " ",
            "        if(x >= n)",
            "        {",
            "            reset();",
            "            return;",
            "        }",
            " ",
            "        const int s = x/B, d = x % B, r = B - d;",
            " ",
            "        if(d > 0)",
            "        {",
            "            for(int i = m - 1 - s; i > 0; i --)",
            "                b[i + s] = (b[i] << d) | (b[i - 1] >> r);",
            "            b[s] = b[0] << d;",
            "        }",
            "        else",
            "        {",
            "            for(int i = m - 1 - s; i > 0; i --)",
            "                b[i + s] = b[i];",
            "            b[s] = b[0];",
            "        }",
            " ",
            "        std::fill(b.begin(), b.begin() + s, T(0));",
            " ",
            "        trim();",
            "    }",
            " ",
            "    void operator >>= (int x)",
            "    {",
            "        if(x == 0)",
            "            return;",
            "     ",
            "        if(x >= n)",
            "        {",
            "            reset();",
            "            return;",
            "        }",
            " ",
            "        const int s = x/B, d = x % B, l = B - d;",
            " ",
            "        if(d > 0)",
            "        {",
            "            for(int i = s; i < m - 1; i ++)",
            "                b[i - s] = (b[i] >> d) | (b[i + 1] << l); ",
            "            b[m - 1 - s] = b[m - 1] >> d;",
            "        }",
            "        else",
            "            for(int i = s; i < m; i ++)",
            "                b[i - s] = b[i];",
            " ",
            "        std::fill(b.begin() + m - s, b.end(), T(0));        ",
            " ",
            "        // trim();",
            "    }",
            " ",
            "    bool operator == (const bitset_chan &other)",
            "    {",
            "        return ((n == other.n) and b == other.b); ",
            "    }",
            " ",
            "    bool operator != (const bitset_chan &other)",
            "    {",
            "        return !(*this == other);",
            "    }",
            " ",
            "    //extended",
            "    bitset_chan operator & (const bitset_chan &other)",
            "    {",
            "        bitset_chan result(*this);",
            "        result &= other;",
            "        return result;",
            "    }",
            " ",
            "    bitset_chan operator | (const bitset_chan &other)",
            "    {",
            "        bitset_chan result(*this);",
            "        result |= other;",
            "        return result;",
            "    }",
            " ",
            "    bitset_chan operator ^ (const bitset_chan &other)",
            "    {",
            "        bitset_chan result(*this);",
            "        result ^= other;",
            "        return result;",
            "    }",
            " ",
            "    bitset_chan operator >> (int x)",
            "    {",
            "        bitset_chan result(*this);",
            "        result >>= x;",
            "        return result;",
            "    }",
            " ",
            "    bitset_chan operator << (int x)",
            "    {",
            "        bitset_chan result(*this);",
            "        result <<= x;",
            "        return result;",
            "    }",
            " ",
            "    bitset_chan operator ~()",
            "    {",
            "        bitset_chan result(*this);",
            "        for(auto &v : result)",
            "            v = ~v;",
            "        result.trim();",
            "        return result;",
            "    }",
            " ",
            "    //custom operations",
            "    int count() const noexcept",
            "    {",
            "        return std::accumulate(b.begin(), b.end(), 0, [](int sum, T value) { return sum + popcnt(value); });",
            "    }",
            "     ",
            "    int find_first()",
            "    {",
            "        int pos = -1;",
            "",
            "        for(int bi = 0; bi < m; bi ++)",
            "        {",
            "            if(b[bi] == T(0))",
            "                continue;",
            "            ",
            "            pos = ctz(b[bi]) + bi * B;",
            "            break;",
            "        }",
            "",
            "        return pos;",
            "    }",
            "",
            "    int find_last()",
            "    {",
            "        int pos = -1;",
            "",
            "        for(int bi = m - 1; bi >= 0; bi --)",
            "        {",
            "            if(b[bi] == T(0))",
            "                continue;",
            "            ",
            "            pos = B - clz(b[bi]) - 1 + bi * B;",
            "            break;",
            "        }",
            "",
            "        return pos;",
            "    }",
            "",
            "    void range_process(int l, int r, auto block_brute, auto block_quick)",
            "    {",
            "        assert(0 <= l and l <= r and r < n);",
            " ",
            "        int bl = block_id(l), br = block_id(r);",
            " ",
            "        if(bl == br)",
            "            block_brute(l, r);",
            "        else",
            "        {",
            "            block_brute(l, (bl + 1) * B - 1);",
            "            for(int bi = bl + 1; bi < br; bi ++)",
            "                block_quick(bi);",
            "            block_brute(br * B, r);",
            "        }",
            "    }",
            " ",
            "    void range_set(int l, int r, bool val)",
            "    {",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            int bi = block_id(l);",
            "            T mask = range(l - bi * B + 1, r - bi * B + 1);",
            "            if(val)",
            "                b[bi] |= mask;",
            "            else",
            "                b[bi] &= ~mask;",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            b[bi] = (val ? ~T(0) : T(0));",
            "        };",
            "        range_process(l, r, block_brute, block_quick);",
            "    }",
            " ",
            "    int count(int l, int r)",
            "    {",
            "        int cnt = 0;",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            cnt += popcnt(submask(l, r));",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            cnt += popcnt(b[bi]);",
            "        };",
            "        range_process(l, r, block_brute, block_quick);",
            "        return cnt;",
            "    }",
            " ",
            "    int find_first (int l, int r)",
            "    {",
            "        int pos = -1;",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            for(int i = l; i <= r and pos == -1; i ++)",
            "                if(get(i))",
            "                    pos = i;    ",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            if(b[bi] == T(0) or pos != -1)",
            "                return;",
            " ",
            "            pos = ctz(b[bi]) + bi * B;",
            "        };",
            " ",
            "        range_process(l, r, block_brute, block_quick);",
            "        return pos;",
            "    }",
            "    ",
            "    int find_last(int l, int r)",
            "    {",
            "        int pos = -1;",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            for(int i = l; i <= r; i ++)",
            "                if(get(i))",
            "                    pos = i;    ",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            if(b[bi] == T(0))",
            "                return;",
            " ",
            "            pos = B - clz(b[bi]) - 1 + bi * B;",
            "        };",
            " ",
            "        range_process(l, r, block_brute, block_quick);",
            "        return pos;",
            "    }",
            "",
            "    friend std::ostream &operator<<(std::ostream &os, const bitset_chan &bitset)",
            "    {",
            "        for (int i = bitset.m - 1; i >= 0; --i)",
            "            os << std::bitset<B>(bitset.b[i]);",
            "        os << '\\\\n';",
            "        return os;",
            "    }",
            "};",
            "",
            "using bitset_chan64 = bitset_chan<uint64_t, bit_width(uint64_t())>;"
        ],
        "description": "Snippet for bitset (normal version)"
    },
    "template_fast_segment_tree_lazy": {
        "prefix": "template_fast_segment_tree_lazy",
        "body": [
            "template <typename info, typename tag>",
            "class f_lazy_segment_tree_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<info> infos;",
            "    vector<tag> tags;",
            "    seg_tree::in_order_layout layout;",
            "",
            "    void apply(seg_tree::point a, const tag &t)",
            "    {",
            "        auto [l, r] = layout.get_node_bounds(a);",
            "        if (!t.apply_to(infos[a], l, r - 1))     //r - 1 to make inclusive",
            "        {",
            "            assert(a < n);",
            "            downdate_node(a);",
            "            apply(a.c(0), t);",
            "            apply(a.c(1), t);",
            "            update_node(a);",
            "            return;",
            "        }",
            "        if (a < n)",
            "        {",
            "            t.apply_to(tags[a]);",
            "        }",
            "    }",
            "",
            "    void downdate_node(seg_tree::point a)",
            "    {",
            "        if (!tags[a].empty())",
            "        {",
            "            apply(a.c(0), tags[a]);",
            "            apply(a.c(1), tags[a]);",
            "            tags[a] = tag();",
            "        }",
            "    }",
            "",
            "    void update_node(seg_tree::point a)",
            "    {",
            "        infos[a] = infos[a.c(0)].unite(infos[a.c(1)]);",
            "    }",
            "",
            "    f_lazy_segment_tree_chan() : f_lazy_segment_tree_chan(0) {}",
            "    f_lazy_segment_tree_chan(int n_) : f_lazy_segment_tree_chan(vector<info>(n_)) {}",
            "    f_lazy_segment_tree_chan(const vector<info> &a) : n(int(a.size()))",
            "    {",
            "        infos.resize(2 * n);",
            "        tags.resize(n);",
            "        layout = seg_tree::in_order_layout(n);",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            infos[layout.get_point(i)] = a[i];",
            "        }",
            "        for (int i = n - 1; i >= 1; i--)",
            "        {",
            "            update_node(seg_tree::point(i));",
            "        }",
            "    }",
            "",
            "    void modify(int l, int r, const tag &t)",
            "    {",
            "        ++ r;",
            "        auto rng = layout.get_range(l, r);",
            "        rng.for_parents_down([&](seg_tree::point a)",
            "                            { downdate_node(a); });",
            "        rng.for_each([&](seg_tree::point a)",
            "                     { apply(a, t); });",
            "        rng.for_parents_up([&](seg_tree::point a)",
            "                            { update_node(a); });",
            "    }",
            "",
            "    void set(int p, const info &v)",
            "    {",
            "        auto pt = layout.get_point(p);",
            "        pt.for_parents_down([&](seg_tree::point a)",
            "                            { downdate_node(a); });",
            "        infos[pt] = v;",
            "        pt.for_parents_up([&](seg_tree::point a)",
            "                          { update_node(a); });",
            "    }",
            "",
            "    info query(int l, int r)",
            "    {",
            "        ++ r;",
            "        auto rng = layout.get_range(l, r);",
            "        rng.for_parents_down([&](seg_tree::point a)",
            "                             { downdate_node(a); });",
            "        info res;",
            "        rng.for_each_l_to_r([&](seg_tree::point a)",
            "                            { res = res.unite(infos[a]); });",
            "        return res;",
            "    }",
            "",
            "    info get(int p)",
            "    {",
            "        auto pt = layout.get_point(p);",
            "        pt.for_parents_down([&](seg_tree::point a)",
            "                            { downdate_node(a); });",
            "        return infos[pt];",
            "    }",
            "",
            "    //returns max point r such that f(sum[l, r]) = true given that f is monotonic as r increases ",
            "    //if (r > n), then f(sum[l, n]) = true ",
            "    //if (r < l), then f(sum[l, l]) = false",
            "    template <typename F>",
            "    int max_right(int l, F f)",
            "    {",
            "        auto rng = layout.get_range(l, n);",
            "        rng.for_parents_down([&](seg_tree::point a) { downdate_node(a); });",
            "        ",
            "        int res = n;",
            "        info sum;",
            "        rng.for_each_l_to_r([&](seg_tree::point a)",
            "        {",
            "            if (res != n)",
            "            {",
            "                return;",
            "            }",
            "            auto new_sum = sum.unite(infos[a]);",
            "            if (f(new_sum)) ",
            "            {",
            "                sum = new_sum;",
            "                return;",
            "            }",
            "            while (a < n)",
            "            {",
            "                downdate_node(a);",
            "                new_sum = sum.unite(infos[a.c(0)]);",
            "                if (f(new_sum))",
            "                {",
            "                    sum = new_sum;",
            "                    a = a.c(1);",
            "                } ",
            "                else",
            "                {",
            "                    a = a.c(0);",
            "                }",
            "            }",
            "            res = layout.get_node_bounds(a)[0];",
            "        });",
            "        -- res;",
            "        return min(res, n);",
            "    }",
            "",
            "    //returns min point l such that f(sum[l, r]) = true given that f is monotonic as l decreases",
            "    //if (l == 0), then f(sum[0, n]) = true",
            "    //if (l > r), then f(sum[r, r]) = false",
            "    template <typename F>",
            "    int min_left(int r, F f)",
            "    {",
            "        ++ r;",
            "        auto rng = layout.get_range(0, r);",
            "        rng.for_parents_down([&](seg_tree::point a) { downdate_node(a); });",
            "        ",
            "        int res = 0;",
            "        info sum;",
            "        rng.for_each_r_to_l([&](seg_tree::point a)",
            "        {",
            "            if (res != 0) ",
            "            {",
            "                return;",
            "            }",
            "            auto new_sum = infos[a].unite(sum);",
            "            if (f(new_sum))",
            "            {",
            "                sum = new_sum;",
            "                return;",
            "            }",
            "            while (a < n)",
            "            {",
            "                downdate_node(a);",
            "                new_sum = infos[a.c(1)].unite(sum);",
            "                if (f(new_sum))",
            "                {",
            "                    sum = new_sum;",
            "                    a = a.c(0);",
            "                }",
            "                else",
            "                {",
            "                    a = a.c(1);",
            "                }",
            "            }",
            "            res = layout.get_node_bounds(a)[1];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for fast_segment_tree_lazy (normal version)"
    },
    "template_persistent_segment_tree_simple": {
        "prefix": "template_persistent_segment_tree_simple",
        "body": [
            "template <typename info, typename info_ptr>",
            "class p_segment_tree_chan",
            "{",
            "public:",
            "    int n, r, U;",
            "    map<int, int> roots;",
            "    vector<info> infos;",
            "    vector<info_ptr> info_ptrs;",
            "",
            "    template<typename O>",
            "    void recurse(int root, int lb, int rb, bool update, O op)",
            "    {",
            "        auto rec = [&](int v, int l, int r, auto &&rec) -> void",
            "        {",
            "            if(l > r or v == 0)",
            "                return;",
            "",
            "            if(lb <= l and r <= rb)",
            "            {",
            "                op(v, l, r);",
            "                return;",
            "            }",
            "",
            "            int m = (l + r)/2;",
            "",
            "            if(m >= lb)",
            "            {",
            "                if(update)",
            "                {",
            "                    int old_lc = info_ptrs[v].lc;",
            "                    info_ptrs[v].lc = ++ U;",
            "                    infos[info_ptrs[v].lc] = infos[old_lc];",
            "                    info_ptrs[info_ptrs[v].lc] = info_ptrs[old_lc];",
            "                }",
            "                rec(info_ptrs[v].lc, l, m, rec);",
            "            }",
            "            if(m + 1 <= rb)",
            "            {",
            "                if(update)",
            "                {",
            "                    int old_rc = info_ptrs[v].rc;",
            "                    info_ptrs[v].rc = ++ U;",
            "                    infos[info_ptrs[v].rc] = infos[old_rc]; ",
            "                    info_ptrs[info_ptrs[v].rc] = info_ptrs[old_rc];",
            "                }",
            "                rec(info_ptrs[v].rc, m + 1, r, rec);",
            "            }",
            "            ",
            "            if(update)",
            "                infos[v] = infos[info_ptrs[v].lc].unite(infos[info_ptrs[v].rc]);",
            "        };",
            "        rec(root, 0, n - 1, rec);",
            "    };",
            "",
            "    p_segment_tree_chan() : p_segment_tree_chan(0, 0) {};",
            "    p_segment_tree_chan(int n, int r) : p_segment_tree_chan(n, r, vector<info> (r)) {};",
            "    p_segment_tree_chan(int n, int r, const vector<info> &a) : ",
            "    n(n), r(r), infos(r + 1), info_ptrs(r + 1), U(0)",
            "    {",
            "        auto build = [&](int v, int l, int r, auto &&build) -> void",
            "        {",
            "            if(!v or l > r)",
            "                return;",
            "",
            "            if(l == r)",
            "            {",
            "                infos[v] = info(a[l]);",
            "                return;",
            "            }",
            "            int m = (l + r)/2;",
            "            if(l <= m)",
            "            {",
            "                info_ptrs[v].lc = ++ U;",
            "                build(info_ptrs[v].lc, l, m, build);",
            "            }",
            "            if(m + 1 <= r)",
            "            {",
            "                info_ptrs[v].rc = ++ U;",
            "                build(info_ptrs[v].rc, m + 1, r, build);",
            "            }",
            "            infos[v] = infos[info_ptrs[v].lc].unite(infos[info_ptrs[v].rc]);",
            "        };",
            "        int root = ++ U;",
            "        roots[0] = root;",
            "        build(U, 0, n - 1, build);",
            "    };",
            "",
            "    pair<int, int> resolve_roots (int new_root, int old_root)",
            "    {",
            "        auto it = roots.find(old_root);",
            "        assert(it != roots.end());",
            "        old_root = (*it).second;",
            "",
            "        assert(roots.find(new_root) == roots.end());",
            "        roots[new_root] = ++ U;",
            "        new_root = U;",
            "        infos[new_root] = infos[old_root];",
            "        info_ptrs[new_root] = info_ptrs[old_root];",
            "",
            "        return {new_root, old_root};",
            "    };",
            "",
            "    void set(int new_root, int old_root, int p, const info &infonode)",
            "    {",
            "        tie(new_root, old_root) = resolve_roots(new_root, old_root);",
            "",
            "        recurse(new_root, p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infonode;",
            "        });",
            "    }",
            "    void add(int new_root, int old_root, int p, const info &infonode)",
            "    {",
            "        tie(new_root, old_root) = resolve_roots(new_root, old_root);",
            "",
            "        recurse(new_root, p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infos[v].unite(infonode);",
            "        });",
            "    }",
            "    info query(int root, int lb, int rb)",
            "    {",
            "        auto it = roots.find(root);",
            "        assert(it != roots.end());",
            "        root = (*it).second;",
            "        info res = info();",
            "        recurse(root, lb, rb, false, [&](int v, int l, int r)",
            "        {",
            "            res = res.unite(infos[v]);",
            "        });",
            "        return res;",
            "    }",
            "    info get(int root, int p)",
            "    {",
            "        auto it = roots.find(root);",
            "        assert(it != roots.end());",
            "        root = (*it).second;",
            "        info res = info();",
            "        recurse(root, p, p, false, [&](int v, int l, int r)",
            "        {",
            "            res = infos[v];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for persistent_segment_tree_simple (normal version)"
    },
    "template_persistent_segment_tree_lazy": {
        "prefix": "template_persistent_segment_tree_lazy",
        "body": [
            "template <typename info, typename tag, typename info_ptr>",
            "class p_lazy_segment_tree_chan",
            "{",
            "public:",
            "    int n, r, U;",
            "    map<int, int> roots;",
            "    vector<info> infos;",
            "    vector<tag> tags;",
            "    vector<info_ptr> info_ptrs;",
            "",
            "    template<typename O>",
            "    void recurse(int root, int lb, int rb, bool update, O op)",
            "    {",
            "        auto rec = [&](int v, int l, int r, auto &&rec) -> void",
            "        {    ",
            "            if(l > r or v == 0)",
            "               return;",
            "            ",
            "            if(lb <= l and r <= rb)",
            "            {",
            "                propagate(v, l, r, update);",
            "                op(v, l, r);",
            "                return;",
            "            }",
            "",
            "            int m = (l + r)/2;",
            "",
            "            if(m >= lb)",
            "            {",
            "                if(update)",
            "                    info_ptrs[v].lc = make_node(info_ptrs[v].lc, true);",
            "                rec(info_ptrs[v].lc, l, m, rec);",
            "            }",
            "            else if(update)",
            "               propagate(info_ptrs[v].lc, l, m, update);",
            "",
            "            if(m + 1 <= rb)",
            "            {",
            "                if(update)",
            "                    info_ptrs[v].rc = make_node(info_ptrs[v].rc, true);",
            "                rec(info_ptrs[v].rc, m + 1, r, rec);",
            "            }",
            "            else if(update)",
            "               propagate(info_ptrs[v].rc, m + 1, r, update);",
            "            ",
            "            if(update)",
            "                infos[v] = infos[info_ptrs[v].lc].unite(infos[info_ptrs[v].rc]);",
            "        };",
            "        rec(root, 0, n - 1, rec);",
            "    };",
            "",
            "    p_lazy_segment_tree_chan() : p_lazy_segment_tree_chan(0) {};",
            "    p_lazy_segment_tree_chan(int n) : p_lazy_segment_tree_chan(n, vector<info> (n)) {};",
            "    p_lazy_segment_tree_chan(int n, const vector<info> &a) : ",
            "    n(n), r(4 * (n + 1) + 5), infos(r), tags(r), info_ptrs(r), U(0)",
            "    {",
            "        assert(n == a.size());",
            "        auto build = [&](int v, int l, int r, auto &&build) -> void",
            "        {",
            "            if(!v or l > r)",
            "                return;",
            "",
            "            if(l == r)",
            "            {",
            "                infos[v] = info(a[l]);",
            "                return;",
            "            }",
            "            int m = (l + r)/2;",
            "            if(l <= m)",
            "            {",
            "                info_ptrs[v].lc = ++ U;",
            "                build(info_ptrs[v].lc, l, m, build);",
            "            }",
            "            if(m + 1 <= r)",
            "            {",
            "                info_ptrs[v].rc = ++ U;",
            "                build(info_ptrs[v].rc, m + 1, r, build);",
            "            }",
            "            infos[v] = infos[info_ptrs[v].lc].unite(infos[info_ptrs[v].rc]);",
            "        };",
            "        int root = ++ U;",
            "        roots[0] = root;",
            "        build(U, 0, n - 1, build);",
            "    };",
            "",
            "    void propagate(int v, int l, int r, bool update)",
            "    {",
            "        if(!v or tags[v].empty())",
            "            return;",
            "        tags[v].apply_to(infos[v], l, r);",
            "        if(l != r)",
            "        {",
            "            if(info_ptrs[v].exp_create)",
            "            {",
            "                info_ptrs[v].exp_create = false;",
            "                info_ptrs[v].lc = make_node(info_ptrs[v].lc, true);",
            "                info_ptrs[v].rc = make_node(info_ptrs[v].rc, true);                ",
            "            }",
            "            tags[v].apply_to(tags[info_ptrs[v].lc]);",
            "            tags[v].apply_to(tags[info_ptrs[v].rc]);",
            "        }",
            "        tags[v] = tag();",
            "    }",
            "    int make_node (int old_node = 0, bool exp_create = false)",
            "    {",
            "        int new_node = ++ U;",
            "",
            "        if(U >= r)",
            "        {",
            "            r ++;",
            "            infos.resize(r);",
            "            info_ptrs.resize(r);",
            "            tags.resize(r);",
            "        }",
            "",
            "        infos[new_node] = infos[old_node];",
            "        info_ptrs[new_node] = info_ptrs[old_node];",
            "        info_ptrs[new_node].exp_create = exp_create;",
            "        tags[new_node] = tags[old_node];",
            "        return new_node;",
            "    }",
            "",
            "    pair<int, int> resolve_roots (int new_root, int old_root)",
            "    {",
            "        auto it = roots.find(old_root);",
            "        assert(it != roots.end());",
            "        old_root = (*it).second;",
            "",
            "        assert(roots.find(new_root) == roots.end());",
            "        int storev = new_root;",
            "        new_root = make_node(old_root, true);",
            "        roots[storev] = new_root;",
            "",
            "        return {new_root, old_root};",
            "    };",
            "",
            "    void modify(int new_root, int old_root, int lb, int rb, const tag &tagnode)",
            "    {",
            "        tie(new_root, old_root) = resolve_roots(new_root, old_root);",
            "        recurse(new_root, lb, rb, true, [&](int v, int l, int r)",
            "        {",
            "            tagnode.apply_to(tags[v]);",
            "            propagate(v, l, r, true);",
            "        });",
            "    }",
            "    void set(int new_root, int old_root, int p, const info &infonode)",
            "    {",
            "        tie(new_root, old_root) = resolve_roots(new_root, old_root);",
            "",
            "        recurse(new_root, p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infonode;",
            "        });",
            "    }",
            "    void add(int new_root, int old_root, int p, const info &infonode)",
            "    {",
            "        tie(new_root, old_root) = resolve_roots(new_root, old_root);",
            "",
            "        recurse(new_root, p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infos[v].unite(infonode);",
            "            propagate(v, l, r, true);",
            "        });",
            "    }",
            "    ",
            "    info query(int root, int lb, int rb)",
            "    {",
            "        auto it = roots.find(root);",
            "        assert(it != roots.end());",
            "        root = (*it).second;",
            "        info res = info();",
            "        recurse(root, lb, rb, false, [&](int v, int l, int r)",
            "        {",
            "            res = res.unite(infos[v]);",
            "        });",
            "        return res;",
            "    }",
            "    info get(int root, int p)",
            "    {",
            "        auto it = roots.find(root);",
            "        assert(it != roots.end());",
            "        root = (*it).second;",
            "        info res = info();",
            "        recurse(root, p, p, false, [&](int v, int l, int r)",
            "        {",
            "            res = infos[v];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for persistent_segment_tree_lazy (normal version)"
    },
    "template_monoid_tag": {
        "prefix": "template_monoid_tag",
        "body": [
            "class tag_chan",
            "{",
            "public:",
            "    int add = 0;",
            "",
            "    tag_chan() : add(0) {};",
            "    tag_chan(int x) : add(x) {};",
            "",
            "    bool apply_to(monoid_chan &a, [[maybe_unused]] int l, [[maybe_unused]] int r) const",
            "    {",
            "        a.sum += add * (r - l + 1);",
            "        return true;",
            "    }",
            "    void apply_to(tag_chan &t) const",
            "    {",
            "        t.add += add;",
            "    }",
            "    bool empty() const",
            "    {",
            "        return add == 0;",
            "    }",
            "};"
        ],
        "description": "Snippet for monoid_tag (normal version)"
    },
    "template_persistent_monoid_pointer": {
        "prefix": "template_persistent_monoid_pointer",
        "body": [
            "class p_node_pointer_chan",
            "{",
            "public:",
            "    int lc, rc;",
            "    bool exp_create;",
            "",
            "    p_node_pointer_chan() : lc(0), rc(0), exp_create(false) {};",
            "    p_node_pointer_chan(int l, int r) : lc(l), rc(r) {};",
            "};"
        ],
        "description": "Snippet for persistent_monoid_pointer (normal version)"
    },
    "template_recursive_segment_tree_simple": {
        "prefix": "template_recursive_segment_tree_simple",
        "body": [
            "template <typename info>",
            "class r_segment_tree_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<info> infos;",
            "",
            "    template<typename O>",
            "    void recurse(int lb, int rb, bool update, O op)",
            "    {",
            "        auto rec = [&](int v, int l, int r, auto &&rec) -> void",
            "        {",
            "            if(l > r)",
            "                return;",
            "            ",
            "            if(lb <= l and r <= rb)",
            "            {",
            "                op(v, l, r);",
            "                return;",
            "            }",
            "            ",
            "            int m = (l + r)/2;",
            "            ",
            "            if(m >= lb)",
            "                rec(2 * v, l, m, rec);",
            "            if(m + 1 <= rb)",
            "                rec(2 * v + 1, m + 1, r, rec);",
            "            ",
            "            if(update)",
            "                infos[v] = infos[2 * v].unite(infos[2 * v + 1]);",
            "        };",
            "        rec(1, 0, n - 1, rec);",
            "    };",
            "",
            "    r_segment_tree_chan() : r_segment_tree_chan(0) {};",
            "    r_segment_tree_chan(int n) : r_segment_tree_chan(vector<info> (n)) {};",
            "    r_segment_tree_chan(const vector<info> &a) : ",
            "    n((int)a.size()), infos(4 * n + 5)",
            "    {",
            "        auto build = [&](int v, int l, int r, auto &&build) -> void",
            "        {",
            "            if(l > r)",
            "                return;",
            "            if(l == r)",
            "            {",
            "                infos[v] = info(a[l]);",
            "                return;",
            "            }",
            "            int m = (l + r)/2;",
            "            build(v * 2, l, m, build);",
            "            build(v * 2 + 1, m + 1, r, build);",
            "            infos[v] = infos[v * 2].unite(infos[v * 2 + 1]);",
            "        };",
            "        build(1, 0, n - 1, build);",
            "    };",
            "",
            "    void set(int p, const info &infonode)",
            "    {",
            "        recurse(p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infonode;",
            "        });",
            "    }",
            "    void add(int p, const info &infonode)",
            "    {",
            "        recurse(p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infos[v].unite(infonode);",
            "        });",
            "    }",
            "    info query(int lb, int rb)",
            "    {",
            "        info res = info();",
            "        recurse(lb, rb, false, [&](int v, int l, int r)",
            "        {",
            "            res = res.unite(infos[v]);",
            "        });",
            "        return res;",
            "    }",
            "    info get(int p)",
            "    {",
            "        info res = info();",
            "        recurse(p, p, false, [&](int v, int l, int r)",
            "        {",
            "            res = infos[v];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for recursive_segment_tree_simple (normal version)"
    },
    "template_recursive_segment_tree_lazy": {
        "prefix": "template_recursive_segment_tree_lazy",
        "body": [
            "template <typename info, typename tag>",
            "class r_lazy_segment_tree_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<info> infos;",
            "    vector<tag> tags;",
            "",
            "    template<typename O>",
            "    void recurse(int lb, int rb, bool update, O op)",
            "    {",
            "        auto rec = [&](int v, int l, int r, auto &&rec) -> void",
            "        {",
            "            propagate(v, l, r);",
            "",
            "            if(l > r)",
            "                return;",
            "            ",
            "            if(lb <= l and r <= rb)",
            "            {",
            "                op(v, l, r);",
            "                return;",
            "            }",
            "            ",
            "            int m = (l + r)/2;",
            "            ",
            "            if(m >= lb)",
            "                rec(2 * v, l, m, rec);",
            "            else if(update)",
            "                propagate(2 * v, l, m);",
            "",
            "            if(m + 1 <= rb)",
            "                rec(2 * v + 1, m + 1, r, rec);",
            "            else if(update)",
            "                propagate(2 * v + 1, m + 1, r);",
            "            ",
            "            if(update)",
            "                infos[v] = infos[2 * v].unite(infos[2 * v + 1]);",
            "        };",
            "        rec(1, 0, n - 1, rec);",
            "    };",
            "",
            "    r_lazy_segment_tree_chan() : r_lazy_segment_tree_chan(0) {};",
            "    r_lazy_segment_tree_chan(int n) : r_lazy_segment_tree_chan(vector<info> (n)) {};",
            "    r_lazy_segment_tree_chan(const vector<info> &a) : ",
            "    n((int)a.size()), infos(4 * n + 5), tags(4 * n + 5)",
            "    {",
            "        auto build = [&](int v, int l, int r, auto &&build) -> void",
            "        {",
            "            if(l > r)",
            "                return;",
            "            if(l == r)",
            "            {",
            "                infos[v] = info(a[l]);",
            "                return;",
            "            }",
            "            int m = (l + r)/2;",
            "            build(v * 2, l, m, build);",
            "            build(v * 2 + 1, m + 1, r, build);",
            "            infos[v] = infos[v * 2].unite(infos[v * 2 + 1]);",
            "        };",
            "        build(1, 0, n - 1, build);",
            "    };",
            "",
            "    void propagate(int v, int l, int r)",
            "    {",
            "        if(tags[v].empty())",
            "            return;",
            "        tags[v].apply_to(infos[v], l, r);",
            "        if(l != r)",
            "        {",
            "            tags[v].apply_to(tags[2 * v]);",
            "            tags[v].apply_to(tags[2 * v  + 1]);",
            "        }",
            "        tags[v] = tag();",
            "    }",
            "",
            "    void modify(int lb, int rb, const tag &tagnode)",
            "    {",
            "        recurse(lb, rb, true, [&](int v, int l, int r)",
            "        {",
            "            tagnode.apply_to(tags[v]);",
            "            propagate(v, l, r);",
            "        });",
            "    }",
            "    void set(int p, const info &info)",
            "    {",
            "        recurse(p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = info;",
            "        });",
            "    }",
            "    void add(int p, const info &info)",
            "    {",
            "        recurse(p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infos[v].unite(info);",
            "            propagate(v, l, r);",
            "        });",
            "    }",
            "    info query(int lb, int rb)",
            "    {",
            "        info res = info();",
            "        recurse(lb, rb, false, [&](int v, int l, int r)",
            "        {",
            "            res = res.unite(infos[v]);",
            "        });",
            "        return res;",
            "    }",
            "    info get(int p)",
            "    {",
            "        info res = info();",
            "        recurse(p, p, false, [&](int v, int l, int r)",
            "        {",
            "            res = infos[v];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for recursive_segment_tree_lazy (normal version)"
    },
    "template_fast_segment_tree_layout": {
        "prefix": "template_fast_segment_tree_layout",
        "body": [
            "namespace seg_tree",
            "{",
            "    // Floor of log_2(a); index of highest 1-bit",
            "    inline int floor_log_2(int a)",
            "    {",
            "        return a ? bit_width(unsigned(a)) - 1 : -1;",
            "    }",
            "",
            "    class point",
            "    {",
            "    public:",
            "        int a;",
            "        point() : a(0) {}",
            "        explicit point(int a_) : a(a_) { assert(a >= -1); }",
            "",
            "        explicit operator bool() { return bool(a); }",
            "",
            "        // This is useful so you can directly do array indices",
            "        /* implicit */ operator int() const { return a; }",
            "",
            "        point c(bool z) const",
            "        {",
            "            return point((a << 1) | z);",
            "        }",
            "",
            "        point operator[](bool z) const",
            "        {",
            "            return c(z);",
            "        }",
            "",
            "        point p() const",
            "        {",
            "            return point(a >> 1);",
            "        }",
            "",
            "        friend std::ostream &operator<<(std::ostream &o, const point &p) { return o << int(p); }",
            "",
            "        template <typename F>",
            "        void for_each(F f) const",
            "        {",
            "            for (int v = a; v > 0; v >>= 1)",
            "            {",
            "                f(point(v));",
            "            }",
            "        }",
            "",
            "        template <typename F>",
            "        void for_parents_down(F f) const",
            "        {",
            "            // strictly greater than 0",
            "            for (int L = floor_log_2(a); L > 0; L--)",
            "            {",
            "                f(point(a >> L));",
            "            }",
            "        }",
            "",
            "        template <typename F>",
            "        void for_parents_up(F f) const",
            "        {",
            "            for (int v = a >> 1; v > 0; v >>= 1)",
            "            {",
            "                f(point(v));",
            "            }",
            "        }",
            "",
            "        point &operator++()",
            "        {",
            "            ++a;",
            "            return *this;",
            "        }",
            "        point operator++(int) { return point(a++); }",
            "        point &operator--()",
            "        {",
            "            --a;",
            "            return *this;",
            "        }",
            "        point operator--(int) { return point(a--); }",
            "    };",
            "",
            "    class range",
            "    {",
            "    public:",
            "        int a, b;",
            "        range() : a(1), b(1) {}",
            "        range(int a_, int b_) : a(a_), b(b_)",
            "        {",
            "            assert(1 <= a && a <= b && b <= 2 * a);",
            "        }",
            "        explicit range(std::array<int, 2> r) : range(r[0], r[1]) {}",
            "",
            "        explicit operator std::array<int, 2>() const",
            "        {",
            "            return {a, b};",
            "        }",
            "",
            "        const int &operator[](bool z) const",
            "        {",
            "            return z ? b : a;",
            "        }",
            "",
            "        friend std::ostream &operator<<(std::ostream &o, const range &r) { return o << \"[\" << r.a << \"..\" << r.b << \")\"; }",
            "",
            "        // Iterate over the range from outside-in.",
            "        //   Calls f(point a)",
            "        template <typename F>",
            "        void for_each(F f) const",
            "        {",
            "            for (int x = a, y = b; x < y; x >>= 1, y >>= 1)",
            "            {",
            "                if (x & 1)",
            "                    f(point(x++));",
            "                if (y & 1)",
            "                    f(point(--y));",
            "            }",
            "        }",
            "",
            "        // Iterate over the range from outside-in.",
            "        //   Calls f(point a, bool is_right)",
            "        template <typename F>",
            "        void for_each_with_side(F f) const",
            "        {",
            "            for (int x = a, y = b; x < y; x >>= 1, y >>= 1)",
            "            {",
            "                if (x & 1)",
            "                    f(point(x++), false);",
            "                if (y & 1)",
            "                    f(point(--y), true);",
            "            }",
            "        }",
            "",
            "        // Iterate over the range from left to right.",
            "        //    Calls f(point)",
            "        template <typename F>",
            "        void for_each_l_to_r(F f) const",
            "        {",
            "            int anc_depth = floor_log_2((a - 1) ^ b);",
            "            int anc_msk = (1 << anc_depth) - 1;",
            "            for (int v = (-a) & anc_msk; v; v &= v - 1)",
            "            {",
            "                int i = countr_zero(unsigned(v));",
            "                f(point(((a - 1) >> i) + 1));",
            "            }",
            "            for (int v = b & anc_msk; v;)",
            "            {",
            "                int i = floor_log_2(v);",
            "                f(point((b >> i) - 1));",
            "                v ^= (1 << i);",
            "            }",
            "        }",
            "",
            "        // Iterate over the range from right to left.",
            "        //    Calls f(point)",
            "        template <typename F>",
            "        void for_each_r_to_l(F f) const",
            "        {",
            "            int anc_depth = floor_log_2((a - 1) ^ b);",
            "            int anc_msk = (1 << anc_depth) - 1;",
            "            for (int v = b & anc_msk; v; v &= v - 1)",
            "            {",
            "                int i = countr_zero(unsigned(v));",
            "                f(point((b >> i) - 1));",
            "            }",
            "            for (int v = (-a) & anc_msk; v;)",
            "            {",
            "                int i = floor_log_2(v);",
            "                f(point(((a - 1) >> i) + 1));",
            "                v ^= (1 << i);",
            "            }",
            "        }",
            "",
            "        template <typename F>",
            "        void for_parents_down(F f) const",
            "        {",
            "            int x = a, y = b;",
            "            if ((x ^ y) > x)",
            "            {",
            "                x <<= 1, std::swap(x, y);",
            "            }",
            "            int dx = countr_zero(unsigned(x));",
            "            int dy = countr_zero(unsigned(y));",
            "            int anc_depth = floor_log_2((x - 1) ^ y);",
            "            for (int i = floor_log_2(x); i > dx; i--)",
            "            {",
            "                f(point(x >> i));",
            "            }",
            "            for (int i = anc_depth; i > dy; i--)",
            "            {",
            "                f(point(y >> i));",
            "            }",
            "        }",
            "",
            "        template <typename F>",
            "        void for_parents_up(F f) const",
            "        {",
            "            int x = a, y = b;",
            "            if ((x ^ y) > x)",
            "            {",
            "                x <<= 1, std::swap(x, y);",
            "            }",
            "            int dx = countr_zero(unsigned(x));",
            "            int dy = countr_zero(unsigned(y));",
            "            int anc_depth = floor_log_2((x - 1) ^ y);",
            "            for (int i = dx + 1; i <= anc_depth; i++)",
            "            {",
            "                f(point(x >> i));",
            "            }",
            "            for (int v = y >> (dy + 1); v; v >>= 1)",
            "            {",
            "                f(point(v));",
            "            }",
            "        }",
            "    };",
            "",
            "    class in_order_layout",
            "    {",
            "    public:",
            "        // Alias them in for convenience",
            "        using point = seg_tree::point;",
            "        using range = seg_tree::range;",
            "",
            "        int n, s;",
            "        in_order_layout() : n(0), s(0) {}",
            "        in_order_layout(int n_) : n(n_), s(n ? bit_ceil(unsigned(n)) : 0) {}",
            "",
            "        point get_point(int a) const",
            "        {",
            "            assert(0 <= a && a < n);",
            "            a += s;",
            "            return point(a >= 2 * n ? a - n : a);",
            "        }",
            "",
            "        range get_range(int a, int b) const",
            "        {",
            "            assert(0 <= a && a <= b && b <= n);",
            "            if (n == 0)",
            "                return range();",
            "            a += s, b += s;",
            "            return range((a >= 2 * n ? 2 * (a - n) : a), (b >= 2 * n ? 2 * (b - n) : b));",
            "        }",
            "",
            "        range get_range(std::array<int, 2> p) const",
            "        {",
            "            return get_range(p[0], p[1]);",
            "        }",
            "",
            "        int get_leaf_index(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(n <= a && a < 2 * n);",
            "            return (a < s ? a + n : a) - s;",
            "        }",
            "",
            "        std::array<int, 2> get_node_bounds(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(1 <= a && a < 2 * n);",
            "            int l = countl_zero(unsigned(a)) - countl_zero(unsigned(2 * n - 1));",
            "            int x = a << l, y = (a + 1) << l;",
            "            assert(s <= x && x < y && y <= 2 * s);",
            "            return {(x >= 2 * n ? (x >> 1) + n : x) - s, (y >= 2 * n ? (y >> 1) + n : y) - s};",
            "        }",
            "",
            "        int get_node_split(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(1 <= a && a < n);",
            "            int l = countl_zero(unsigned(2 * a + 1)) - countl_zero(unsigned(2 * n - 1));",
            "            int x = (2 * a + 1) << l;",
            "            assert(s <= x && x < 2 * s);",
            "            return (x >= 2 * n ? (x >> 1) + n : x) - s;",
            "        }",
            "",
            "        int get_node_size(point pt) const",
            "        {",
            "            auto bounds = get_node_bounds(pt);",
            "            return bounds[1] - bounds[0];",
            "        }",
            "    };",
            "",
            "    class circular_layout",
            "    {",
            "    public:",
            "        // Alias them in for convenience",
            "        using point = seg_tree::point;",
            "        using range = seg_tree::range;",
            "",
            "        int n;",
            "        circular_layout() : n(0) {}",
            "        circular_layout(int n_) : n(n_) {}",
            "",
            "        point get_point(int a) const",
            "        {",
            "            assert(0 <= a && a < n);",
            "            return point(n + a);",
            "        }",
            "",
            "        range get_range(int a, int b) const",
            "        {",
            "            assert(0 <= a && a <= b && b <= n);",
            "            if (n == 0)",
            "                return range();",
            "            return range(n + a, n + b);",
            "        }",
            "",
            "        range get_range(std::array<int, 2> p) const",
            "        {",
            "            return get_range(p[0], p[1]);",
            "        }",
            "",
            "        int get_leaf_index(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(n <= a && a < 2 * n);",
            "            return a - n;",
            "        }",
            "",
            "        // Returns {x,y} so that 0 <= x < n and 1 <= y <= n",
            "        // If the point is non-wrapping, then 0 <= x < y <= n",
            "        std::array<int, 2> get_node_bounds(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(1 <= a && a < 2 * n);",
            "            int l = countl_zero(unsigned(a)) - countl_zero(unsigned(2 * n - 1));",
            "            int s = bit_ceil(unsigned(n));",
            "            int x = a << l, y = (a + 1) << l;",
            "            assert(s <= x && x < y && y <= 2 * s);",
            "            return {(x >= 2 * n ? x >> 1 : x) - n, (y > 2 * n ? y >> 1 : y) - n};",
            "        }",
            "",
            "        // Returns the split point of the node, such that 1 <= s <= n.",
            "        int get_node_split(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(1 <= a && a < n);",
            "            return get_node_bounds(pt.c(0))[1];",
            "        }",
            "",
            "        int get_node_size(point pt) const",
            "        {",
            "            auto bounds = get_node_bounds(pt);",
            "            int r = bounds[1] - bounds[0];",
            "            return r > 0 ? r : r + n;",
            "        }",
            "    };",
            "}"
        ],
        "description": "Snippet for fast_segment_tree_layout (normal version)"
    },
    "template_fast_segment_tree_simple": {
        "prefix": "template_fast_segment_tree_simple",
        "body": [
            "template <typename info>",
            "class f_segment_tree_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<info> infos;",
            "    seg_tree::in_order_layout layout;",
            "",
            "    void update_node(seg_tree::point a)",
            "    {",
            "        infos[a] = infos[a.c(0)].unite(infos[a.c(1)]);",
            "    }",
            "",
            "    f_segment_tree_chan(int n_) : f_segment_tree_chan(vector<info>(n_)) {}",
            "",
            "    f_segment_tree_chan(const vector<info> &a) : n(int(a.size()))",
            "    {",
            "        assert(n > 0);",
            "        infos.resize(2 * n);",
            "        layout = seg_tree::in_order_layout(n);",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            infos[layout.get_point(i)] = a[i];",
            "        }",
            "        for (int i = n - 1; i >= 1; i--)",
            "        {",
            "            infos[i] = infos[2 * i].unite(infos[2 * i + 1]);",
            "        }",
            "    }",
            "",
            "    void set(int p, const info &v)",
            "    {",
            "        auto pt = layout.get_point(p);",
            "        infos[pt] = v;",
            "        pt.for_parents_up([&](seg_tree::point a)",
            "                          { update_node(a); });",
            "    }",
            "",
            "    info query(int l, int r)",
            "    {",
            "        ++ r;",
            "        auto rng = layout.get_range(l, r);",
            "        info res;",
            "        rng.for_each_l_to_r([&](seg_tree::point a)",
            "                            { res = res.unite(infos[a]); });",
            "        return res;",
            "    }",
            "",
            "    info get(int p)",
            "    {",
            "        auto pt = layout.get_point(p);",
            "        return infos[pt];",
            "    }",
            "",
            "    //returns max `r` such that `f(sum[l, r]) = true` given that `f` is monotonic as `r` increases ",
            "    //if `(r > n)`, then `f(sum[l, n]) = true` ",
            "    //if `(r < l)`, then `f(sum[l, l]) = false`",
            "    template <typename F>",
            "    int max_right(int l, F f)",
            "    {",
            "        auto rng = layout.get_range(l, n);",
            "        int res = n;",
            "        info sum;",
            "        rng.for_each_l_to_r([&](seg_tree::point a)",
            "        {",
            "            if (res != n) ",
            "            {",
            "                return;",
            "            }",
            "            auto new_sum = sum.unite(infos[a]);",
            "            if (f(new_sum))",
            "            {",
            "                sum = new_sum;",
            "                return;",
            "            }",
            "            while (a < n) ",
            "            {",
            "                new_sum = sum.unite(infos[a.c(0)]);",
            "                if (f(new_sum)) ",
            "                {",
            "                    sum = new_sum;",
            "                    a = a.c(1);",
            "                }",
            "                else",
            "                {",
            "                    a = a.c(0);",
            "                }",
            "            }",
            "            res = layout.get_node_bounds(a)[0];",
            "        });",
            "        -- res;",
            "        return min(n, res);",
            "    }",
            "",
            "    //returns min point l such that f(sum[l, r]) = true given that f is monotonic as l decreases",
            "    //if (l == 0), then f(sum[0, n]) = true",
            "    //if (l > r), then f(sum[r, r]) = false",
            "    template <typename F>",
            "    int min_left(int r, F f)",
            "    {",
            "        ++ r;",
            "        auto rng = layout.get_range(0, r);",
            "        int res = 0;",
            "        info sum;",
            "        rng.for_each_r_to_l([&](seg_tree::point a)",
            "        {",
            "            if (res != 0) ",
            "            {",
            "                return;",
            "            }",
            "            ",
            "            auto new_sum = infos[a].unite(sum);",
            "            if (f(new_sum))",
            "            {",
            "                sum = new_sum;",
            "                return;",
            "            }",
            "            while (a < n)",
            "            {",
            "                new_sum = infos[a.c(1)].unite(sum);",
            "                if (f(new_sum)) ",
            "                {",
            "                    sum = new_sum;",
            "                    a = a.c(0);",
            "                }",
            "                else",
            "                {",
            "                    a = a.c(1);",
            "                }",
            "            }",
            "            res = layout.get_node_bounds(a)[1];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for fast_segment_tree_simple (normal version)"
    },
    "template_monoid": {
        "prefix": "template_monoid",
        "body": [
            "class monoid_chan",
            "{",
            "public:",
            "    int sum = 0;",
            "",
            "    monoid_chan() : sum(0) {};",
            "    monoid_chan(int x) : sum(x) {};",
            "",
            "    monoid_chan unite(monoid_chan b) const ",
            "    {",
            "        monoid_chan res(sum + b.sum);",
            "        return res;",
            "    }",
            "    static monoid_chan get_default([[maybe_unused]] int l, [[maybe_unused]] int r)",
            "    {",
            "        return monoid_chan();",
            "    }",
            "};"
        ],
        "description": "Snippet for monoid (normal version)"
    },
    "template_dynamic_monoid": {
        "prefix": "template_dynamic_monoid",
        "body": [
            "class dynamic_monoid_chan",
            "{",
            "public:",
            "    dynamic_monoid_chan *left, *right;",
            "    int sum = 0;",
            "",
            "    dynamic_monoid_chan() : sum(0) {};",
            "    dynamic_monoid_chan(int x) : sum(x) {};",
            "",
            "    dynamic_monoid_chan unite(dynamic_monoid_chan b) const ",
            "    {",
            "        dynamic_monoid_chan res(sum + b.sum);",
            "        return res;",
            "    }",
            "    static dynamic_monoid_chan get_default([[maybe_unused]] int l, [[maybe_unused]] int r)",
            "    {",
            "        return dynamic_monoid_chan();",
            "    }",
            "",
            "    dynamic_monoid_chan grow()",
            "    {",
            "        if(left == nullptr)",
            "        {",
            "            left = new dynamic_monoid_chan();",
            "            right = new dynamic_monoid_chan();",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet for dynamic_monoid (normal version)"
    },
    "template_splay": {
        "prefix": "template_splay",
        "body": [
            "/*",
            "general ideas:",
            "- Can do a dfs to an arbitrary node in O(log(n)) time, if you always splay it afterwards",
            "- For single node modifications, we generally splay the node first and then do what we want",
            "- BST property is maintained throughout (key can be redundant a lot of times)",
            "*/",
            "",
            "namespace splay_chan",
            "{",
            "    //common: push, splay, pull",
            "    bool is_root(node* u)",
            "    {",
            "        if(u == nullptr)",
            "            return false;",
            "        return (u->p == nullptr);",
            "    }",
            "",
            "    void rotate(node* u)",
            "    {",
            "        auto p = u->p;",
            "        assert(p != nullptr);",
            "",
            "        p->push();",
            "        u->push();",
            "",
            "        u->p = p->p;",
            "        p->p = u;",
            "",
            "        if(u->p != nullptr)",
            "        {",
            "            if(u->p->l == p)",
            "                u->p->l = u;",
            "            if(u->p->r == p)",
            "                u->p->r = u;",
            "        }",
            "",
            "        if(u == p->l)",
            "        {",
            "            p->l = u->r;",
            "            if(u->r != nullptr)",
            "                u->r->p = p;",
            "            u->r = p;",
            "        }",
            "        else",
            "        {",
            "            p->r = u->l;",
            "            if(u->l != nullptr)",
            "                u->l->p = p;",
            "            u->l = p;",
            "        }",
            "",
            "        p->pull();",
            "        u->pull();",
            "    }",
            "",
            "    void splay(node *u)",
            "    {",
            "        if(u == nullptr)",
            "            return;",
            "        while(!is_root(u))",
            "        {",
            "            auto p = u->p;",
            "            if(!is_root(p))",
            "            {",
            "                if((p->l == u) ^ (p->p->l == p))",
            "                    rotate(u);",
            "                else",
            "                    rotate(p);",
            "            }",
            "            rotate(u);",
            "        }",
            "    }",
            "",
            "    pair<node*, int> access(node* u, const function<int(node*)> &go_to)",
            "    {",
            "        if(u == nullptr)",
            "            return {u, 0};",
            "        splay(u);",
            "        int d = 0;",
            "",
            "        while(1)",
            "        {",
            "            u->push();",
            "            d = go_to(u);",
            "            if(d == 0)",
            "                break;",
            "            node *v = (d == -1 ? u->l : u->r);",
            "            if(v == nullptr)",
            "                break;",
            "            u = v;      ",
            "        }",
            "",
            "        splay(u);",
            "        return {u, d};",
            "    }",
            "",
            "    node* get_leftmost(node* u)",
            "    {",
            "        return access(u, [&](node*) {return -1;}).first;",
            "    }",
            "",
            "    node* get_rightmost(node* u)",
            "    {",
            "        return access(u, [&](node*) {return 1;}).first;",
            "    }",
            "",
            "    node* get_kth(node* u, int k)        // 0-indexed",
            "    {",
            "        pair<node*, int> p = access(u, [&](node* u)",
            "        {",
            "            if(u->l != nullptr)",
            "            {",
            "                if(u->l->siz > k)",
            "                    return -1;",
            "                k -= u->l->siz;",
            "            }",
            "            if(k == 0)",
            "                return 0;",
            "            -- k;",
            "            return 1;",
            "        });",
            "",
            "        auto v = p.first;",
            "        v->push();",
            "        splay(v);",
            "",
            "        return (p.second == 0 ? v : nullptr); ",
            "    }",
            "",
            "    int get_position(node *u)        // 0 -indexed",
            "    {",
            "        splay(u);",
            "        return (u->l == nullptr ? 0 : u->l->siz);",
            "    }",
            "",
            "    node* get_root(node* u)",
            "    {",
            "        splay(u);",
            "        return u;",
            "    }",
            "",
            "    pair<node*, node*> split(node* u, const function<bool(node*)> &IsRight)",
            "    {",
            "        if(u == nullptr)",
            "            return {nullptr, nullptr};",
            "        ",
            "        pair<node*, int> p = access(u, [&](node* u) {return IsRight(u) ? -1 : 1;});",
            "        ",
            "        //if p.second == 1, we have found the greatest node which should be in the left subtree",
            "        //if p.second == -1, we have found the smallest node which should be in the right subtree",
            "        //then in both cases, we splayed this node and its now the root",
            "",
            "        u = p.first;",
            "        u->push();",
            "        splay(u);",
            "",
            "        if(p.second == -1)",
            "        {",
            "            node* v = u->l;",
            "            if(v == nullptr)",
            "                return {nullptr, u};",
            "            u->l = nullptr;",
            "            v->p = nullptr;",
            "            u->pull();",
            "            return {v, u};",
            "        }",
            "        else",
            "        {",
            "            node* v = u->r;",
            "            if(v == nullptr)",
            "                return {u, nullptr};",
            "            u->r = nullptr;",
            "            v->p = nullptr;",
            "            u->pull();",
            "            return {u, v};",
            "        }",
            "",
            "        return {nullptr, nullptr};",
            "    }",
            "",
            "    node* merge(node* u, node* v)       //all in u <= all in v",
            "    {",
            "        if(u == nullptr)",
            "            return v;",
            "        if(v == nullptr)",
            "            return u;",
            "        ",
            "        u = get_rightmost(u);",
            "        u->push();",
            "        ",
            "        splay(u);",
            "",
            "        assert(u->r == nullptr);",
            "        u->r = v;",
            "        v->p = u;",
            "        u->pull();",
            "",
            "        return u;",
            "    }",
            "",
            "    node *insert(node *r, node *v, const function<bool(node *)> &go_left)",
            "    {",
            "        //returns new root",
            "        pair<node *, node *> p = split(r, go_left);",
            "        return merge(p.first, merge(v, p.second));",
            "    }",
            "",
            "    node *remove(node *u)",
            "    { ",
            "        // returns the new root",
            "        splay(u);",
            "        u->push();",
            "        node *x = u->l;",
            "        node *y = u->r;",
            "        u->l = u->r = nullptr;",
            "        if(x != nullptr)",
            "            x->p = nullptr;",
            "        if(y != nullptr) ",
            "            y->p = nullptr;",
            "        node *z = merge(x, y);",
            "        ",
            "        u->p = nullptr;",
            "        u->push();",
            "        u->pull(); // now u might be reusable...",
            "        ",
            "        return z;",
            "    }",
            "",
            "    //untested",
            "    node *next(node *v)",
            "    {",
            "        splay(v);",
            "        v->push();",
            "        //find leftmost node in subtree of right child of node v",
            "        if (v->r == nullptr)",
            "            return nullptr;",
            "        v = v->r;",
            "        while (v->l != nullptr)",
            "        {",
            "            v->push();",
            "            v = v->l;",
            "        }",
            "        splay(v);",
            "        return v;",
            "    }",
            "",
            "    //untested",
            "    node *prev(node *v)",
            "    {",
            "        splay(v);",
            "        v->push();",
            "        //find rightmost node in subtree of left child of v",
            "        if (v->l == nullptr)",
            "            return nullptr;",
            "        v = v->l;",
            "        while (v->r != nullptr)",
            "        {",
            "            v->push();",
            "            v = v->r;",
            "        }",
            "        splay(v);",
            "        return v;",
            "    }",
            "",
            "    //0-indexed",
            "    //`operate(0, node*)` is to operate with single node",
            "    //`operate(1, node*)` is to operate on subtree of node",
            "    template<typename O>",
            "    node* query(node* u, int l, int r, O operate)",
            "    {",
            "        u = get_kth(u, l);",
            "        assert(u != nullptr);",
            "        assert(l <= r and r < u->siz);",
            "",
            "        int remaining = (r - l + 1);",
            "        ",
            "        -- remaining;",
            "        operate(0, u);",
            "        u->push();",
            "",
            "        if(u->r != nullptr)",
            "            u = u->r;",
            "",
            "        while(remaining > 0)",
            "        {",
            "            u->push();",
            "",
            "            if(u->l != nullptr)",
            "            {",
            "                if(u->l->siz >= remaining)",
            "                {",
            "                    u = u->l;",
            "                    continue;",
            "                }",
            "                remaining -= u->l->siz;",
            "                operate(1, u->l);",
            "            }",
            "",
            "            if(remaining > 0)",
            "            {",
            "                -- remaining;",
            "                operate(0, u);",
            "            }",
            "",
            "            if(u->r == nullptr)",
            "                break;",
            "            u = u->r;",
            "        }",
            "",
            "        u->push();",
            "        splay(u);",
            "        u->pull();",
            "",
            "        return u;",
            "    }",
            "",
            "    //0-indexed",
            "    //`operate(0, node*)` is to operate with single node",
            "    //`operate(1, node*)` is to operate on subtree of node",
            "    template<typename O>",
            "    node* modify(node* u, int l, int r, O operate)",
            "    {",
            "        u = get_kth(u, l);",
            "        assert(u != nullptr);",
            "        assert(l <= r and r < u->siz);",
            "",
            "        int remaining = (r - l + 1);",
            "        ",
            "        -- remaining;",
            "        operate(0, u);",
            "        u->push();",
            "",
            "        auto dfs = [&](auto &&dfs) -> void",
            "        {",
            "            if(remaining == 0)",
            "                return;",
            "            ",
            "            node* cur = u;",
            "            u->push();",
            "",
            "            if(u->l != nullptr)",
            "            {",
            "                if(u->l->siz >= remaining)",
            "                {",
            "                    u = u->l;",
            "                    dfs(dfs);",
            "",
            "                    cur->pull();",
            "                    return;",
            "                }",
            "                ",
            "                remaining -= u->l->siz;",
            "                operate(1, u->l);",
            "                u->pull();          //left child might have been updated",
            "            }",
            "",
            "            if(remaining > 0)",
            "            {",
            "                -- remaining;",
            "                operate(0, u);",
            "            }",
            "",
            "            if(u->r == nullptr)",
            "            {",
            "                cur->pull();",
            "                return;",
            "            }",
            "",
            "            u = u->r;",
            "            dfs(dfs);",
            "",
            "            cur->pull();",
            "            return;",
            "        };",
            "",
            "        if(u->r != nullptr)",
            "            u = u->r;",
            "        ",
            "        node* cur = u;",
            "        dfs(dfs);",
            "        cur->pull();",
            "",
            "        u->push();",
            "        splay(u);",
            "        u->pull();",
            "",
            "        return u;",
            "    }",
            "};",
            "using namespace splay_chan;"
        ],
        "description": "Snippet for splay (normal version)"
    },
    "template_bst_node": {
        "prefix": "template_bst_node",
        "body": [
            "class node",
            "{",
            "public:",
            "//tree info",
            "    node *l, *r, *p;",
            "    //self",
            "    int key;",
            "    //subtree aggregate",
            "    int siz;",
            "",
            "//monoid info",
            "    //self",
            "    int64_t val;",
            "",
            "    //subtree Aggregates",
            "    int64_t sum;",
            "",
            "    //lazy propagation",
            "    int64_t add;",
            "",
            "    node()",
            "    {",
            "        p = l = r = nullptr;",
            "        key = siz = val = sum = add = 0;",
            "    }",
            "",
            "    //current attributes are already updated, update child attributes so that a pull would result in the correct aggregate",
            "    void push()",
            "    {",
            "        if(l != nullptr)",
            "            l->sum += add * l->siz, l->val += add, l->add += add;",
            "        if(r != nullptr)",
            "            r->sum += add * r->siz, r->val += add, r->add += add;",
            "        add = 0;",
            "    }",
            "    void pull()",
            "    {",
            "        siz = sum = 0;",
            "        if(l != nullptr)",
            "            siz += l->siz, sum += l->sum;",
            "        siz += 1, sum += val;",
            "        if(r != nullptr)",
            "            siz += r->siz, sum += r->sum;",
            "    }",
            "};"
        ],
        "description": "Snippet for bst_node (normal version)"
    },
    "sport_waifu": {
        "prefix": "sport_waifu",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"../libra/misc/dbg.h\"",
            "#else",
            "#define debug(...)",
            "#define endl \"\\\\n\"",
            "#endif",
            "",
            "signed main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int t = 1;",
            "    cin >> t;",
            "    while(t --)",
            "    {",
            "        $0",
            "    }",
            "}"
        ],
        "description": "Snippet for template (waifu version)"
    },
    "sport_hacker_waifu": {
        "prefix": "sport_hacker_waifu",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"../libra/misc/dbg.h\"",
            "#else",
            "#define debug(...)",
            "#define endl \"\\\\n\"",
            "#endif",
            "",
            "void main_()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int t = 1;",
            "    cin >> t;",
            "    for(int tt = 1; tt <= t; tt ++)",
            "    {",
            "        ifstream fin(\"inp.txt\");",
            "        ofstream fout(\"out.txt\");",
            "",
            "        $0",
            "    }",
            "}",
            "",
            "static void run_with_stack_size(void (*func)(void), size_t stsize)",
            "{",
            "    char *stack, *send;",
            "    stack = (char *)malloc(stsize);",
            "    send = stack + stsize - 16;",
            "    send = (char *)((uintptr_t)send / 16 * 16);",
            "    asm volatile(",
            "        \"mov %%rsp, (%0)\\\\n\"",
            "        \"mov %0, %%rsp\\\\n\"",
            "        :",
            "        : \"r\"(send));",
            "    func();",
            "    asm volatile(\"mov (%0), %%rsp\\\\n\" : : \"r\"(send));",
            "    free(stack);",
            "}",
            "",
            "int32_t main()",
            "{",
            "    run_with_stack_size(main_, 1024 * 1024 * 1024); // run with a 1 GiB stack",
            "    return 0;",
            "}"
        ],
        "description": "Snippet for hacker_cup (waifu version)"
    },
    "template_waifu_random": {
        "prefix": "template_waifu_random",
        "body": [
            "struct random : std::mt19937",
            "{",
            "    using std::mt19937::mt19937;",
            "    using std::mt19937::operator();",
            "    static int64_t gen_seed()",
            "    {",
            "        return std::chrono::steady_clock::now().time_since_epoch().count();",
            "    }",
            "    random() : std::mt19937(gen_seed()) {}",
            "    template <class Int>",
            "    auto operator()(Int a, Int b)",
            "        -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(a, b)(*this);",
            "    }",
            "    template <class Int>",
            "    auto operator()(Int a) -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(0, a - 1)(*this);",
            "    }",
            "    template <class Real>",
            "    auto operator()(Real a, Real b)",
            "        -> std::enable_if_t<std::is_floating_point_v<Real>, Real>",
            "    {",
            "        return std::uniform_real_distribution<Real>(a, b)(*this);",
            "    }",
            "};"
        ],
        "description": "Snippet for random (waifu version)"
    },
    "template_waifu_pragma": {
        "prefix": "template_waifu_pragma",
        "body": [
            "#include <bits/allocator.h>",
            "#pragma GCC optimize(\"O3,unroll-loops\")",
            "#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")"
        ],
        "description": "Snippet for pragma (waifu version)"
    },
    "template_waifu_random64": {
        "prefix": "template_waifu_random64",
        "body": [
            "struct random64 : std::mt19937_64",
            "{",
            "    using std::mt19937_64::mt19937_64;",
            "    using std::mt19937_64::operator();",
            "",
            "    static int64_t gen_seed()",
            "    {",
            "        return std::chrono::steady_clock::now().time_since_epoch().count();",
            "    }",
            "",
            "    random64() : std::mt19937_64(gen_seed()) {}",
            "",
            "    template <class Int>",
            "    auto operator()(Int a, Int b)",
            "        -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(a, b)(*this);",
            "    }",
            "",
            "    template <class Int>",
            "    auto operator()(Int a)",
            "        -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(0, a - 1)(*this);",
            "    }",
            "",
            "    template <class Real>",
            "    auto operator()(Real a, Real b)",
            "        -> std::enable_if_t<std::is_floating_point_v<Real>, Real>",
            "    {",
            "        return std::uniform_real_distribution<Real>(a, b)(*this);",
            "    }",
            "};"
        ],
        "description": "Snippet for random64 (waifu version)"
    },
    "template_waifu_time": {
        "prefix": "template_waifu_time",
        "body": [
            "auto start = std::chrono::high_resolution_clock::now();",
            "// Code to benchmark",
            "auto end = std::chrono::high_resolution_clock::now();",
            "auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();",
            "std::cout << \"Execution time: \" << duration << \" microseconds\" << std::endl;"
        ],
        "description": "Snippet for time (waifu version)"
    },
    "template_waifu_SolnCorrect": {
        "prefix": "template_waifu_SolnCorrect",
        "body": [
            "#include<bits/stdc++.h>",
            "#pragma GCC optimize(\"O3\")",
            "",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"/dbg.h\"",
            "#else",
            "#define endl \"\\\\n\"",
            "#define debug(...)",
            "#endif",
            "",
            "const int64_t inf = 1e9+9, INF = 1e18;",
            "",
            "//#define int int64_t",
            "",
            "const int N = 3e5+5;",
            "",
            "int32_t main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int a, b;",
            "    cin >> a >> b;",
            "    cout << a + b << endl;",
            "}"
        ],
        "description": "Snippet for SolnCorrect (waifu version)"
    },
    "template_waifu_TestGenerator": {
        "prefix": "template_waifu_TestGenerator",
        "body": [
            "#include<bits/stdc++.h>",
            "#pragma GCC optimize(\"O3\")",
            "",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"/dbg.h\"",
            "#else",
            "#define endl \"\\\\n\"",
            "#define debug(...)",
            "#endif",
            "",
            "const int64_t inf = 1e9+9, INF = 1e18;",
            "",
            "//#define int int64_t",
            "",
            "const int N = 3e5+5;",
            "",
            "int32_t main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int a = rand() % 10, b = rand() % 10;",
            "    cout << a << \" \" << b << endl; ",
            "}"
        ],
        "description": "Snippet for TestGenerator (waifu version)"
    },
    "template_waifu_SolnMy": {
        "prefix": "template_waifu_SolnMy",
        "body": [
            "#include<bits/stdc++.h>",
            "#pragma GCC optimize(\"O3\")",
            "",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"/dbg.h\"",
            "#else",
            "#define endl \"\\\\n\"",
            "#define debug(...)",
            "#endif",
            "",
            "const int64_t inf = 1e9+9, INF = 1e18;",
            "",
            "//#define int int64_t",
            "",
            "const int N = 3e5+5;",
            "",
            "int32_t main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int a, b;",
            "    cin >> a >> b;",
            "    cout << a + b << endl;",
            "}"
        ],
        "description": "Snippet for SolnMy (waifu version)"
    },
    "template_waifu_ordered_set": {
        "prefix": "template_waifu_ordered_set",
        "body": [
            "// #include<bits/extc++.h>",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "",
            "template <typename K, typename V, typename Comp = std::less<K>>",
            "using ordered_map = __gnu_pbds::tree<",
            "    K, V, Comp,",
            "    __gnu_pbds::rb_tree_tag,",
            "    __gnu_pbds::tree_order_statistics_node_update",
            ">;",
            "",
            "template <typename K, typename Comp = std::less<K>>",
            "using ordered_set = ordered_map<K, __gnu_pbds::null_type, Comp>;",
            "",
            "// Supports",
            "//  auto iterator = ordered_set().find_by_order(idx); // (0-indexed)",
            "//  int num_strictly_smaller = ordered_set().order_of_key(key);"
        ],
        "description": "Snippet for ordered_set (waifu version)"
    },
    "template_waifu_hash_map": {
        "prefix": "template_waifu_hash_map",
        "body": [
            "// #include<bits/extc++.h>",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "",
            "struct splitmix64_hash {",
            "    static uint64_t splitmix64(uint64_t x) {",
            "        // http://xorshift.di.unimi.it/splitmix64.c",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            "",
            "    size_t operator()(uint64_t x) const {",
            "        static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "    }",
            "};",
            "",
            "template <typename K, typename V, typename Hash = splitmix64_hash>",
            "using HashMap = __gnu_pbds::gp_hash_table<K, V, Hash>;",
            "",
            "template <typename K, typename Hash = splitmix64_hash>",
            "using HashSet = HashMap<K, __gnu_pbds::null_type, Hash>;"
        ],
        "description": "Snippet for hash_map (waifu version)"
    },
    "template_waifu_int_128": {
        "prefix": "template_waifu_int_128",
        "body": [
            "// int128 bit for numbers larger than 1e18. Will support numbers till 1e36",
            "// Comment out everything related to PBDS while using this",
            "// Put all the code in the same order",
            "",
            "// Typedef to ell",
            "typedef __int128 ell;",
            "",
            "// For printing",
            "std::ostream&",
            "operator<<( std::ostream& dest, __int128_t value ) {",
            "\tstd::ostream::sentry s( dest );",
            "\tif ( s ) {",
            "\t\t__uint128_t tmp = value < 0 ? -value : value; char buffer[ 128 ];",
            "\t\tchar* d = std::end( buffer );",
            "\t\tdo {\t-- d; *d = \"0123456789\"[ tmp % 10 ]; tmp /= 10;} while ( tmp != 0 );",
            "\t\tif ( value < 0 ) {-- d; *d = '-';}",
            "\t\tint len = std::end( buffer ) - d;",
            "\t\tif ( dest.rdbuf()->sputn( d, len ) != len ) {dest.setstate( std::ios_base::badbit );}",
            "\t}",
            "\treturn dest;",
            "}",
            "",
            "// For reading _int128 to_read = read()",
            "__int128 read() {",
            "\t__int128 x = 0, f = 1;",
            "\tchar ch = getchar();",
            "\twhile (ch < '0' || ch > '9') {if (ch == '-') f = -1; ch = getchar();}",
            "\twhile (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}",
            "\treturn x * f;",
            "}",
            "",
            "// For debugging",
            "void _print(ell t) {cerr << t;}"
        ],
        "description": "Snippet for int_128 (waifu version)"
    },
    "template_waifu_min_pq": {
        "prefix": "template_waifu_min_pq",
        "body": [
            "template<typename T>",
            "using MinPQ = priority_queue<T, vector<T>, greater<T>>;"
        ],
        "description": "Snippet for min_pq (waifu version)"
    },
    "template_waifu_fast_io": {
        "prefix": "template_waifu_fast_io",
        "body": [
            "namespace fast_io",
            "{",
            "    /*",
            "    warning:",
            "        remove custom fastio things",
            "    ",
            "    usage:",
            "        https://codeforces.com/contest/659/submission/128052727",
            "    */",
            "",
            "\tconstexpr int SIZE = (1 << 21) + 1;",
            "\tint num = 0, f;",
            "\tchar ibuf[SIZE], obuf[SIZE], que[65], *iS, *iT, *oS = obuf, *oT = obuf + SIZE - 1, c;",
            "\t#define gc() (iS == iT ? (iT = ((iS = ibuf) + fread(ibuf, 1, SIZE, stdin)), (iS == iT ? EOF : *iS ++)) : *iS ++)",
            "\tinline void flush()",
            "    {",
            "\t\tfwrite(obuf, 1, oS - obuf, stdout);",
            "\t\toS = obuf;",
            "\t}",
            "\tinline void putc(char c)",
            "    {",
            "\t\t*oS ++ = c;",
            "\t\tif (oS == oT) flush();",
            "\t}",
            "\tinline void getc(char &c) ",
            "    {",
            "\t\tfor (c = gc(); (c == ' ' || c == '\\\\0' || c == '\\\\n') && c != EOF; c = gc());",
            "\t}",
            "\tinline void reads(char *st) ",
            "    {",
            "\t\tchar c;",
            "\t\tint n = 0; ",
            "\t\tgetc(st[++ n]);",
            "\t\tfor (c = gc(); c != ' ' && c != '\\\\0' && c != '\\\\n' && c != EOF ; c = gc()) st[++ n] = c;",
            "\t\tst[++ n] = '\\\\0';",
            "\t}",
            "\ttemplate<class I>",
            "\tinline void read(I &x) ",
            "    {",
            "\t\tfor (f = 1, c = gc(); c < '0' || c > '9' ; c = gc()) if (c == '-') f = -1;",
            "\t\tfor (x = 0; c >= '0' && c <= '9' ; c = gc()) x = (x << 3) + (x << 1) + (c & 15);",
            "\t\tx *= f;",
            "\t}",
            "\ttemplate<class I>",
            "\tinline void print(I x) ",
            "    {",
            "\t\tif (x < 0) putc('-'), x = -x;",
            "\t\tif (!x) putc('0');",
            "\t\twhile (x) que[++ num] = x % 10 + 48, x /= 10;",
            "\t\twhile (num) putc(que[num --]);",
            "\t}",
            "\tinline void putstr(string st) ",
            "    {",
            "\t\tfor (int i = 0; i < (int)st.size() ; ++ i)  putc(st[i]);",
            "\t}",
            "\tstruct Flusher_{~Flusher_(){flush();}} io_Flusher_;",
            "}",
            "using fast_io :: read;",
            "using fast_io :: putc;",
            "using fast_io :: putstr;",
            "using fast_io :: getc;",
            "using fast_io :: reads;",
            "using fast_io :: print;"
        ],
        "description": "Snippet for fast_io (waifu version)"
    },
    "template_waifu_fast_set": {
        "prefix": "template_waifu_fast_set",
        "body": [
            "// https://codeforces.com/contest/1641/submission/147448352",
            "",
            "// D : 3 -> 2.6 * 10 ^ 5",
            "// D : 4 -> 1.6 * 10 ^ 7",
            "// D : 5 -> 1.0 * 10 ^ 9",
            "// D : 6 -> int \u306e\u7bc4\u56f2\u5168\u90e8",
            "",
            "const int not_found = 262144;",
            "",
            "template <const int D = 6> struct FastSet {",
            "    int n;",
            "    using u64 = uint64_t;",
            "    vector<u64> a[D];",
            "    FastSet(int n_ = (1 << std::min(31, D * 6))) : n(n_) {",
            "        for(int i = 0; i < D; i++) {",
            "            n_ = (n_ + 63) >> 6;",
            "            a[i].assign(n_, 0);",
            "        }",
            "    }",
            "    bool empty() const { return !a[D - 1][0]; }",
            "    bool contains(int x) const { return (a[0][x >> 6] >> (x & 63)) & 1; }",
            "    void insert(int x) {",
            "        for(int i = 0; i < D; i++) {",
            "            const int y = x & 63;",
            "            x >>= 6;",
            "            a[i][x] |= 1ULL << y;",
            "        }",
            "    }",
            "    void erase(int x) {",
            "        for(int i = 0; i < D; i++) {",
            "            const int y = x & 63;",
            "            x >>= 6;",
            "            if((a[i][x] &= ~(1ULL << y))) break;",
            "        }",
            "    }",
            "    int next(int x) const {             //smallest element >= x, returns 262144 if no such element",
            "        for(int i = 0; i < D; i++) {",
            "            const int k = x >> 6, y = x & 63;",
            "            if(k >= a[i].size()) return n;",
            "            const u64 top = a[i][k] >> y;",
            "            if(top) {",
            "                x += __builtin_ctzll(top);",
            "                for(int j = i - 1; j >= 0; --j) x = x << 6 | __builtin_ctzll(a[j][x]);",
            "                return x;",
            "            }",
            "            x = k + 1;",
            "        }",
            "        return n;",
            "    }",
            "    int prev(int x) const {            //largest element <= x",
            "        for(int i = 0; i < D; ++i) {",
            "            if(x < 0) return -1;",
            "            const int k = x >> 6, y = x & 63;",
            "            const u64 bot = a[i][k] << (63 - y);",
            "            if(bot) {",
            "                x -= __builtin_clzll(bot);",
            "                for(int j = i - 1; j >= 0; --j) x = x << 6 | (63 - __builtin_clzll(a[j][x]));",
            "                return x;",
            "            }",
            "            x = k - 1;",
            "        }",
            "        return -1;",
            "    }",
            "    int max() const { return prev(n); }",
            "    int min() const { return next(0); }",
            "};"
        ],
        "description": "Snippet for fast_set (waifu version)"
    },
    "template_waifu_ultra_fast_set": {
        "prefix": "template_waifu_ultra_fast_set",
        "body": [
            "using uint = unsigned int;",
            "using ull = unsigned long long;",
            "constexpr ull lowest_bitsll[] = {0ull, 1ull, 3ull, 7ull, 15ull, 31ull, 63ull, 127ull, 255ull, 511ull, 1023ull, 2047ull, 4095ull, 8191ull, 16383ull, 32767ull, 65535ull, 131071ull, 262143ull, 524287ull, 1048575ull, 2097151ull, 4194303ull, 8388607ull, 16777215ull, 33554431ull, 67108863ull, 134217727ull, 268435455ull, 536870911ull, 1073741823ull, 2147483647ull, 4294967295ull, 8589934591ull, 17179869183ull, 34359738367ull, 68719476735ull, 137438953471ull, 274877906943ull, 549755813887ull, 1099511627775ull, 2199023255551ull, 4398046511103ull, 8796093022207ull, 17592186044415ull, 35184372088831ull, 70368744177663ull, 140737488355327ull, 281474976710655ull, 562949953421311ull, 1125899906842623ull, 2251799813685247ull, 4503599627370495ull, 9007199254740991ull, 18014398509481983ull, 36028797018963967ull, 72057594037927935ull, 144115188075855871ull, 288230376151711743ull, 576460752303423487ull, 1152921504606846975ull, 2305843009213693951ull, 4611686018427387903ull, 9223372036854775807ull, 18446744073709551615ull};",
            "const uint NO = 1 << 20; // This value will be returned in lower_bound functions, if no answer exists. Change, if need.",
            "template <uint MAXN>     // Can correctly work with numbers in range [0; MAXN]",
            "class godgod_suc_pred",
            "{",
            "    static const uint PREF = (MAXN <= 64 ? 0 : MAXN <= 4096     ? 1",
            "                                           : MAXN <= 262144     ? 1 + 64",
            "                                           : MAXN <= 16777216   ? 1 + 64 + 4096",
            "                                           : MAXN <= 1073741824 ? 1 + 64 + 4096 + 262144",
            "                                                                : 227) +",
            "                             1;",
            "    static const uint SZ = PREF + (MAXN + 63) / 64 + 1;",
            "    ull m[SZ] = {0};",
            "",
            "    inline uint left(uint v) const { return (v - 62) * 64; }",
            "    inline uint parent(uint v) const { return v / 64 + 62; }",
            "    inline void setbit(uint v) { m[v >> 6] |= 1ull << (v & 63); }",
            "    inline void resetbit(uint v) { m[v >> 6] &= ~(1ull << (v & 63)); }",
            "    inline uint getbit(uint v) const { return m[v >> 6] >> (v & 63) & 1; }",
            "    inline ull childs_value(uint v) const { return m[left(v) >> 6]; }",
            "",
            "    inline uint left_go(uint x, const uint c) const",
            "    {",
            "        const ull rem = x & 63;",
            "        uint bt = PREF * 64 + x;",
            "        ull num = m[bt >> 6] & lowest_bitsll[rem + c];",
            "        if (num)",
            "            return (x ^ rem) | __lg(num);",
            "        for (bt = parent(bt); bt > 62; bt = parent(bt))",
            "        {",
            "            const ull rem = bt & 63;",
            "            num = m[bt >> 6] & lowest_bitsll[rem];",
            "            if (num)",
            "            {",
            "                bt = (bt ^ rem) | __lg(num);",
            "                break;",
            "            }",
            "        }",
            "        if (bt == 62)",
            "            return NO;",
            "        while (bt < PREF * 64)",
            "            bt = left(bt) | __lg(m[bt - 62]);",
            "        return bt - PREF * 64;",
            "    }",
            "",
            "    inline uint right_go(uint x, const uint c) const",
            "    {",
            "        const ull rem = x & 63;",
            "        uint bt = PREF * 64 + x;",
            "        ull num = m[bt >> 6] & ~lowest_bitsll[rem + c];",
            "        if (num)",
            "            return (x ^ rem) | __builtin_ctzll(num);",
            "        for (bt = parent(bt); bt > 62; bt = parent(bt))",
            "        {",
            "            const ull rem = bt & 63;",
            "            num = m[bt >> 6] & ~lowest_bitsll[rem + 1];",
            "            if (num)",
            "            {",
            "                bt = (bt ^ rem) | __builtin_ctzll(num);",
            "                break;",
            "            }",
            "        }",
            "        if (bt == 62)",
            "            return NO;",
            "        while (bt < PREF * 64)",
            "            bt = left(bt) | __builtin_ctzll(m[bt - 62]);",
            "        return bt - PREF * 64;",
            "    }",
            "",
            "public:",
            "    godgod_suc_pred()",
            "    {",
            "        assert(PREF != 228);",
            "        setbit(62);",
            "    }",
            "",
            "    bool empty() const { return getbit(63); }",
            "",
            "    void clear()",
            "    {",
            "        fill(m, m + SZ, 0);",
            "        setbit(62);",
            "    }",
            "",
            "    bool count(uint x) const { return m[PREF + (x >> 6)] >> (x & 63) & 1; }",
            "",
            "    void insert(uint x)",
            "    {",
            "        for (uint v = PREF * 64 + x; !getbit(v); v = parent(v))",
            "        {",
            "            setbit(v);",
            "        }",
            "    }",
            "",
            "    void erase(uint x)",
            "    {",
            "        if (!getbit(PREF * 64 + x))",
            "            return;",
            "        resetbit(PREF * 64 + x);",
            "        for (uint v = parent(PREF * 64 + x); v > 62 && !childs_value(v); v = parent(v))",
            "        {",
            "            resetbit(v);",
            "        }",
            "    }",
            "",
            "    uint lower_bound(uint x) const { return right_go(x, 0); }",
            "    uint upper_bound(uint x) const { return right_go(x, 1); }",
            "    uint inverse_lower_bound(uint x) const { return left_go(x, 1); }",
            "    uint inverse_upper_bound(uint x) const { return left_go(x, 0); }",
            "};",
            "// Supports all std::set operations in O(1) on random queries / dense arrays, O(log_64(N)) in worst case (sparce array).",
            "// Count operation works in O(1) always.",
            "//  reference : https://codeforces.com/contest/1793/submission/193330718"
        ],
        "description": "Snippet for ultra_fast_set (waifu version)"
    },
    "template_waifu_random_suffix_tree": {
        "prefix": "template_waifu_random_suffix_tree",
        "body": [
            "template<typename C, typename L, typename G, typename R>",
            "class random_suffix_tree_chan",
            "{",
            "    /*",
            "    info:",
            "        - Based on https://www.welcome-to-the-sunny-side.com/algo/theory/suffix_tree_funny_construction.html ",
            "        - Generates suffix tree using the leader split technique for a set of strings numbered from 0 to n - 1",
            "        - bool compare(int i, int j, int x) returns true if x-length prefix of strings i and j is equal, and false otherwise",
            "        - int length(int i) returns length of ith string",
            "        - int get(int i, int x) returns the xth integer of string i (1 based indexing)",
            "        - rng just needs to have rng(x) generating random integer in [0, x)",
            "    warning:",
            "        - has been stress tested but its pretty slow and not optimized at all: https://judge.yosupo.jp/submission/237581",
            "    */",
            "public:",
            "    int n, root;",
            "    vector<int> dep;",
            "    vector<int> nid;",
            "    vector<int> rep;",
            "    vector<vector<int>> adj;",
            "",
            "    random_suffix_tree_chan(int n, C compare, L length, G get, R rng) : ",
            "    n(n), dep(2 * n + 5), nid(2 * n + 5), rep(2 * n + 5, -1), adj(2 * n + 5)",
            "    {",
            "        vector<int> alive(n);",
            "        iota(alive.begin(), alive.end(), 0);",
            "",
            "        int timer = n - 1;",
            "        vector<int> dis(2 * n + 5);",
            "        vector<int> brk(2 * n + 5);",
            "",
            "        auto construct = [&](vector<int> a, auto &&construct) -> int",
            "        {",
            "            assert(!a.empty());",
            "",
            "            if(a.size() == 1)",
            "            {",
            "                int u = a[0];",
            "                nid[u] = u;",
            "                rep[u] = u;",
            "                return a[0];",
            "            }",
            "",
            "            int l = a[rng(a.size())];",
            "            a.erase(find(a.begin(), a.end(), l));",
            "            dis[l] = length(l);",
            "",
            "            for(auto v : a)",
            "            {",
            "                dis[v] = 0;",
            "                int s = 1, e = min(dis[l], length(v));",
            "                while(s <= e)",
            "                {",
            "                    int mid = (s + e)/2;",
            "                    if(compare(l, v, mid))",
            "                        s = mid + 1, dis[v] = mid;",
            "                    else",
            "                        e = mid - 1;",
            "                }",
            "            }",
            "",
            "            sort(a.begin(), a.end(), [&](int i, int j) {return dis[i] > dis[j];});",
            "            a.insert(a.begin(), l);",
            "",
            "            vector<int> nodes;",
            "",
            "            while(!a.empty())",
            "            {",
            "                int len = dis[a.back()];",
            "                vector<int> split;",
            "",
            "                int node = -1;",
            "",
            "                while(!a.empty() and dis[a.back()] == len)",
            "                {",
            "                    if(length(a.back()) == len)",
            "                    {",
            "                        if(node == -1)",
            "                            node = a.back(), rep[node] = node;",
            "                        nid[a.back()] = node;",
            "                    }",
            "                    else",
            "                        split.push_back(a.back());",
            "                    a.pop_back();",
            "                }",
            "",
            "                if(node == -1)",
            "                    node = ++ timer;",
            "",
            "                dep[node] = len;",
            "",
            "                for(auto u : split)",
            "                    brk[u] = get(u, len + 1);",
            "                ",
            "                sort(split.begin(), split.end(), [&](int i, int j) {return brk[i] < brk[j];});",
            "                ",
            "                for(int i = 0; i < split.size();)",
            "                {",
            "                    int j = i;",
            "                    while(j < split.size() and brk[split[i]] == brk[split[j]])",
            "                        ++ j;",
            "                    ",
            "                    vector<int> hsplit;",
            "                    for(int k = i; k < j; k ++)",
            "                        hsplit.push_back(split[k]);",
            "                    ",
            "                    int child = construct(hsplit, construct);",
            "",
            "                    adj[node].push_back(child);",
            "                    rep[node] = max(rep[node], rep[child]);",
            "",
            "                    i = j;",
            "                }",
            "              ",
            "                nodes.push_back(node);",
            "            }",
            "",
            "            for(int i = 0; i < nodes.size() - 1; i ++)",
            "            {",
            "                adj[nodes[i]].push_back(nodes[i + 1]);",
            "                rep[nodes[i]] = max(rep[nodes[i]], rep[nodes[i + 1]]);",
            "            }",
            "",
            "            return nodes.front();",
            "        };",
            "        root = construct(alive, construct);",
            "",
            "        if(dep[root] != 0)",
            "        {",
            "            int new_root = ++ timer;",
            "            adj[new_root].push_back(root);",
            "            dep[new_root] = 0;",
            "            rep[new_root] = rep[root];",
            "            root = new_root;",
            "        }",
            "",
            "        for(int u = 0; u < adj.size(); u ++)",
            "        {",
            "            for(auto v : adj[u])",
            "                brk[v] = get(rep[v], dep[u] + 1);",
            "",
            "            sort(adj[u].begin(), adj[u].end(), ",
            "            [&](int i, int j) {return brk[i] < brk[j];});",
            "        }",
            "    };",
            "};"
        ],
        "description": "Snippet for random_suffix_tree (waifu version)"
    },
    "template_waifu_scc": {
        "prefix": "template_waifu_scc",
        "body": [
            "class condenser_chan",
            "{",
            "    /*",
            "    tc: O(n + m)",
            "    ml: O(n + m)",
            "",
            "    info:",
            "        0-indexed    ",
            "        SCC u occurs before SCC v (u < v) in some topological ordering of SCCs ",
            "",
            "    warning: ",
            "        there may be multiple edges between different SCCs",
            "",
            "    var:",
            "        [n -> number of nodes]",
            "        [c -> number of SCCs]",
            "        [comp[u] -> component number of node u]",
            "        [scc[u] -> outedge list for scc u]",
            "        [grp[u] -> node list for scc u]",
            "    */",
            "public:",
            "    int n, c;",
            "    vector<bool> vis;",
            "    vector<int> stak, comp;",
            "    vector<vector<int>> adj, rdj, scc, grp;",
            "",
            "    condenser_chan(int n, const vector<vector<int>> &adj) :",
            "    n(n), c(0), vis(n), adj(adj), rdj(n), scc(n), grp(n), comp(n, -1) ",
            "    {",
            "        for(int u = 0; u < n; u ++)",
            "            for(auto v : adj[u])",
            "                rdj[v].push_back(u);",
            "    };",
            "",
            "    void condense()",
            "    {",
            "        auto dfs1 = [&](int u, auto &&dfs1) -> void ",
            "        {",
            "            vis[u] = true;",
            "            for(auto v : adj[u])",
            "                if(!vis[v])",
            "                    dfs1(v, dfs1);",
            "            stak.push_back(u);",
            "        };",
            "        for(int u = 0; u < n; u ++)",
            "            if(!vis[u])",
            "                dfs1(u, dfs1);",
            "",
            "        auto dfs2 = [&](int u, auto &&dfs2) -> void ",
            "        {",
            "            comp[u] = c;",
            "            for(auto v : rdj[u])",
            "                if(comp[v] == -1)",
            "                    dfs2(v, dfs2);",
            "        };",
            "",
            "        reverse(stak.begin(), stak.end());",
            "        for(auto u : stak)",
            "            if(comp[u] == -1)",
            "                dfs2(u, dfs2), ++ c;",
            "",
            "        for(int u = 0; u < n; u ++)",
            "            for(auto v : adj[u])",
            "                if(comp[u] != comp[v])",
            "                    scc[comp[u]].push_back(comp[v]);",
            "",
            "        for(int u = 0; u < n; u ++)",
            "            grp[comp[u]].push_back(u);",
            "    }",
            "",
            "    void fix()      //remove multiple edges [O(m log(m))]",
            "    {",
            "        for(auto &v : scc)",
            "        {",
            "            sort(v.begin(), v.end());",
            "            v.erase(unique(v.begin(), v.end()), v.end());",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet for scc (waifu version)"
    },
    "template_waifu_connectivity": {
        "prefix": "template_waifu_connectivity",
        "body": [
            "class connectivity_chan",
            "{",
            "    /*",
            "        n -> number of nodes",
            "        bridge -> contains all bridges",
            "        a -> number of cutpoints",
            "        cut[u] -> is u an articulation point",
            "        m -> n + number of biconnected components (bcc's indexed in [n, inf))",
            "        bcc -> stores bcc's (note that its of size m, and the first n elements are empty vectors)",
            "        b -> number of nodes in the block cut tree",
            "        block_node_id -> id of bct-node that a certain node belongs to",
            "        cut_node_id -> new id of a cut node",
            "        bct_comp -> just stores the set of original nodes that correspond to a certain node in the bct",
            "        bct -> the actual adjacency list for the bct",
            "",
            "        Block: BCC",
            "        All edges form equivalence classes, these are grouped into blocks (BCCs)",
            "        These blocks may share vertices but not edges",
            "        A bipartite graph (and tree), BCT is formed by creating a node for every block, every",
            "        cut-point and adding an edge from every cut-point to all the blocks it is a part of.",
            "    */",
            "public:",
            "    int n;",
            "    vector<vector<int>> adj;",
            "    int timer;",
            "    vector<int> tin, low;",
            "",
            "    vector<pair<int, int>> bridge;",
            "",
            "    int a;",
            "    vector<bool> cut;",
            "",
            "    int m;",
            "    vector<vector<int>> bcc;",
            "",
            "    int b;",
            "    vector<int> block_node_id;",
            "    vector<int> cut_node_id;",
            "    vector<vector<int>> bct_comp;    ",
            "    vector<vector<int>> bct;",
            "",
            "    connectivity_chan(const vector<vector<int>> &adj) : ",
            "    n(adj.size()), m(n), adj(adj), timer(0), tin(n, -1), low(n, -1), cut(n), bcc(n), ",
            "    block_node_id(n, -1), cut_node_id(n, -1) ",
            "    {",
            "        compute_connectivity();",
            "        make_block_cut_tree();",
            "    };",
            "",
            "    void compute_connectivity()",
            "    {",
            "        vector<bool> vis(n);",
            "        vector<int> stk;",
            "",
            "        auto dfs = [&](int u, int p, auto &&dfs) -> void",
            "        {",
            "            tin[u] = low[u] = timer ++;",
            "            vis[u] = true;",
            "            stk.push_back(u);",
            "",
            "            int ptimes = 0;",
            "            int children = 0;",
            "            for(auto v : adj[u])",
            "            {",
            "                if(v == p)",
            "                {",
            "                    ++ ptimes;",
            "                    continue;",
            "                }",
            "",
            "                if(vis[v])",
            "                    low[u] = min(low[u], tin[v]);",
            "                else",
            "                {",
            "                    ++ children;",
            "                    int s = stk.size();",
            "                    dfs(v, u, dfs);",
            "                    low[u] = min(low[u], low[v]);",
            "",
            "                    if((p == -1 and children > 1) or (p != -1 and tin[u] <= low[v]))",
            "                    {",
            "                        cut[u] = true;",
            "                        bcc.push_back(vector<int> ());",
            "                        bcc[m].push_back(u);",
            "                        while(stk.size() > s)",
            "                        {",
            "                            bcc[m].push_back(stk.back());",
            "                            stk.pop_back();",
            "                        }",
            "                        ++ m;",
            "                    }",
            "                }",
            "            ",
            "            }",
            "",
            "            if(p != -1 and ptimes <= 1 and low[u] > tin[p])",
            "                bridge.emplace_back(min(u, p), max(u, p));",
            "        };",
            "        for(int u = 0; u < n; u ++)",
            "            if(!vis[u])",
            "            {",
            "                dfs(u, -1, dfs);",
            "                bcc.push_back(vector<int> ());",
            "                while(!stk.empty())",
            "                {",
            "                    bcc[m].push_back(stk.back());",
            "                    stk.pop_back();",
            "                }",
            "                ++ m;",
            "            }",
            "        a = count(cut.begin(), cut.end(), true);",
            "    }",
            "",
            "    void make_block_cut_tree()",
            "    {",
            "        b = (m - n) + a;",
            "        bct_comp.assign(b, vector<int>());",
            "        bct.assign(b, vector<int>());",
            "",
            "        for(int i = n; i < m; i ++)",
            "        {",
            "            bct_comp[i - n] = bcc[i];",
            "            for(auto u : bct_comp[i - n])",
            "                block_node_id[u] = i - n;",
            "        }",
            "",
            "        vector<int> cut_list;",
            "        for(int i = 0; i < n; i ++)",
            "            if(cut[i])",
            "                cut_list.push_back(i);",
            "            ",
            "        for(int i = m - n; i < m - n + a; i ++)",
            "        {",
            "            bct_comp[i] = {cut_list[i - (m - n)]};",
            "            for(auto u : bct_comp[i])",
            "                cut_node_id[u] = i;",
            "        }",
            "",
            "        for(int i = 0; i < m - n; i ++)",
            "            for(auto u : bct_comp[i])",
            "                if(cut[u])",
            "                    bct[i].push_back(cut_node_id[u]), bct[cut_node_id[u]].push_back(i);",
            "    }",
            "};"
        ],
        "description": "Snippet for connectivity (waifu version)"
    },
    "template_waifu_level_ancestor": {
        "prefix": "template_waifu_level_ancestor",
        "body": [
            "//wip",
            "class level_ancestor_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<int> tin;",
            "    vector<int> tout;",
            "    vector<int> heavy;",
            "",
            "    level_ancestor_chan(int n, int r, const vector<vector<int>> &tree) : ",
            "    n(n), heavy(n + 1), tin(n + 1), tout(n + 1)",
            "    {",
            "        auto adj = tree;",
            "        vector<int> sz(n + 1, 0);",
            "        auto dfs1 = [&](int u, int p, auto &&dfs) -> void",
            "        {",
            "            sz[u] = 1;",
            "            if(p != 0)",
            "                adj[u].erase(find(adj[u].begin(), adj[u].end(), p));",
            "            for(auto v : adj[u])",
            "                dfs(v, u, dfs), sz[u] += sz[v];",
            "            if(!adj[u].empty())",
            "            {",
            "                auto mit = *max_element(adj[u].begin(), adj[u].end(), [&](int v1, int v2) {return sz[v1] < sz[v2];});",
            "                swap(*adj[u].begin(), mit);",
            "            }",
            "        };",
            "        dfs1(r, 0, dfs1);",
            "",
            "        int timer = 0;",
            "        auto dfs2 = [&](int u, int p, auto &&dfs) -> void",
            "        {",
            "            tin[]",
            "        };",
            "    };",
            "",
            "    bool is_anc(int a, int u)",
            "    {",
            "        return tin[a] <= tin[u] and tout[u] <= tout[a];",
            "    }",
            "",
            "    int lca(int u, int v)",
            "    {",
            "",
            "    }",
            "",
            "    int get_ancestor(int u, int k)",
            "    {",
            "",
            "    }",
            "};"
        ],
        "description": "Snippet for level_ancestor (waifu version)"
    },
    "template_waifu_binary_lifter": {
        "prefix": "template_waifu_binary_lifter",
        "body": [
            "class binary_lifter_chan",
            "{",
            "    /*",
            "    tc: O(n logn) preprocessing, O(logn) query",
            "    ml: O(n logn)",
            "",
            "    info:",
            "        - 0 indexed",
            "        - n -> number of nodes",
            "        - dep[u] -> depth of node u",
            "        - tin[u], tout[u] -> intime, outtime of node u",
            "        - up[u][i] -> stores 2^ith ancestor of u",
            "    */",
            "public:",
            "    int n, L, timer;",
            "    vector<int> dep, tin, tout;",
            "    vector<vector<int>> up;",
            "",
            "    binary_lifter_chan(int n, int r, const vector<vector<int>> &adj) : ",
            "    n(n), L(ceil(log2(n)) + 1), timer(0), dep(n), tin(n), tout(n), up(n, vector<int> (L, r))",
            "    {",
            "        timer = 0;",
            "        dep[r] = 0;",
            "        dfs(r, r, adj);",
            "    }",
            "",
            "    void dfs(int u, int p, const vector<vector<int>> &adj)",
            "    {",
            "        tin[u] = ++ timer;",
            "        up[u][0] = p;",
            " ",
            "        for(int i = 1; i < L; ++i)",
            "            up[u][i] = up[up[u][i - 1]][i - 1];",
            " ",
            "        for(auto v : adj[u])",
            "            if (v != p)",
            "                dep[v] = dep[u] + 1, dfs(v, u, adj);",
            "",
            "        tout[u] = ++ timer;",
            "    }",
            "",
            "    int get_kth(int v, int k)",
            "    {",
            "        if(k != 0)",
            "            for(int i = L - 1; i >= 0 and v > 0; i --)",
            "                if((1 << i) <= k)",
            "                    k -= (1 << i), v = up[v][i];",
            "        return v;",
            "    }",
            "",
            "    bool is_anc(int anc, int v)",
            "    {",
            "        return tin[anc] <= tin[v] and tout[v] <= tout[anc];",
            "    }",
            "",
            "    int lca(int u, int v)",
            "    {",
            "        if (is_anc(u, v))",
            "            return u;",
            "        if (is_anc(v, u))",
            "            return v;",
            "        for (int i = L - 1; i >= 0; --i) ",
            "            if (!is_anc(up[u][i], v))",
            "                u = up[u][i];",
            "        return up[u][0];",
            "    }",
            "};"
        ],
        "description": "Snippet for binary_lifter (waifu version)"
    },
    "template_waifu_offline_lca": {
        "prefix": "template_waifu_offline_lca",
        "body": [
            "vector<int> offline_lca_chan(int n, int r, const vector<vector<int>> &adj, vector<pair<int, int>> query)",
            "{",
            "    /*",
            "        info:",
            "            - 0 indexed",
            "        vars:",
            "            - n : number of nodes",
            "            - r : root",
            "    */",
            "    ",
            "",
            "    //dsu",
            "    vector<int> par(n), siz(n, 1);",
            "    iota(par.begin(), par.end(), 0);",
            "    auto get = [&](int u, auto &&get) -> int",
            "    {",
            "        return (par[u] == u ? u : par[u] = get(par[u], get));",
            "    };",
            "    auto unite = [&](int u, int v) -> void",
            "    {",
            "        u = get(u, get), v = get(v, get);",
            "        if(u == v)",
            "            return;",
            "        if(siz[u] < siz[v])",
            "            swap(u, v);",
            "        par[v] = u, siz[u] += siz[v];",
            "    };",
            "",
            "    assert(!query.empty());",
            "    int m = query.size();",
            "    ",
            "    vector<int> ans(m);",
            "    vector<bool> see(m);",
            "    vector<vector<int>> store(n);",
            "",
            "    for(int i = 0; i < m; i ++)",
            "    {",
            "        auto [u, v] = query[i];",
            "        store[u].push_back(i), store[v].push_back(i);",
            "    }",
            "",
            "    auto dfs = [&](int u, int p, auto &&dfs) -> void",
            "    {",
            "        for(auto i : store[u])",
            "        {",
            "            if(see[i])",
            "                ans[i] = get(query[i].first == u ? query[i].second : query[i].first, get);",
            "            see[i] = true;",
            "        }",
            "",
            "        for(auto v : adj[u])",
            "            if(v != p)",
            "                dfs(v, u, dfs);",
            "",
            "        if(p != 0)",
            "            unite(u, p);",
            "    };",
            "    dfs(r, 0, dfs);",
            "    ",
            "    return ans;",
            "};"
        ],
        "description": "Snippet for offline_lca (waifu version)"
    },
    "template_waifu_virtual_tree": {
        "prefix": "template_waifu_virtual_tree",
        "body": [
            "template <typename L>",
            "vector<pair<int, int>> virtual_tree_chan(vector<int> key, const vector<int> &tin, const vector<int> &tout, L &lca)",
            "{",
            "    /*",
            "        info:",
            "            - index agnostic",
            "    */",
            "    assert(!key.empty());",
            "    sort(key.begin(), key.end(), [&](int a, int b)  { return tin[a] < tin[b]; });",
            "",
            "    vector<int> l;",
            "    for (int i = 0; i < key.size() - 1; i++)",
            "        l.push_back(lca.LCA(key[i], key[i + 1]));",
            "    ",
            "    for (auto p : l)",
            "        key.push_back(p);",
            "    sort(key.begin(), key.end(), [&](int a, int b)  { return tin[a] < tin[b]; });",
            "    key.erase(unique(key.begin(), key.end()), key.end());",
            "    reverse(key.begin(), key.end());",
            "",
            "    // stk contains path from root to current node, key contains unvisited nodes",
            "    stack<int> stk;",
            "    vector<pair<int, int>> edge;",
            "",
            "    stk.push(key.back());",
            "    key.pop_back();",
            "",
            "    while (!stk.empty())",
            "    {",
            "        int u = stk.top();",
            "        if (!key.empty() and tin[u] <= tin[key.back()] and tout[key.back()] <= tout[u])",
            "        {",
            "            edge.push_back(make_pair(u, key.back()));",
            "            stk.push(key.back());",
            "            key.pop_back();",
            "            continue;",
            "        }",
            "        stk.pop();",
            "    }",
            "",
            "    return edge;",
            "}"
        ],
        "description": "Snippet for virtual_tree (waifu version)"
    },
    "template_waifu_centroid": {
        "prefix": "template_waifu_centroid",
        "body": [
            "",
            "class centroid_decomposition_chan",
            "{",
            "    /*",
            "        info:",
            "            - 0-indexed",
            "            - roots the tree at `root`",
            "            - finally, par and cadj define the centroid tree",
            "            - parent of root is -1",
            "    */",
            "public:",
            "    int n;",
            "    int root;",
            "",
            "    vector<int> par;",
            "    vector<vector<int>> cadj;",
            "",
            "    centroid_decomposition_chan(int n, const vector<vector<int>> &adj) : n(n), par(n, -1), cadj(n) ",
            "    {",
            "        vector<bool> mark(n, false);",
            "        vector<int> sub(n);",
            "        auto find_centroid = [&](int u) -> int",
            "        {",
            "            assert(!mark[u]);",
            "            int cnt = 0;",
            "            vector<int> seen;",
            "            auto dfs = [&](int u, int p, auto &&dfs) -> void",
            "            {",
            "                ++ cnt;",
            "                sub[u] = 1;",
            "                for(auto v : adj[u])",
            "                    if(v != p and !mark[v])",
            "                        dfs(v, u, dfs), sub[u] += sub[v];",
            "            };",
            "            dfs(u, 0, dfs);",
            "",
            "            int cen = -1;",
            "            auto dfs2 = [&](int u, int p, auto &&dfs2) -> void",
            "            {",
            "                int mx = cnt - sub[u];",
            "                for(auto v : adj[u])",
            "                    if(v != p and !mark[v])",
            "                    {",
            "                        dfs2(v, u, dfs2);",
            "                        mx = max(mx, sub[v]);",
            "                    }",
            "                if(mx <= cnt/2)",
            "                    cen = u;",
            "            };",
            "            dfs2(u, 0, dfs2);",
            "",
            "            assert(cen != -1);",
            "            return cen;",
            "        };",
            "",
            "        auto dfs = [&](int u, auto &&dfs) -> void",
            "        {",
            "            for(auto v : adj[u])",
            "                if(!mark[v])",
            "                {",
            "                    int c = find_centroid(v);",
            "                    cadj[u].push_back(c);",
            "                    par[c] = u;",
            "                    mark[c] = true;",
            "                    dfs(c, dfs);",
            "                }",
            "        };",
            "        root = find_centroid(0);",
            "        mark[root] = true;",
            "        dfs(root, dfs);",
            "    };",
            "};"
        ],
        "description": "Snippet for centroid (waifu version)"
    },
    "template_waifu_heavy_light": {
        "prefix": "template_waifu_heavy_light",
        "body": [
            "template <typename I, typename T, template<typename, typename> typename S, const bool on_edge>",
            "class heavy_light_chan",
            "{",
            "    /*",
            "        info:",
            "            - 0 indexed",
            "            - range [pos[u], out[u]) represents subtree of u",
            "        vars:",
            "            - I: Info struct of segment tree",
            "            - T: Lazy Tag struct of segment tree",
            "            - S: segment tree class (S must support S<I, T>)",
            "            - r = tree root",
            "            - on_edge = true => values on edges. Internally, value of edge is stored at lower node.",
            "        warning:",
            "            - handle segtree initialization correctly",
            "            - monoid operations must be commutative here",
            "                (implement directed path queries later)",
            "    */",
            "public:",
            "    int n, r;",
            "    vector<int> par, heavy, dep, root, pos, out;",
            "    S<I, T> tree;",
            "",
            "    heavy_light_chan(int n, int r, vector<vector<int>> adj) :",
            "    n(n), r(r), par(n, -1), heavy(n, -1), dep(n), root(n), pos(n), out(n),",
            "    tree(n + 1)",
            "    {",
            "        assert(r < n);",
            "",
            "        auto dfs_sz = [&](int u, auto &&dfs) -> int",
            "        {",
            "            int ss = 1, m = 0;",
            "            for(auto &v : adj[u])",
            "                if(v != par[u])",
            "                {",
            "                    par[v] = u, dep[v] = dep[u] + 1;",
            "                    int s = dfs(v, dfs);",
            "                    ss += s;",
            "                    if(s > m)",
            "                        heavy[u] = v, m = s, swap(adj[u][0], v);",
            "                }",
            "            return ss;",
            "        };",
            "        int timer = 0;",
            "        auto dfs_hld = [&](int u, auto &&dfs) -> void",
            "        {",
            "            pos[u] = timer ++;",
            "            for(auto v : adj[u])",
            "                if(v != par[u])",
            "                    root[v] = (heavy[u] == v ? root[u] : v), dfs(v, dfs);",
            "            out[u] = timer;",
            "        };",
            "        par[r] = -1, dep[r] = 0, root[r] = r;",
            "        dfs_sz(r, dfs_sz), dfs_hld(r, dfs_hld);",
            "    };",
            "",
            "    int lca(int u, int v)",
            "    {",
            "        for (; root[u] != root[v]; v = par[root[v]])",
            "            if (dep[root[u]] > dep[root[v]])",
            "                swap(u, v);",
            "        return (dep[u] < dep[v] ? u : v);",
            "    }",
            "",
            "    template <typename O>",
            "    void process_path(int u, int v, O op)",
            "    {",
            "        for (; root[u] != root[v]; v = par[root[v]])",
            "        {",
            "            if (dep[root[u]] > dep[root[v]])",
            "                swap(u, v);",
            "            op(pos[root[v]], pos[v]);",
            "        }",
            "        if (dep[u] > dep[v])",
            "            swap(u, v);",
            "        ",
            "        if(!on_edge)",
            "            op(pos[u], pos[v]);",
            "        else if(u != v)",
            "            op(pos[u] + 1, pos[v]);",
            "    }",
            "    ",
            "    void set(int v, const I &info)",
            "    {",
            "        tree.set(pos[v], info);",
            "    }",
            "    void modify_path(int u, int v, const T &tag)",
            "    {",
            "        process_path(u, v, [this, &tag](int l, int r)  {tree.modify(l, r, tag);});",
            "    }",
            "    void modify_subtree(int u, const T &tag)",
            "    {",
            "        if(!on_edge)",
            "            tree.modify(pos[u], out[u] - 1, tag);",
            "        else if(pos[u] < out[u] - 1)",
            "            tree.modify(pos[u] + 1, out[u] - 1, tag);",
            "    }",
            "",
            "    I get(int v)",
            "    {",
            "        return tree.get(pos[v]);",
            "    }",
            "    I query_path(int u, int v)",
            "    {",
            "        I res = I();",
            "        process_path(u, v, [this, &res](int l, int r)    {res = res.unite(tree.query(l, r));});",
            "        return res;",
            "    }",
            "    I query_subtree(int u)",
            "    {",
            "        if(on_edge)",
            "            return (pos[u] < out[u] - 1 ? tree.query(pos[u] + 1, out[u] - 1) : I());   ",
            "        return tree.query(pos[u], out[u] - 1);",
            "    }",
            "};"
        ],
        "description": "Snippet for heavy_light (waifu version)"
    },
    "template_waifu_bipartite": {
        "prefix": "template_waifu_bipartite",
        "body": [
            "class bipartite_chan",
            "{",
            "    /*",
            "        tc: O(E sqrt(V))",
            "        mc: O(V + E)",
            "",
            "        vars:",
            "            n, m: size of left and right partitions",
            "            adj: left to right edges ONLY",
            "        info:",
            "            Both partitions are individually 0 indexed",
            "            After calling max_matching():",
            "                - matching = size of max matching",
            "                - l[u] = matched right node for u (l[u] = -1 => unmatched)",
            "                - r[u] = matched left node for u (r[u] = -1 => unmatched)",
            "            MVC is found by:",
            "                - orienting matched edges from right to left, unmatched opposite",
            "                - running dfs from all unmatched left side nodes",
            "                - (unvis nodes on the left) + (visited nodes on right) = mvc",
            "            MIS is complement of MVC",
            "    */",
            "public:",
            "    int n, m;",
            "    int matching = 0;",
            "    vector<vector<int>> adj;",
            "    vector<int> l, r, lvl;",
            "    bipartite_chan(int n, int m, const vector<vector<int>> &adj) : ",
            "        n(n), m(m), l(n, -1), r(m, -1), adj(adj) {};",
            "",
            "    // void Add(int u, int v)  { adj[u].push_back(v); }",
            "    bool dfs(int u)",
            "    {",
            "        int t = exchange(lvl[u], -1) + 1;",
            "        for (int v : adj[u])",
            "            if (r[v] == -1 or (lvl[r[v]] == t and dfs(r[v])))",
            "                return l[u] = v, r[v] = u, 1;",
            "        return 0;",
            "    }",
            "",
            "    int max_matching()",
            "    {",
            "        matching = 0;   ",
            "        vector<int> q(n);",
            "        for (int s = 0, t = 0;; s = t = 0)",
            "        {",
            "            lvl = vector<int>(n);   bool f = 0;",
            "            for(int i = 0; i < n; i ++) ",
            "                if (l[i] == -1) ",
            "                    lvl[i] = 1, q[t ++] = i;",
            "            ",
            "            while (s < t)",
            "            {",
            "                int u = q[ s++];",
            "                for (int v : adj[u])",
            "                {",
            "                    int x = r[v];",
            "                    if (x == -1)",
            "                        f = 1;",
            "                    else if (!lvl[x])",
            "                        lvl[x] = lvl[u] + 1, q[t++] = x;",
            "                }",
            "            }",
            "",
            "            if (!f)",
            "                break;",
            "            ",
            "            for(int i = 0; i < n; i ++) ",
            "                if (l[i] == -1) ",
            "                    matching += dfs(i);",
            "        }",
            "        return matching;",
            "    }",
            "",
            "    vector<pair<int, int>> max_matching_edges()",
            "    {",
            "        vector<pair<int, int>> mme;",
            "        for(int u = 0; u < n; u ++)",
            "            if(l[u] != -1)",
            "                mme.push_back(make_pair(u, l[u]));",
            "        return mme;",
            "    }",
            "    ",
            "    pair<vector<int>, vector<int>> min_vertex_cover()",
            "    {",
            "        vector<bool> lv(n, false), rv(m, false);",
            "        ",
            "        auto dfs = [&](int u, auto &&dfs) -> void",
            "        {",
            "            lv[u] = true;",
            "            for(auto v : adj[u])",
            "                if(r[v] != u and !rv[v])",
            "                {",
            "                    rv[v] = true;",
            "                    if(r[v] != -1 and !lv[r[v]])",
            "                        dfs(r[v], dfs);",
            "                }",
            "        };",
            "        for(int u = 0; u < n; u ++)",
            "            if(l[u] == -1 and !lv[u])",
            "                dfs(u, dfs);",
            "",
            "        vector<int> lc, rc;",
            "        for(int u = 0; u < n; u ++)",
            "            if(!lv[u])",
            "                lc.push_back(u);",
            "        for(int u = 0; u < m; u ++)",
            "            if(rv[u])",
            "                rc.push_back(u);",
            "        ",
            "        assert(matching == (int)lc.size() + (int)rc.size());",
            "        return {lc, rc};",
            "    }",
            "};"
        ],
        "description": "Snippet for bipartite (waifu version)"
    },
    "template_waifu_gaussian_elimination": {
        "prefix": "template_waifu_gaussian_elimination",
        "body": [
            "class gauss_chan",
            "{",
            "public:",
            "    int d, sz;",
            "    vector<int> basis;",
            "",
            "    gauss_chan (int d) : d(d), sz(0), basis(d) {};",
            "",
            "    void insert(int mask)",
            "    {",
            "        for(int i = 0; i < d; i ++) if(mask & (1 << i))",
            "        {",
            "            if(basis[i] == 0)",
            "            {",
            "                basis[i] = mask;",
            "                ++ sz;",
            "                break;",
            "            }",
            "            mask ^= basis[i];",
            "        }",
            "    }",
            "",
            "    void query()",
            "    {",
            "        //",
            "    }",
            "};"
        ],
        "description": "Snippet for gaussian_elimination (waifu version)"
    },
    "template_waifu_mod_int_variable": {
        "prefix": "template_waifu_mod_int_variable",
        "body": [
            "",
            "namespace atcoder",
            "{",
            "",
            "    namespace internal",
            "    {",
            "",
            "        // @param m `1 <= m`",
            "        // @return x mod m",
            "        constexpr long long safe_mod(long long x, long long m)",
            "        {",
            "            x %= m;",
            "            if (x < 0)",
            "                x += m;",
            "            return x;",
            "        }",
            "",
            "        // Fast modular multiplication by barrett reduction",
            "        // Reference: https://en.wikipedia.org/wiki/Barrett_reduction",
            "        // NOTE: reconsider after Ice Lake",
            "        struct barrett",
            "        {",
            "            unsigned int _m;",
            "            unsigned long long im;",
            "",
            "            // @param m `1 <= m`",
            "            explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}",
            "",
            "            // @return m",
            "            unsigned int umod() const { return _m; }",
            "",
            "            // @param a `0 <= a < m`",
            "            // @param b `0 <= b < m`",
            "            // @return `a * b % m`",
            "            unsigned int mul(unsigned int a, unsigned int b) const",
            "            {",
            "                // [1] m = 1",
            "                // a = b = im = 0, so okay",
            "",
            "                // [2] m >= 2",
            "                // im = ceil(2^64 / m)",
            "                // -> im * m = 2^64 + r (0 <= r < m)",
            "                // let z = a*b = c*m + d (0 <= c, d < m)",
            "                // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im",
            "                // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2",
            "                // ((ab * im) >> 64) == c or c + 1",
            "                unsigned long long z = a;",
            "                z *= b;",
            "#ifdef _MSC_VER",
            "                unsigned long long x;",
            "                _umul128(z, im, &x);",
            "#else",
            "                unsigned long long x =",
            "                    (unsigned long long)(((unsigned __int128)(z)*im) >> 64);",
            "#endif",
            "                unsigned long long y = x * _m;",
            "                return (unsigned int)(z - y + (z < y ? _m : 0));",
            "            }",
            "        };",
            "",
            "        // @param n `0 <= n`",
            "        // @param m `1 <= m`",
            "        // @return `(x ** n) % m`",
            "        constexpr long long pow_mod_constexpr(long long x, long long n, int m)",
            "        {",
            "            if (m == 1)",
            "                return 0;",
            "            unsigned int _m = (unsigned int)(m);",
            "            unsigned long long r = 1;",
            "            unsigned long long y = safe_mod(x, m);",
            "            while (n)",
            "            {",
            "                if (n & 1)",
            "                    r = (r * y) % _m;",
            "                y = (y * y) % _m;",
            "                n >>= 1;",
            "            }",
            "            return r;",
            "        }",
            "",
            "        // Reference:",
            "        // M. Forisek and J. Jancina,",
            "        // Fast Primality Testing for Integers That Fit into a Machine Word",
            "        // @param n `0 <= n`",
            "        constexpr bool is_prime_constexpr(int n)",
            "        {",
            "            if (n <= 1)",
            "                return false;",
            "            if (n == 2 || n == 7 || n == 61)",
            "                return true;",
            "            if (n % 2 == 0)",
            "                return false;",
            "            long long d = n - 1;",
            "            while (d % 2 == 0)",
            "                d /= 2;",
            "            constexpr long long bases[3] = {2, 7, 61};",
            "            for (long long a : bases)",
            "            {",
            "                long long t = d;",
            "                long long y = pow_mod_constexpr(a, t, n);",
            "                while (t != n - 1 && y != 1 && y != n - 1)",
            "                {",
            "                    y = y * y % n;",
            "                    t <<= 1;",
            "                }",
            "                if (y != n - 1 && t % 2 == 0)",
            "                {",
            "                    return false;",
            "                }",
            "            }",
            "            return true;",
            "        }",
            "        template <int n>",
            "        constexpr bool is_prime = is_prime_constexpr(n);",
            "",
            "        // @param b `1 <= b`",
            "        // @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g",
            "        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b)",
            "        {",
            "            a = safe_mod(a, b);",
            "            if (a == 0)",
            "                return {b, 0};",
            "",
            "            // Contracts:",
            "            // [1] s - m0 * a = 0 (mod b)",
            "            // [2] t - m1 * a = 0 (mod b)",
            "            // [3] s * |m1| + t * |m0| <= b",
            "            long long s = b, t = a;",
            "            long long m0 = 0, m1 = 1;",
            "",
            "            while (t)",
            "            {",
            "                long long u = s / t;",
            "                s -= t * u;",
            "                m0 -= m1 * u; // |m1 * u| <= |m1| * s <= b",
            "",
            "                // [3]:",
            "                // (s - t * u) * |m1| + t * |m0 - m1 * u|",
            "                // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)",
            "                // = s * |m1| + t * |m0| <= b",
            "",
            "                auto tmp = s;",
            "                s = t;",
            "                t = tmp;",
            "                tmp = m0;",
            "                m0 = m1;",
            "                m1 = tmp;",
            "            }",
            "            // by [3]: |m0| <= b/g",
            "            // by g != b: |m0| < b/g",
            "            if (m0 < 0)",
            "                m0 += b / s;",
            "            return {s, m0};",
            "        }",
            "",
            "        // Compile time primitive root",
            "        // @param m must be prime",
            "        // @return primitive root (and minimum in now)",
            "        constexpr int primitive_root_constexpr(int m)",
            "        {",
            "            if (m == 2)",
            "                return 1;",
            "            if (m == 167772161)",
            "                return 3;",
            "            if (m == 469762049)",
            "                return 3;",
            "            if (m == 754974721)",
            "                return 11;",
            "            if (m == 998244353)",
            "                return 3;",
            "            int divs[20] = {};",
            "            divs[0] = 2;",
            "            int cnt = 1;",
            "            int x = (m - 1) / 2;",
            "            while (x % 2 == 0)",
            "                x /= 2;",
            "            for (int i = 3; (long long)(i)*i <= x; i += 2)",
            "            {",
            "                if (x % i == 0)",
            "                {",
            "                    divs[cnt++] = i;",
            "                    while (x % i == 0)",
            "                    {",
            "                        x /= i;",
            "                    }",
            "                }",
            "            }",
            "            if (x > 1)",
            "            {",
            "                divs[cnt++] = x;",
            "            }",
            "            for (int g = 2;; g++)",
            "            {",
            "                bool ok = true;",
            "                for (int i = 0; i < cnt; i++)",
            "                {",
            "                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1)",
            "                    {",
            "                        ok = false;",
            "                        break;",
            "                    }",
            "                }",
            "                if (ok)",
            "                    return g;",
            "            }",
            "        }",
            "        template <int m>",
            "        constexpr int primitive_root = primitive_root_constexpr(m);",
            "",
            "        // @param n `n < 2^32`",
            "        // @param m `1 <= m < 2^32`",
            "        // @return sum_{i=0}^{n-1} floor((ai + b) / m) (mod 2^64)",
            "        unsigned long long floor_sum_unsigned(unsigned long long n,",
            "                                              unsigned long long m,",
            "                                              unsigned long long a,",
            "                                              unsigned long long b)",
            "        {",
            "            unsigned long long ans = 0;",
            "            while (true)",
            "            {",
            "                if (a >= m)",
            "                {",
            "                    ans += n * (n - 1) / 2 * (a / m);",
            "                    a %= m;",
            "                }",
            "                if (b >= m)",
            "                {",
            "                    ans += n * (b / m);",
            "                    b %= m;",
            "                }",
            "",
            "                unsigned long long y_max = a * n + b;",
            "                if (y_max < m)",
            "                    break;",
            "                // y_max < m * (n + 1)",
            "                // floor(y_max / m) <= n",
            "                n = (unsigned long long)(y_max / m);",
            "                b = (unsigned long long)(y_max % m);",
            "                std::swap(m, a);",
            "            }",
            "            return ans;",
            "        }",
            "",
            "    } // namespace internal",
            "",
            "} // namespace atcoder",
            "namespace atcoder",
            "{",
            "",
            "    namespace internal",
            "    {",
            "",
            "#ifndef _MSC_VER",
            "        template <class T>",
            "        using is_signed_int128 =",
            "            typename std::conditional<std::is_same<T, __int128_t>::value ||",
            "                                          std::is_same<T, __int128>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_unsigned_int128 =",
            "            typename std::conditional<std::is_same<T, __uint128_t>::value ||",
            "                                          std::is_same<T, unsigned __int128>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using make_unsigned_int128 =",
            "            typename std::conditional<std::is_same<T, __int128_t>::value,",
            "                                      __uint128_t,",
            "                                      unsigned __int128>;",
            "",
            "        template <class T>",
            "        using is_integral = typename std::conditional<std::is_integral<T>::value ||",
            "                                                          is_signed_int128<T>::value ||",
            "                                                          is_unsigned_int128<T>::value,",
            "                                                      std::true_type,",
            "                                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_signed_int = typename std::conditional<(is_integral<T>::value &&",
            "                                                         std::is_signed<T>::value) ||",
            "                                                            is_signed_int128<T>::value,",
            "                                                        std::true_type,",
            "                                                        std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_unsigned_int =",
            "            typename std::conditional<(is_integral<T>::value &&",
            "                                       std::is_unsigned<T>::value) ||",
            "                                          is_unsigned_int128<T>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using to_unsigned = typename std::conditional<",
            "            is_signed_int128<T>::value,",
            "            make_unsigned_int128<T>,",
            "            typename std::conditional<std::is_signed<T>::value,",
            "                                      std::make_unsigned<T>,",
            "                                      std::common_type<T>>::type>::type;",
            "",
            "#else",
            "",
            "        template <class T>",
            "        using is_integral = typename std::is_integral<T>;",
            "",
            "        template <class T>",
            "        using is_signed_int =",
            "            typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_unsigned_int =",
            "            typename std::conditional<is_integral<T>::value &&",
            "                                          std::is_unsigned<T>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using to_unsigned = typename std::conditional<is_signed_int<T>::value,",
            "                                                      std::make_unsigned<T>,",
            "                                                      std::common_type<T>>::type;",
            "",
            "#endif",
            "",
            "        template <class T>",
            "        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
            "",
            "        template <class T>",
            "        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
            "",
            "        template <class T>",
            "        using to_unsigned_t = typename to_unsigned<T>::type;",
            "",
            "    } // namespace internal",
            "",
            "} // namespace atcoder",
            "namespace atcoder",
            "{",
            "",
            "    namespace internal",
            "    {",
            "",
            "        struct modint_base",
            "        {",
            "        };",
            "        struct static_modint_base : modint_base",
            "        {",
            "        };",
            "",
            "        template <class T>",
            "        using is_modint = std::is_base_of<modint_base, T>;",
            "        template <class T>",
            "        using is_modint_t = std::enable_if_t<is_modint<T>::value>;",
            "",
            "    } // namespace internal",
            "",
            "    template <int m, std::enable_if_t<(1 <= m)> * = nullptr>",
            "    struct static_modint : internal::static_modint_base",
            "    {",
            "        using mint = static_modint;",
            "",
            "    public:",
            "        static constexpr int mod() { return m; }",
            "        static mint raw(int v)",
            "        {",
            "            mint x;",
            "            x._v = v;",
            "            return x;",
            "        }",
            "",
            "        static_modint() : _v(0) {}",
            "        template <class T, internal::is_signed_int_t<T> * = nullptr>",
            "        static_modint(T v)",
            "        {",
            "            long long x = (long long)(v % (long long)(umod()));",
            "            if (x < 0)",
            "                x += umod();",
            "            _v = (unsigned int)(x);",
            "        }",
            "        template <class T, internal::is_unsigned_int_t<T> * = nullptr>",
            "        static_modint(T v)",
            "        {",
            "            _v = (unsigned int)(v % umod());",
            "        }",
            "",
            "        unsigned int val() const { return _v; }",
            "",
            "        mint &operator++()",
            "        {",
            "            _v++;",
            "            if (_v == umod())",
            "                _v = 0;",
            "            return *this;",
            "        }",
            "        mint &operator--()",
            "        {",
            "            if (_v == 0)",
            "                _v = umod();",
            "            _v--;",
            "            return *this;",
            "        }",
            "        mint operator++(int)",
            "        {",
            "            mint result = *this;",
            "            ++*this;",
            "            return result;",
            "        }",
            "        mint operator--(int)",
            "        {",
            "            mint result = *this;",
            "            --*this;",
            "            return result;",
            "        }",
            "",
            "        mint &operator+=(const mint &rhs)",
            "        {",
            "            _v += rhs._v;",
            "            if (_v >= umod())",
            "                _v -= umod();",
            "            return *this;",
            "        }",
            "        mint &operator-=(const mint &rhs)",
            "        {",
            "            _v -= rhs._v;",
            "            if (_v >= umod())",
            "                _v += umod();",
            "            return *this;",
            "        }",
            "        mint &operator*=(const mint &rhs)",
            "        {",
            "            unsigned long long z = _v;",
            "            z *= rhs._v;",
            "            _v = (unsigned int)(z % umod());",
            "            return *this;",
            "        }",
            "        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "",
            "        mint operator+() const { return *this; }",
            "        mint operator-() const { return mint() - *this; }",
            "",
            "        mint pow(long long n) const",
            "        {",
            "            assert(0 <= n);",
            "            mint x = *this, r = 1;",
            "            while (n)",
            "            {",
            "                if (n & 1)",
            "                    r *= x;",
            "                x *= x;",
            "                n >>= 1;",
            "            }",
            "            return r;",
            "        }",
            "        mint inv() const",
            "        {",
            "            if (prime)",
            "            {",
            "                assert(_v);",
            "                return pow(umod() - 2);",
            "            }",
            "            else",
            "            {",
            "                auto eg = internal::inv_gcd(_v, m);",
            "                assert(eg.first == 1);",
            "                return eg.second;",
            "            }",
            "        }",
            "",
            "        friend mint operator+(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) += rhs;",
            "        }",
            "        friend mint operator-(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) -= rhs;",
            "        }",
            "        friend mint operator*(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) *= rhs;",
            "        }",
            "        friend mint operator/(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) /= rhs;",
            "        }",
            "        friend bool operator==(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v == rhs._v;",
            "        }",
            "        friend bool operator!=(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v != rhs._v;",
            "        }",
            "",
            "    private:",
            "        unsigned int _v;",
            "        static constexpr unsigned int umod() { return m; }",
            "        static constexpr bool prime = internal::is_prime<m>;",
            "    };",
            "",
            "    template <int id>",
            "    struct dynamic_modint : internal::modint_base",
            "    {",
            "        using mint = dynamic_modint;",
            "",
            "    public:",
            "        static int mod() { return (int)(bt.umod()); }",
            "        static void set_mod(int m)",
            "        {",
            "            assert(1 <= m);",
            "            bt = internal::barrett(m);",
            "        }",
            "        static mint raw(int v)",
            "        {",
            "            mint x;",
            "            x._v = v;",
            "            return x;",
            "        }",
            "",
            "        dynamic_modint() : _v(0) {}",
            "        template <class T, internal::is_signed_int_t<T> * = nullptr>",
            "        dynamic_modint(T v)",
            "        {",
            "            long long x = (long long)(v % (long long)(mod()));",
            "            if (x < 0)",
            "                x += mod();",
            "            _v = (unsigned int)(x);",
            "        }",
            "        template <class T, internal::is_unsigned_int_t<T> * = nullptr>",
            "        dynamic_modint(T v)",
            "        {",
            "            _v = (unsigned int)(v % mod());",
            "        }",
            "",
            "        unsigned int val() const { return _v; }",
            "",
            "        mint &operator++()",
            "        {",
            "            _v++;",
            "            if (_v == umod())",
            "                _v = 0;",
            "            return *this;",
            "        }",
            "        mint &operator--()",
            "        {",
            "            if (_v == 0)",
            "                _v = umod();",
            "            _v--;",
            "            return *this;",
            "        }",
            "        mint operator++(int)",
            "        {",
            "            mint result = *this;",
            "            ++*this;",
            "            return result;",
            "        }",
            "        mint operator--(int)",
            "        {",
            "            mint result = *this;",
            "            --*this;",
            "            return result;",
            "        }",
            "",
            "        mint &operator+=(const mint &rhs)",
            "        {",
            "            _v += rhs._v;",
            "            if (_v >= umod())",
            "                _v -= umod();",
            "            return *this;",
            "        }",
            "        mint &operator-=(const mint &rhs)",
            "        {",
            "            _v += mod() - rhs._v;",
            "            if (_v >= umod())",
            "                _v -= umod();",
            "            return *this;",
            "        }",
            "        mint &operator*=(const mint &rhs)",
            "        {",
            "            _v = bt.mul(_v, rhs._v);",
            "            return *this;",
            "        }",
            "        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "",
            "        mint operator+() const { return *this; }",
            "        mint operator-() const { return mint() - *this; }",
            "",
            "        mint pow(long long n) const",
            "        {",
            "            assert(0 <= n);",
            "            mint x = *this, r = 1;",
            "            while (n)",
            "            {",
            "                if (n & 1)",
            "                    r *= x;",
            "                x *= x;",
            "                n >>= 1;",
            "            }",
            "            return r;",
            "        }",
            "        mint inv() const",
            "        {",
            "            auto eg = internal::inv_gcd(_v, mod());",
            "            assert(eg.first == 1);",
            "            return eg.second;",
            "        }",
            "",
            "        friend mint operator+(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) += rhs;",
            "        }",
            "        friend mint operator-(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) -= rhs;",
            "        }",
            "        friend mint operator*(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) *= rhs;",
            "        }",
            "        friend mint operator/(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) /= rhs;",
            "        }",
            "        friend bool operator==(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v == rhs._v;",
            "        }",
            "        friend bool operator!=(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v != rhs._v;",
            "        }",
            "",
            "    private:",
            "        unsigned int _v;",
            "        static internal::barrett bt;",
            "        static unsigned int umod() { return bt.umod(); }",
            "    };",
            "    template <int id>",
            "    internal::barrett dynamic_modint<id>::bt(998244353);",
            "",
            "    using modint998244353 = static_modint<998244353>;",
            "    using modint1000000007 = static_modint<1000000007>;",
            "    using modint = dynamic_modint<-1>;",
            "",
            "    namespace internal",
            "    {",
            "",
            "        template <class T>",
            "        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;",
            "",
            "        template <class T>",
            "        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;",
            "",
            "        template <class>",
            "        struct is_dynamic_modint : public std::false_type",
            "        {",
            "        };",
            "        template <int id>",
            "        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type",
            "        {",
            "        };",
            "",
            "        template <class T>",
            "        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;",
            "",
            "    } // namespace internal",
            "",
            "} // namespace atcoder",
            "",
            "using mint = atcoder::dynamic_modint<-1>;",
            "// mint::set_mod(variable_mod)"
        ],
        "description": "Snippet for mod_int_variable (waifu version)"
    },
    "template_waifu_mod_int": {
        "prefix": "template_waifu_mod_int",
        "body": [
            "template <const int &MOD>",
            "struct modular_int",
            "{",
            "    int val;",
            "",
            "    modular_int(int64_t v = 0)",
            "    {",
            "        if (v < 0)",
            "            v = v % MOD + MOD;",
            "        if (v >= MOD)",
            "            v %= MOD;",
            "        val = int(v);",
            "    }",
            "",
            "    modular_int(uint64_t v)",
            "    {",
            "        if (v >= MOD)",
            "            v %= MOD;",
            "        val = int(v);",
            "    }",
            "",
            "    modular_int(int v) : modular_int(int64_t(v)) {}",
            "    modular_int(unsigned v) : modular_int(uint64_t(v)) {}",
            "",
            "    explicit operator int() const { return val; }",
            "    explicit operator unsigned() const { return val; }",
            "    explicit operator int64_t() const { return val; }",
            "    explicit operator uint64_t() const { return val; }",
            "    explicit operator double() const { return val; }",
            "    explicit operator long double() const { return val; }",
            "",
            "    modular_int &operator+=(const modular_int &other)",
            "    {",
            "        val -= MOD - other.val;",
            "        if (val < 0)",
            "            val += MOD;",
            "        return *this;",
            "    }",
            "",
            "    modular_int &operator-=(const modular_int &other)",
            "    {",
            "        val -= other.val;",
            "        if (val < 0)",
            "            val += MOD;",
            "        return *this;",
            "    }",
            "",
            "    static unsigned fast_mod(uint64_t x, unsigned m = MOD)",
            "    {",
            "#if !defined(_WIN32) || defined(_WIN64)",
            "        return unsigned(x % m);",
            "#endif",
            "        // Optimized mod for Codeforces 32-bit machines.",
            "        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.",
            "        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);",
            "        unsigned quot, rem;",
            "        asm(\"divl %4\\\\n\"",
            "            : \"=a\"(quot), \"=d\"(rem)",
            "            : \"d\"(x_high), \"a\"(x_low), \"r\"(m));",
            "        return rem;",
            "    }",
            "",
            "    modular_int &operator*=(const modular_int &other)",
            "    {",
            "        val = fast_mod(uint64_t(val) * other.val);",
            "        return *this;",
            "    }",
            "",
            "    modular_int &operator/=(const modular_int &other)",
            "    {",
            "        return *this *= other.inv();",
            "    }",
            "",
            "    friend modular_int operator+(const modular_int &a, const modular_int &b) { return modular_int(a) += b; }",
            "    friend modular_int operator-(const modular_int &a, const modular_int &b) { return modular_int(a) -= b; }",
            "    friend modular_int operator*(const modular_int &a, const modular_int &b) { return modular_int(a) *= b; }",
            "    friend modular_int operator/(const modular_int &a, const modular_int &b) { return modular_int(a) /= b; }",
            "",
            "    modular_int &operator++()",
            "    {",
            "        val = val == MOD - 1 ? 0 : val + 1;",
            "        return *this;",
            "    }",
            "",
            "    modular_int &operator--()",
            "    {",
            "        val = val == 0 ? MOD - 1 : val - 1;",
            "        return *this;",
            "    }",
            "",
            "    modular_int operator++(int)",
            "    {",
            "        modular_int before = *this;",
            "        ++*this;",
            "        return before;",
            "    }",
            "    modular_int operator--(int)",
            "    {",
            "        modular_int before = *this;",
            "        --*this;",
            "        return before;",
            "    }",
            "",
            "    modular_int operator-() const",
            "    {",
            "        return val == 0 ? 0 : MOD - val;",
            "    }",
            "",
            "    friend bool operator==(const modular_int &a, const modular_int &b) { return a.val == b.val; }",
            "    friend bool operator!=(const modular_int &a, const modular_int &b) { return a.val != b.val; }",
            "    friend bool operator<(const modular_int &a, const modular_int &b) { return a.val < b.val; }",
            "    friend bool operator>(const modular_int &a, const modular_int &b) { return a.val > b.val; }",
            "    friend bool operator<=(const modular_int &a, const modular_int &b) { return a.val <= b.val; }",
            "    friend bool operator>=(const modular_int &a, const modular_int &b) { return a.val >= b.val; }",
            "",
            "    static const int SAVE_INV = int(1e6) + 5;",
            "    static modular_int save_inv[SAVE_INV];",
            "",
            "    static void prepare_inv()",
            "    {",
            "        // Ensures that MOD is prime, which is necessary for the inverse algorithm below.",
            "        for (int64_t p = 2; p * p <= MOD; p += p % 2 + 1)",
            "            assert(MOD % p != 0);",
            "",
            "        save_inv[0] = 0;",
            "        save_inv[1] = 1;",
            "",
            "        for (int i = 2; i < SAVE_INV; i++)",
            "            save_inv[i] = save_inv[MOD % i] * (MOD - MOD / i);",
            "    }",
            "",
            "    modular_int inv() const",
            "    {",
            "        if (save_inv[1] == 0)",
            "            prepare_inv();",
            "",
            "        if (val < SAVE_INV)",
            "            return save_inv[val];",
            "",
            "        modular_int product = 1;",
            "        int v = val;",
            "",
            "        do",
            "        {",
            "            product *= MOD - MOD / v;",
            "            v = MOD % v;",
            "        } while (v >= SAVE_INV);",
            "",
            "        return product * save_inv[v];",
            "    }",
            "",
            "    modular_int pow(int64_t p) const",
            "    {",
            "        if (p < 0)",
            "            return inv().pow(-p);",
            "",
            "        modular_int a = *this, result = 1;",
            "",
            "        while (p > 0)",
            "        {",
            "            if (p & 1)",
            "                result *= a;",
            "",
            "            p >>= 1;",
            "",
            "            if (p > 0)",
            "                a *= a;",
            "        }",
            "",
            "        return result;",
            "    }",
            "",
            "    friend ostream &operator<<(ostream &os, const modular_int &m)",
            "    {",
            "        return os << m.val;",
            "    }",
            "};",
            "template <const int &MOD>",
            "modular_int<MOD> modular_int<MOD>::save_inv[modular_int<MOD>::SAVE_INV];",
            "const int MOD = 998244353;",
            "using mint = modular_int<MOD>;",
            "void __print(mint x) { cerr << x; }"
        ],
        "description": "Snippet for mod_int (waifu version)"
    },
    "template_waifu_combinatorics": {
        "prefix": "template_waifu_combinatorics",
        "body": [
            "template<typename T, const int P>",
            "class combinatorics",
            "{",
            "public:",
            "    int n;",
            "    vector<T> inv, fac, ifac, pw;",
            "    combinatorics (int n) : n(n), inv(n), fac(n), ifac(n), pw(n)",
            "    {",
            "        fac[0] = inv[0] = ifac[0] = pw[0] = T(1);",
            " ",
            "        for(int i = 1; i <= n; i ++)",
            "            inv[i] = T(1)/T(i), fac[i] = fac[i - 1] * T(i), ifac[i] = ifac[i - 1] * inv[i], pw[i] = pw[i - 1] * T(P);",
            "    }",
            "",
            "    T ncr(int n, int r)",
            "    {",
            "        if(n < r or r < 0)",
            "            return 0;",
            "        return fac[n] * ifac[r] * ifac[n - r];",
            "    }",
            "};"
        ],
        "description": "Snippet for combinatorics (waifu version)"
    },
    "template_waifu_convex_hull_trick": {
        "prefix": "template_waifu_convex_hull_trick",
        "body": [
            "class cht_chan",
            "{",
            "public:",
            "    /*",
            "        tc: O(log(n)) per insertion amortized, O(log(n)) per query",
            "        ml: O(n)",
            "",
            "        info:",
            "            1. inserts lines of form Ax + B",
            "            2. returns inserted line with maximum value of Ax + B for queried x ",
            "    */",
            "\tstatic const int64_t INF=1e18;",
            "\tstruct Line",
            "\t{",
            "\t\tint64_t a, b; //y = ax + b",
            "\t\tdouble xLeft; //Stores the llersection wiith previous line in the convex hull. First line has -INF",
            "",
            "\t\tenum Type {line, maxQuery, minQuery} type;",
            "\t\tint64_t val;",
            "",
            "\t\texplicit Line(int64_t aa=0, int64_t bb=0): a(aa), b(bb), xLeft(-INF), type(Type::line), val(0) {}",
            "",
            "\t\tint64_t valueAt(int64_t x) const",
            "\t\t{",
            "\t\t\treturn a*x + b;",
            "\t\t}",
            "\t\tfriend bool isParallel(const Line &l1, const Line &l2)",
            "\t\t{",
            "\t\t\treturn l1.a == l2.a;",
            "\t\t}",
            "\t\tfriend double llersectX(const Line &l1, const Line &l2)",
            "\t\t{",
            "\t\t\treturn isParallel(l1, l2)?INF:1.0*(l2.b-l1.b)/(l1.a-l2.a);",
            "\t\t}",
            "\t\tbool operator<(const Line& l2) const",
            "\t\t{",
            "\t\t\tif(l2.type == line)",
            "\t\t\t\treturn this->a < l2.a;",
            "\t\t\tif(l2.type == maxQuery)",
            "\t\t\t\treturn this->xLeft < l2.val;",
            "\t\t\tif(l2.type == minQuery)",
            "\t\t\t\treturn this->xLeft > l2.val;",
            "            return 0;",
            "\t\t}",
            "\t};",
            "",
            "\tbool isMax;",
            "\tset<Line> hull;",
            "",
            "\tbool hasPrev(set<Line>::iterator it)",
            "\t{",
            "\t\treturn it!=hull.begin();",
            "\t}\t",
            "\tbool hasNext(set<Line>::iterator it)",
            "\t{",
            "\t\treturn it!=hull.end() && next(it)!=hull.end();",
            "\t}",
            "\tbool irrelevant(const Line &l1, const Line &l2, const Line &l3)",
            "\t{",
            "\t\treturn llersectX(l1, l3) <= llersectX(l1, l2);",
            "\t}",
            "\tbool irrelevant(set<Line>::iterator it)",
            "\t{",
            "\t\treturn hasPrev(it) && hasNext(it) && ( ",
            "\t\t\t(isMax && irrelevant(*prev(it), *it, *next(it))) ",
            "\t\t\t|| (!isMax && irrelevant(*next(it), *it, *prev(it))));",
            "\t}",
            "\t//Updates xValue of line polled by it",
            "\tset<Line>::iterator updateLeftBorder(set<Line>::iterator it)",
            "\t{",
            "\t\tif(isMax && !hasPrev(it) || !isMax && !hasNext(it))",
            "\t\t\treturn it;",
            "\t\tdouble val=llersectX(*it, isMax?(*prev(it)):(*next(it)));",
            "\t\tLine temp(*it);",
            "\t\tit=hull.erase(it);",
            "\t\ttemp.xLeft=val;",
            "\t\tit=hull.insert(it, temp);",
            "\t\treturn it;",
            "\t}",
            "",
            "\texplicit cht_chan(bool isMax): isMax(isMax) {}",
            "",
            "\tvoid add_line(int64_t a, int64_t b) //Add ax + b in logN time",
            "\t{",
            "\t\tLine l3=Line(a, b);",
            "\t\tauto it=hull.lower_bound(l3);",
            "",
            "\t\t//If parallel liune is already in set, one of the lines becomes irrelevant",
            "\t\tif(it!=hull.end() && isParallel(*it, l3))",
            "\t\t{",
            "\t\t\tif(isMax && it->b<b || !isMax && it->b>b)",
            "\t\t\t\tit=hull.erase(it);",
            "\t\t\telse",
            "\t\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tit=hull.insert(it, l3);",
            "\t\tif(irrelevant(it))",
            "\t\t{",
            "\t\t\thull.erase(it);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\t//Remove lines which became irrelevant after inserting",
            "\t\twhile(hasPrev(it) && irrelevant(prev(it)))",
            "\t\t\thull.erase(prev(it));",
            "\t\twhile(hasNext(it) && irrelevant(next(it)))",
            "\t\t\thull.erase(next(it));",
            "",
            "\t\t//Update xLine",
            "\t\tit=updateLeftBorder(it);",
            "\t\tif(hasPrev(it))",
            "\t\t\tupdateLeftBorder(prev(it));",
            "\t\tif(hasNext(it))",
            "\t\t\tupdateLeftBorder(next(it));",
            "\t}",
            "",
            "\tint64_t get_opt(int64_t x)",
            "\t{",
            "\t\tLine q;",
            "\t\tq.val=x;",
            "\t\tq.type = isMax?Line::Type::maxQuery : Line::Type::minQuery;",
            "",
            "\t\tauto bestLine=hull.lower_bound(q);",
            "\t\tif(isMax)",
            "\t\t\t--bestLine;",
            "\t\treturn bestLine->valueAt(x);",
            "\t}",
            "};"
        ],
        "description": "Snippet for convex_hull_trick (waifu version)"
    },
    "template_waifu_manachers": {
        "prefix": "template_waifu_manachers",
        "body": [
            "template <typename T>",
            "vector<int> manachers_chan(const T &s)",
            "{",
            "    /*",
            "        tc: O(|s|)",
            "        mc: O(|s|)",
            "",
            "        info:",
            "            0-indexed",
            "            res[2 * i]  = odd RADIUS in position i",
            "            res[2 * i + 1] = even RADIUS between positions i and i + 1",
            "        ",
            "        ex:",
            "            s = \"abaa\" -> res = {0, 0, 1, 0, 0, 1, 0};",
            "        ",
            "        author notes:",
            "            in other words, for every z from 0 to 2 * n - 2:",
            "            calculate i = (z + 1) >> 1 and j = z >> 1",
            "            now there is a palindrome from i - res[z] to j + res[z]",
            "            (watch out for i > j and res[z] = 0)",
            "    */",
            "    int n = (int)s.size();",
            "    if (n == 0)",
            "        return vector<int>();",
            "        ",
            "    vector<int> res(2 * n - 1, 0);",
            "    int l = -1, r = -1;",
            "    for (int z = 0; z < 2 * n - 1; z ++)",
            "    {",
            "        int i = (z + 1) >> 1, j = z >> 1;",
            "        int p = (i >= r ? 0 : min(r - i, res[2 * (l + r) - z]));",
            "",
            "        while (j + p + 1 < n and i - p - 1 >= 0 and (s[j + p + 1] == s[i - p - 1]))",
            "            p ++;",
            "",
            "        if (j + p > r)",
            "            l = i - p, r = j + p;",
            "        res[z] = p;",
            "    }",
            "",
            "    return res;",
            "}"
        ],
        "description": "Snippet for manachers (waifu version)"
    },
    "template_waifu_trie": {
        "prefix": "template_waifu_trie",
        "body": [
            "template<const int C>",
            "class static_node_chan",
            "{",
            "public:",
            "    int sub = 0;",
            "    int leaf = 0;",
            "    array<int, C> next;",
            "};",
            "class dynamic_node_chan",
            "{",
            "public: ",
            "    int sub = 0;",
            "    int leaf = 0;",
            "    map<int, int> next;",
            "};",
            "",
            "template<typename S, typename T, typename I>",
            "class trie_chan",
            "{",
            "public:",
            "    int r = 0, p = 0;",
            "    vector<T> t;",
            "    I ind;",
            "",
            "    trie_chan(int n, I ind) : t(n), ind(ind) {};",
            "",
            "    void insert(const vector<S> &s)",
            "    {",
            "        int v = r;",
            "        for(auto x : s)",
            "        {",
            "            ++ t[v].sub;",
            "",
            "            int f = ind(x);",
            "         ",
            "            if(t[v].next[f] == 0)",
            "                t[v].next[f] = ++ p;",
            "            v = t[v].next[f];",
            "        }",
            "        ++ t[v].sub, ++ t[v].leaf;",
            "    }",
            "};"
        ],
        "description": "Snippet for trie (waifu version)"
    },
    "template_waifu_suffix_tree": {
        "prefix": "template_waifu_suffix_tree",
        "body": [
            "class suffix_tree_chan",
            "{",
            "    /*",
            "    tc: O(n)",
            "    mc: O(n)",
            "",
            "    info:",
            "        0 indexed",
            "        pass it 0 indexed suffix array and lcp array",
            "        constructs suffix tree with the following properties:",
            "            1. node i (< n) represents suffix i (length = n - 1)",
            "            2. for every suffix there exists node in the suffix tree (even if it has only child)",
            "            3. if u > v, then u cannot be in the subtree of v",
            "            4. adj[u] contains downward edges from node u, sorted lexicography in order of strings on their labels",
            "            5. `root` is root node",
            "            6. dep[u] contains length of path from root to node u, used for edge labels",
            "            7. rep[u] = some i such that leaf for suffix i is in subtree of u ",
            "            8. m is the total number of nodes in the suffix tree (so m - n is the number of new internal nodes)",
            "",
            "        warning:",
            "            sa gets modified so dont pass by reference",
            "    */",
            "public:",
            "    int n, m, root;",
            "    vector<int> dep, rep;",
            "    vector<vector<int>> adj;",
            "",
            "    suffix_tree_chan(int n, vector<int> sa, vector<int> lcp) : ",
            "    n(n), m(n), dep(2 * n + 1), rep(2 * n + 1), adj(2 * n + 1)",
            "    {",
            "        vector<int> l(n), r(n);",
            "        for(int i = 0; i < n; i ++) ",
            "            l[i] = r[i] = rep[i] = i, dep[i] = n - i;",
            "        ",
            "        vector<vector<int>> q(n);",
            "        for(int i = 0; i < n - 1; i ++)",
            "            q[lcp[i]].push_back(i);",
            "        ",
            "        for(int d = n - 1; d >= 0; d --)",
            "            for(auto i : q[d])",
            "            {",
            "                int u;",
            "                if(dep[sa[i]] == d)",
            "                    u = sa[i], adj[u].push_back(sa[i + 1]);",
            "                else if(dep[sa[i + 1]] == d)",
            "                    u = sa[i + 1], adj[u].push_back(sa[i]);",
            "                else",
            "                    u = m ++, rep[u] = rep[sa[i]], adj[u] = {sa[i], sa[i + 1]};",
            "                ",
            "                dep[u] = d;",
            "                l[r[i + 1]] = l[i], r[l[i]] = r[i + 1];",
            "                sa[l[i]] = sa[r[i + 1]] = u;",
            "            }",
            "",
            "        root = sa[0];",
            "        if(dep[root] != 0)",
            "            root = m ++, dep[root] = 0, adj[root] = {sa[0]};",
            "    };",
            "};"
        ],
        "description": "Snippet for suffix_tree (waifu version)"
    },
    "template_waifu_kmp": {
        "prefix": "template_waifu_kmp",
        "body": [
            "template <typename T>",
            "vector<int> kmp_table(const T &s)",
            "{",
            "    /*",
            "        tc: O(|s|)",
            "        mc: O(|s|)",
            "",
            "        info:",
            "            p[i] = longest suffix of substring s[0, 1, .. i] which is also a suffix ",
            "    */",
            "    int n = s.size();",
            "    vector<int> p(n, 0);",
            "    int k = 0;",
            "    for (int i = 1; i < n; i ++)",
            "    {",
            "        while (k > 0 && !(s[i] == s[k]))",
            "            k = p[k - 1];",
            "        if (s[i] == s[k])",
            "            k ++;",
            "        p[i] = k;",
            "    }",
            "    return p;",
            "}",
            "",
            "template <typename T>",
            "vector<int> kmp_search(const T &s, const T &w, const vector<int> &p)",
            "{",
            "    /*",
            "        tc: O(|s| + |w|)",
            "        mc: O(|w|)",
            "",
            "        info:",
            "            finds 0-indexed positions of occurences of s in w",
            "            p is kmp table of s",
            "    */",
            "    int n = s.size(), m = w.size();",
            "    assert(n >= 1 && (int)p.size() == n);",
            "    vector<int> res;",
            "    int k = 0;",
            "    for (int i = 0; i < m; i ++)",
            "    {",
            "        while (k > 0 && (k == n || !(w[i] == s[k])))",
            "            k = p[k - 1];",
            "        if (w[i] == s[k])",
            "            k ++;",
            "        if (k == n)",
            "            res.push_back(i - n + 1);",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Snippet for kmp (waifu version)"
    },
    "template_waifu_z": {
        "prefix": "template_waifu_z",
        "body": [
            "template <typename T>",
            "vector<int> z_chan(const T &s)",
            "{",
            "    int n = s.size();",
            "    vector<int> z(n, n);",
            "    int l = 0, r = 0;",
            "    for (int i = 1; i < n; i++)",
            "    {",
            "        z[i] = (i > r ? 0 : min(r - i + 1, z[i - l]));",
            "        while (i + z[i] < n && s[z[i]] == s[i + z[i]])",
            "            z[i]++;",
            "",
            "        if (i + z[i] - 1 > r)",
            "            l = i, r = i + z[i] - 1;",
            "    }",
            "    return z;",
            "}"
        ],
        "description": "Snippet for z (waifu version)"
    },
    "template_waifu_suffix_array": {
        "prefix": "template_waifu_suffix_array",
        "body": [
            "template <class T>",
            "array<vector<int>, 3> suffix_array_chan(const T &s, int max_num)",
            "{",
            "    /*",
            "        tc: O(|s|.log(|s|) + max_num)",
            "        mc: O(|s| + max_num)",
            "",
            "        info:",
            "            must pass s such that s[i] works as array index",
            "            returns {suffix array, inverse suffix array, lcp array}",
            "    */",
            "    int n = (int)size(s);",
            "    vector<int> sa(n), sa_inv(begin(s), end(s)), lcp(max(0, n - 1));",
            "    iota(begin(sa), end(sa), 0);",
            "    ",
            "    for (int ln = 0; ln < n; ln = max(1, 2 * ln))",
            "    {",
            "        vector<int> tmp(n), freq(max_num);",
            "        iota(begin(tmp), begin(tmp) + ln, n - ln);",
            "        copy_if(begin(sa), end(sa), begin(tmp) + ln, [&](int &x) { return (x -= ln) >= 0; });",
            "        for (int x : sa_inv)    freq[x]++;",
            "        ",
            "        partial_sum(begin(freq), end(freq), begin(freq));",
            "        for_each(rbegin(tmp), rend(tmp), [&](int x) { sa[--freq[sa_inv[x]]] = x; });",
            "        swap(sa_inv, tmp);",
            "        max_num = 1, sa_inv[sa[0]] = 0;",
            "        ",
            "        auto prev_inv = [&](int i) { return pair(tmp[i], i + ln < n ? tmp[i + ln] : -1); };",
            "        for (int i = 1; i < (n); i++)",
            "        {",
            "            max_num += prev_inv(sa[i - 1]) != prev_inv(sa[i]);",
            "            sa_inv[sa[i]] = max_num - 1;",
            "        }",
            "        if (max_num == n)",
            "            break;",
            "    }",
            "",
            "    int sz = 0;",
            "    for (int i = 0; i < (n); i++)",
            "    {",
            "        if (sz > 0)",
            "            sz--;",
            "        if (sa_inv[i] == 0)",
            "            continue;",
            "        for (int j = sa[sa_inv[i] - 1]; max(i, j) + sz < n && s[i + sz] == s[j + sz];)",
            "            sz++;",
            "        lcp[sa_inv[i] - 1] = sz;",
            "    }",
            "    return {sa, sa_inv, lcp};",
            "}"
        ],
        "description": "Snippet for suffix_array (waifu version)"
    },
    "template_waifu_mo": {
        "prefix": "template_waifu_mo",
        "body": [
            "template <const int B, const int mode = 1>",
            "class mo_chan",
            "{",
            "    /*",
            "        info:",
            "            - 0 indexed",
            "            - mode = 1 for the regular query order, mode = 2 for the fancier one",
            "        usage:",
            "            - one provides external add(array index)/delete(array index)/query(query index) functions  ",
            "            - naturally, you'll have to maintain the window aggregate externally too",
            "            - so for range sum queries, the external helpers are:",
            "                int64_t sum = 0;",
            "                auto add = [&](int i) -> void",
            "                {",
            "                    sum += a[i];",
            "                };",
            "                auto rem = [&](int i) -> void",
            "                {",
            "                    sum -= a[i];",
            "                };",
            "                vector<int64_t> ans(q);",
            "                auto query = [&](int i) -> void",
            "                {",
            "                    ans[i] = sum;",
            "                };",
            "    */",
            "public:",
            "    int n, q;",
            "    vector<array<int, 3>> qr;",
            "",
            "    mo_chan(int n, const vector<pair<int, int>> &queries) : n(n), q(queries.size()) ",
            "    {",
            "        for(int i = 0; i < q; i ++)",
            "        {",
            "            auto [l, r] = queries[i];",
            "            qr.push_back({l, r, i});",
            "        }",
            "",
            "        auto lmb1 = [&](array<int, 3> a, array<int, 3> b) -> bool",
            "        {",
            "            a[0] /= B, b[0] /= B;",
            "            return a < b;",
            "        };",
            "        auto lmb2 = [&](array<int, 3> a, array<int, 3> b) -> bool",
            "        {",
            "            a[0] /= B, b[0] /= B;",
            "            if(a[0] == b[0])",
            "            {",
            "                if(a[0] & 1)",
            "                    return a[1] > b[1];",
            "                else",
            "                    return b[1] > a[1];",
            "            }",
            "            return a[0] < b[0];",
            "        };",
            "        ",
            "        if(mode == 1)",
            "            sort(qr.begin(), qr.end(), lmb1);",
            "        else",
            "            sort(qr.begin(), qr.end(), lmb2);",
            "    };",
            "",
            "    void process(auto add, auto rem, auto query)",
            "    {",
            "        int l = 0, r = -1;",
            "        for(auto [nl, nr, qi] : qr)",
            "        {",
            "            while(l > nl)",
            "                add(-- l);",
            "            while(r < nr)",
            "                add(++ r);",
            "            while(l < nl)",
            "                rem(l ++);",
            "            while(r > nr)",
            "                rem(r --);",
            "            query(qi);",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet for mo (waifu version)"
    },
    "template_waifu_sparse_table": {
        "prefix": "template_waifu_sparse_table",
        "body": [
            "template <typename T>",
            "class sparse_table_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<vector<T>> mat;",
            "    sparse_table_chan(const vector<T> &a)",
            "    {",
            "        n = a.size();",
            "        int max_log = 32 - __builtin_clz(n);",
            "        mat.resize(max_log);",
            "        mat[0] = a;",
            "        for (int j = 1; j < max_log; j++)",
            "        {",
            "            mat[j].resize(n - (1 << j) + 1);",
            "            for (int i = 0; i <= n - (1 << j); i++)",
            "                mat[j][i] = mat[j - 1][i].unite(mat[j - 1][i + (1 << (j - 1))]);",
            "        }",
            "    }",
            "    T query(int from, int to) const",
            "    {",
            "        assert(0 <= from && from <= to && to <= n - 1);",
            "        int lg = 32 - __builtin_clz(to - from + 1) - 1;",
            "        return mat[lg][from].unite(mat[lg][to - (1 << lg) + 1]);",
            "    }",
            "};"
        ],
        "description": "Snippet for sparse_table (waifu version)"
    },
    "template_waifu_block_decomposition": {
        "prefix": "template_waifu_block_decomposition",
        "body": [
            "class element_chan",
            "{",
            "public:",
            "};",
            "class block_chan",
            "{",
            "public:",
            "};",
            "",
            "template<typename E, typename T, const int B>",
            "class block_decomposition_chan",
            "{",
            "    /*",
            "        info:",
            "            - 0 indexed",
            "            - E is the type of elements in the array",
            "            - T is the type of the blocks ",
            "            - B is the block size",
            "            - when passing in vector<E> (length = n) and vector<T>, make sure to have the size of vector<T> be at least ceil(n/B)",
            "            - for several queries, using process() will be rather awkward, so just implement your own external function  ",
            "    */",
            "public:",
            "    int ceil_div(int x, int y)",
            "    {",
            "        return (x + y - 1)/y;",
            "    }",
            "    int block_id(int i)",
            "    {",
            "        return i/B;",
            "    }",
            "    int lb(int bid)",
            "    {",
            "        return bid * B;",
            "    }",
            "    int rb(int bid)",
            "    {",
            "        return min(n, (bid + 1) * B - 1);",
            "    }",
            "",
            "public:",
            "    int n;",
            "    vector<E> element;",
            "    vector<T> block;",
            "",
            "    block_decomposition_chan(int n, vector<E> a, vector<T> b) : n(n), element(a), block(b)",
            "    {",
            "    };",
            "",
            "    void process(int l, int r, auto block_brute, auto block_quick)",
            "    {",
            "        assert(1 <= l and l <= r and r <= n);",
            "        int bl = block_id(l), br = block_id(r);",
            "        if(bl == br)",
            "            block_brute(l, r);",
            "        else",
            "        {",
            "            block_brute(l, rb(bl));",
            "            for(int b = bl + 1; b < br; b ++)",
            "                block_quick(b);",
            "            block_brute(lb(br), r);",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet for block_decomposition (waifu version)"
    },
    "template_waifu_monoid_stack": {
        "prefix": "template_waifu_monoid_stack",
        "body": [
            "template<typename T>",
            "class monoid_stack_chan",
            "{",
            "public:",
            "    vector<pair<T, T>> stk;",
            "    int size()",
            "    {",
            "        return stk.size();",
            "    }",
            "",
            "    bool empty()",
            "    {",
            "        return stk.empty();",
            "    }",
            "",
            "    void push(T x)",
            "    {",
            "        stk.push_back({x, x.unite(sum())});",
            "    }",
            "",
            "    void pop()",
            "    {",
            "        assert(!stk.empty());",
            "        stk.pop_back();",
            "    }",
            "",
            "    T top()",
            "    {",
            "        assert(!stk.empty());",
            "        return stk.back().first;",
            "    }",
            "",
            "    T sum(int i = -1)",
            "    {",
            "        if(i == -1) ",
            "            i = size() - 1;",
            "        if(i == -1)",
            "            return T();",
            "        return stk[i].second;",
            "    }",
            "",
            "    void rswap(monoid_stack_chan &other)",
            "    {",
            "        swap(stk, other.stk);",
            "    }",
            "};"
        ],
        "description": "Snippet for monoid_stack (waifu version)"
    },
    "template_waifu_monoid_deque": {
        "prefix": "template_waifu_monoid_deque",
        "body": [
            "template<template<typename> typename S, typename T>",
            "class monoid_deque_chan",
            "{",
            "public:",
            "    S<T> l, r, t;",
            "",
            "    int size()",
            "    {",
            "        return l.size() + r.size();",
            "    }",
            "    bool empty()",
            "    {",
            "        return (l.empty() and r.empty());",
            "    }",
            "",
            "    void rebalance()",
            "    {",
            "        bool f = false;",
            "",
            "        if(r.empty())",
            "            f = true, l.rswap(r);",
            "        ",
            "        int sz = r.size() / 2;",
            "        while(sz -- )",
            "            t.push(r.top()), r.pop();",
            "        while(!r.empty())",
            "            l.push(r.top()), r.pop();",
            "        while(!t.empty())",
            "            r.push(t.top()), t.pop();",
            "        ",
            "        if(f)",
            "            l.rswap(r);",
            "    }",
            "",
            "    void push_front(T x)",
            "    {",
            "        l.push(x);",
            "    }",
            "    void push_back(T x)",
            "    {",
            "        r.push(x);",
            "    }",
            "",
            "    void pop_front()",
            "    {",
            "        assert(!empty());",
            "        if(l.empty())",
            "            rebalance();",
            "        l.pop();",
            "    }",
            "    void pop_back()",
            "    {",
            "        assert(!empty());",
            "        if(r.empty())",
            "            rebalance();",
            "        r.pop();",
            "    }",
            "",
            "    T sum()",
            "    {",
            "        return l.sum().unite(r.sum());",
            "    }",
            "",
            "    T front()",
            "    {",
            "        assert(!empty());",
            "        if(l.empty())   ",
            "            rebalance();",
            "        return l.top();",
            "    }",
            "    ",
            "    T back()",
            "    {",
            "        assert(!empty());",
            "        if(r.empty())",
            "            return l.top(0);",
            "        return r.top();",
            "    }",
            "",
            "    void rswap(monoid_deque_chan &other)",
            "    {",
            "        l.rswap(other.l);",
            "        r.rswap(other.r);",
            "        t.rswap(other.t);",
            "    }",
            "};"
        ],
        "description": "Snippet for monoid_deque (waifu version)"
    },
    "template_waifu_dsu": {
        "prefix": "template_waifu_dsu",
        "body": [
            "class dsu_chan",
            "{",
            "    /*",
            "        tc: ",
            "            O(n a(n)) amortized",
            "            O(n log(n)) for rollbackable",
            "",
            "        info:",
            "            par[u] stores leader of u",
            "            siz[u] stores size of component with leader u",
            "",
            "        modify:",
            "            to make rollbackable, we do not make modifications in get() [which makes the get() function O(log(N))] ",
            "            and store change info in unite()",
            "    */",
            "public:",
            "    int n;",
            "    vector<int> par;",
            "    vector<int> siz;",
            "    dsu_chan(int n) : n(n), par(n), siz(n, 1)",
            "    {",
            "        iota(par.begin(), par.end(), 0);",
            "    };",
            "    ",
            "    int get(int x)",
            "    {",
            "        return (par[x] == x ? x : par[x] = get(par[x]));",
            "    }",
            "",
            "    void unite(int x, int y)",
            "    {",
            "        x = get(x), y = get(y);",
            "        if(x == y)",
            "            return;",
            "        if(siz[x] > siz[y]) swap(x, y);",
            "        par[x] = y, siz[y] += siz[x];",
            "    }",
            "",
            "    vector<vector<int>> group()",
            "    {",
            "        vector<vector<int>> g(n);",
            "        for(int u = 0; u < n; u ++)",
            "            g[get(u)].push_back(u);",
            "        return g;",
            "    }",
            "};"
        ],
        "description": "Snippet for dsu (waifu version)"
    },
    "template_waifu_fenwick_tree": {
        "prefix": "template_waifu_fenwick_tree",
        "body": [
            "class node_chan",
            "{",
            "public:",
            "    int v = 0;",
            "",
            "    inline void operator+=(node_chan &other)",
            "    {",
            "        v += other.v;",
            "    }",
            "    inline bool operator<(node_chan &other)",
            "    {",
            "        return v < other.v;",
            "    }",
            "};",
            "template <typename T>",
            "class fenwick_tree_chan",
            "{",
            "public:",
            "    vector<T> fenw;",
            "    int n;",
            "    int pw;",
            "",
            "    fenwick_tree_chan() : n(0) {}",
            "    fenwick_tree_chan(int n) : n(n)",
            "    {",
            "        fenw.resize(n);",
            "        pw = (n == 0 ? 0 : 1ULL << (63 - __builtin_clzll(unsigned(n))));",
            "    }",
            "",
            "    // a[x] += v;",
            "    void modify(int x, T v)",
            "    {",
            "        assert(0 <= x && x < n);",
            "        while (x < n)",
            "        {",
            "            fenw[x] += v;",
            "            x |= x + 1;",
            "        }",
            "    }",
            "",
            "    /// sum of prefix [0, .. x] ",
            "    T query(int x)",
            "    {",
            "        ++ x;",
            "        assert(0 <= x && x <= n);",
            "        T v{};",
            "        while (x > 0)",
            "        {",
            "            v += fenw[x - 1];",
            "            x &= x - 1;",
            "        }",
            "        return v;",
            "    }",
            "",
            "    // Returns the length of the longest prefix (0 indexed) with sum <= c",
            "    int max_prefix(T c)",
            "    {",
            "        T v{};",
            "        int at = 0;",
            "        for (int len = pw; len > 0; len >>= 1)",
            "        {",
            "            if (at + len <= n)",
            "            {",
            "                auto nv = v;",
            "                nv += fenw[at + len - 1];",
            "                if (!(c < nv))",
            "                {",
            "                    v = nv;",
            "                    at += len;",
            "                }",
            "            }",
            "        }",
            "        assert(0 <= at && at <= n);",
            "        return at;",
            "    }",
            "};"
        ],
        "description": "Snippet for fenwick_tree (waifu version)"
    },
    "template_waifu_disjoint_sparse_table": {
        "prefix": "template_waifu_disjoint_sparse_table",
        "body": [
            "template <typename T>",
            "class disjoint_sparse_table_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<vector<T>> mat;",
            "",
            "    disjoint_sparse_table_chan(const vector<T> &a)",
            "    {",
            "        n = static_cast<int>(a.size());",
            "        mat.push_back(a);",
            "        for (int p = 1; (1 << p) < n; p++)",
            "        {",
            "            mat.emplace_back(n);",
            "            for (int mid = 1 << p; mid < n; mid += 1 << (p + 1))",
            "            {",
            "                mat[p][mid - 1] = a[mid - 1];",
            "                for (int j = mid - 2; j >= mid - (1 << p); j--)",
            "                    mat[p][j] = a[j].unite(mat[p][j + 1]);",
            "                mat[p][mid] = a[mid];",
            "                for (int j = mid + 1; j < min(n, mid + (1 << p)); j++)",
            "                    mat[p][j] = mat[p][j - 1].unite(a[j]);",
            "            }",
            "        }",
            "    }",
            "",
            "    T query(int l, int r) const",
            "    {",
            "        assert(0 <= l && l < r && r <= n);",
            "        if (r - l == 1)",
            "            return mat[0][l];",
            "        int p = bit_width(unsigned(l ^ (r - 1))) - 1;",
            "        return mat[p][l].unite(mat[p][r - 1]);",
            "    }",
            "};"
        ],
        "description": "Snippet for disjoint_sparse_table (waifu version)"
    },
    "template_waifu_offline_deletion": {
        "prefix": "template_waifu_offline_deletion",
        "body": [
            "template<typename T, typename Q, typename D>",
            "class offline_deletion_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<Q> ans;",
            "    vector<vector<T>> store;",
            "    D ds;",
            "",
            "    offline_deletion_chan(int n) : ",
            "    n(n), ans(4 * n + 5), store(4 * n + 5) {};",
            "",
            "    //put(L, R, life) puts element \"life\" into segment [L, R]",
            "    void put(int L, int R, T life)",
            "    {",
            "        auto rec = [&](int v, int l, int r, auto &&rec) -> void",
            "        {",
            "            if(l > r or r < L or R < l)",
            "                return;",
            "",
            "            if(L <= l and r <= R)",
            "            {",
            "                store[v].push_back(life);",
            "                return;",
            "            }",
            "            ",
            "            int mid = (l + r)/2;",
            "            put(v * 2, l, mid, rec);",
            "            put(v * 2 + 1, mid + 1, r, rec);",
            "        };",
            "        rec(1, 1, n, rec);",
            "    }",
            "",
            "    void compute()",
            "    {",
            "        auto dfs = [&](int v, int l, int r, auto &&dfs) -> void",
            "        {",
            "            if(l > r)",
            "                return;",
            "",
            "            for(auto point : store[v])",
            "                ds.Insert(point);",
            "",
            "            if(l == r)",
            "                ans[l] = ds.Query();",
            "            else",
            "            {",
            "                int mid = (l + r)/2;",
            "                dfs(v * 2, l, mid, dfs);",
            "                dfs(v * 2 + 1, mid + 1, r, dfs);",
            "            }",
            "            ",
            "            for(auto point : store[v])",
            "                ds.Rollback();",
            "        };",
            "        dfs(1, 1, n, dfs);",
            "    }",
            "};"
        ],
        "description": "Snippet for offline_deletion (waifu version)"
    },
    "template_waifu_cartesian_tree": {
        "prefix": "template_waifu_cartesian_tree",
        "body": [
            "template<typename T, typename C>",
            "vector<vector<int>> cartesian_tree(const vector<T> &p, C c = C())",
            "{",
            "    int n = p.size();",
            "",
            "    vector<int> l(n, -1);",
            "",
            "    vector<int> stk;",
            "    for(int i = n - 1; i >= 0; i --)",
            "    {",
            "        while(!stk.empty() and c(p[i], p[stk.back()]))",
            "            l[stk.back()] = i, stk.pop_back();",
            "        stk.push_back(i);",
            "    }",
            "    stk.clear();",
            "",
            "    vector<int> r(n, n);",
            "    for(int i = 0; i < n; i ++)",
            "    {",
            "        while(!stk.empty() and c(p[i], p[stk.back()]))",
            "            r[stk.back()] = i, stk.pop_back();",
            "        stk.push_back(i);",
            "    }",
            "    stk.clear();",
            "",
            "    vector<vector<int>> adj(n);",
            "    for(int i = 0; i < n; i ++)",
            "    {",
            "        int parent = -1;",
            "        if(l[i] != -1)",
            "            parent = l[i];",
            "        ",
            "        if(r[i] != -1)",
            "            if(parent == -1 or !c(p[parent], p[r[i]]))",
            "                parent = r[i];",
            "        ",
            "        if(parent != -1)",
            "            adj[parent].push_back(i);",
            "    }",
            "",
            "    return adj;",
            "}"
        ],
        "description": "Snippet for cartesian_tree (waifu version)"
    },
    "template_waifu_krt": {
        "prefix": "template_waifu_krt",
        "body": [
            "class krt_chan",
            "{",
            "public:",
            "    int n;",
            "",
            "    vector<int> wg;",
            "    vector<vector<int>> krt;",
            "",
            "    krt_chan(int n, vector<array<int, 3>> edge, auto cmp) : n(n), wg(2 * n, -1), krt(2 * n)",
            "    {",
            "        int id = n;",
            "        vector<int> par(2 * n);",
            "        iota(par.begin(), par.end(), 0);",
            "",
            "        auto find = [&](int u, auto &&find) -> int",
            "        {",
            "            return (par[u] == u ? u : par[u] = find(par[u], find));",
            "        };",
            "        auto unite = [&](int u, int v, int w) -> void",
            "        {",
            "            u = find(u, find), v = find(v, find);",
            "            if(u == v)",
            "                return;",
            "            par[u] = par[v] = par[id] = id;",
            "            krt[id] = {u, v};",
            "            wg[id] = w;",
            "            id ++;",
            "        };",
            "",
            "        sort(edge.begin(), edge.end(), cmp);",
            "        for(auto [u, v, w] : edge)",
            "            unite(u, v, w);",
            "    };",
            "};"
        ],
        "description": "Snippet for krt (waifu version)"
    },
    "template_waifu_monoid_queue": {
        "prefix": "template_waifu_monoid_queue",
        "body": [
            "template<template<typename> typename S, typename T>",
            "class monoid_queue_chan",
            "{",
            "public:",
            "    S<T> l, r;",
            "",
            "    int size()",
            "    {",
            "        return l.size() + r.size();",
            "    }",
            "",
            "    bool empty()",
            "    {",
            "        return (l.empty() and r.empty());",
            "    }",
            "",
            "    void rebalance()",
            "    {",
            "        while(!r.empty())",
            "            l.push(r.top()), r.pop();",
            "    }",
            "",
            "    void push(T x)",
            "    {",
            "        r.push(x);",
            "    }",
            "",
            "    void pop()",
            "    {",
            "        assert(!empty());",
            "        if(l.empty())   rebalance();",
            "        l.pop();",
            "    }",
            "",
            "    T sum()",
            "    {",
            "        return l.sum().unite(r.sum());",
            "    }",
            "",
            "    T front()",
            "    {",
            "        assert(!empty());",
            "        if(l.empty())   rebalance();",
            "        return l.top();",
            "    }",
            "    ",
            "    T back()",
            "    {",
            "        assert(!empty());",
            "        if(r.empty())",
            "            return l.top(0);",
            "        return r.top();",
            "    }",
            "};"
        ],
        "description": "Snippet for monoid_queue (waifu version)"
    },
    "template_waifu_bitset": {
        "prefix": "template_waifu_bitset",
        "body": [
            "template<typename T, const int B>",
            "class bitset_chan",
            "{",
            "public:",
            "    using T_T = T;",
            "    static_assert(sizeof(T) * 8 == B, \"check block width\");",
            "    static_assert(std::is_same<T, uint64_t>::value, \"modify popcnt(), ctz(), clz()\");",
            "",
            "//static helper",
            "public:",
            "    static inline constexpr bool on(int i, T x) noexcept",
            "    {",
            "        return ((T(1) << i) & x) != 0;",
            "    }",
            "    static inline constexpr T prefix(int i) noexcept",
            "    {",
            "        return (i >= B) ? ~T(0) : ((T(1) << i) - T(1));",
            "    }",
            "    static inline constexpr T suffix(int i) noexcept",
            "    {",
            "        return ~prefix(B - i);",
            "    }",
            "    static inline constexpr T range(int l, int r) noexcept",
            "    {",
            "        return prefix(r) ^ prefix(l - 1);",
            "    }",
            "    static constexpr int popcnt(T x) noexcept",
            "    {",
            "        // return _mm_popcnt_u64(x);",
            "        return __builtin_popcountll(x);",
            "    }",
            "    static constexpr int clz(T x) noexcept",
            "    {",
            "        return __builtin_clzll(x);",
            "    }",
            "    static constexpr int ctz(T x) noexcept",
            "    {",
            "        return __builtin_ctzll(x);",
            "    }",
            "    static inline constexpr int block_id(int i) noexcept",
            "    {",
            "        return i / B;",
            "    }",
            " ",
            "//helper",
            "public:",
            "    inline T submask(int l, int r) const noexcept",
            "    {",
            "        int bx = block_id(l);",
            "        assert(bx == block_id(r));",
            "        return (b[bx] & range(l - bx * B + 1, r - bx * B + 1)); ",
            "    }",
            "    inline void trim() noexcept",
            "    {",
            "        b.back() &= prefix(n % B == 0 ? B : n % B);",
            "    }",
            " ",
            "//main",
            "public:",
            "    int n, m;",
            "    std::vector<T> b;",
            " ",
            "    bitset_chan(int n) : bitset_chan(n, false) {};",
            "    bitset_chan(int n, bool init) : n(n), m((n + B - 1)/B), b(m, init ? ~T(0) : T(0)) ",
            "    {",
            "        trim();",
            "    };",
            " ",
            "    inline void set(int i, bool val) noexcept",
            "    {",
            "        assert(0 <= i and i < n);",
            "        if(val)",
            "            b[i/B] |= (T(1) << (i % B));",
            "        else",
            "            b[i/B] &= ~(T(1) << (i % B));",
            "    }",
            " ",
            "    inline bool get(int i) const noexcept",
            "    {",
            "        assert(0 <= i and i < n);",
            "        return (b[i/B] & (T(1) << (i % B))) != 0;",
            "    }",
            " ",
            "    void reset() noexcept",
            "    {",
            "        std::fill(b.begin(), b.end(), T(0));",
            "    }",
            " ",
            "    //bitwise operations",
            "    void operator &= (const bitset_chan &other)",
            "    {",
            "        for(int i = 0; i < std::min(m, other.m); i ++)",
            "            b[i] &= other.b[i];",
            "        if(m > other.m)",
            "            std::fill(b.begin() + other.m, b.begin() + m, T(0));",
            "        // trim();",
            "    }",
            " ",
            "    void operator |= (const bitset_chan &other)",
            "    {",
            "        for(int i = 0; i < std::min(m, other.m); i ++)",
            "            b[i] |= other.b[i];",
            "        trim();",
            "    }",
            " ",
            "    void operator ^= (const bitset_chan &other)",
            "    {",
            "        for(int i = 0; i < std::min(m, other.m); i ++)",
            "            b[i] ^= other.b[i];",
            "        trim();",
            "    }",
            " ",
            "    void operator <<= (int x)",
            "    {",
            "        if(x == 0)",
            "            return;",
            " ",
            "        if(x >= n)",
            "        {",
            "            reset();",
            "            return;",
            "        }",
            " ",
            "        const int s = x/B, d = x % B, r = B - d;",
            " ",
            "        if(d > 0)",
            "        {",
            "            for(int i = m - 1 - s; i > 0; i --)",
            "                b[i + s] = (b[i] << d) | (b[i - 1] >> r);",
            "            b[s] = b[0] << d;",
            "        }",
            "        else",
            "        {",
            "            for(int i = m - 1 - s; i > 0; i --)",
            "                b[i + s] = b[i];",
            "            b[s] = b[0];",
            "        }",
            " ",
            "        std::fill(b.begin(), b.begin() + s, T(0));",
            " ",
            "        trim();",
            "    }",
            " ",
            "    void operator >>= (int x)",
            "    {",
            "        if(x == 0)",
            "            return;",
            "     ",
            "        if(x >= n)",
            "        {",
            "            reset();",
            "            return;",
            "        }",
            " ",
            "        const int s = x/B, d = x % B, l = B - d;",
            " ",
            "        if(d > 0)",
            "        {",
            "            for(int i = s; i < m - 1; i ++)",
            "                b[i - s] = (b[i] >> d) | (b[i + 1] << l); ",
            "            b[m - 1 - s] = b[m - 1] >> d;",
            "        }",
            "        else",
            "            for(int i = s; i < m; i ++)",
            "                b[i - s] = b[i];",
            " ",
            "        std::fill(b.begin() + m - s, b.end(), T(0));        ",
            " ",
            "        // trim();",
            "    }",
            " ",
            "    bool operator == (const bitset_chan &other)",
            "    {",
            "        return ((n == other.n) and b == other.b); ",
            "    }",
            " ",
            "    bool operator != (const bitset_chan &other)",
            "    {",
            "        return !(*this == other);",
            "    }",
            " ",
            "    //extended",
            "    bitset_chan operator & (const bitset_chan &other)",
            "    {",
            "        bitset_chan result(*this);",
            "        result &= other;",
            "        return result;",
            "    }",
            " ",
            "    bitset_chan operator | (const bitset_chan &other)",
            "    {",
            "        bitset_chan result(*this);",
            "        result |= other;",
            "        return result;",
            "    }",
            " ",
            "    bitset_chan operator ^ (const bitset_chan &other)",
            "    {",
            "        bitset_chan result(*this);",
            "        result ^= other;",
            "        return result;",
            "    }",
            " ",
            "    bitset_chan operator >> (int x)",
            "    {",
            "        bitset_chan result(*this);",
            "        result >>= x;",
            "        return result;",
            "    }",
            " ",
            "    bitset_chan operator << (int x)",
            "    {",
            "        bitset_chan result(*this);",
            "        result <<= x;",
            "        return result;",
            "    }",
            " ",
            "    bitset_chan operator ~()",
            "    {",
            "        bitset_chan result(*this);",
            "        for(auto &v : result)",
            "            v = ~v;",
            "        result.trim();",
            "        return result;",
            "    }",
            " ",
            "    //custom operations",
            "    int count() const noexcept",
            "    {",
            "        return std::accumulate(b.begin(), b.end(), 0, [](int sum, T value) { return sum + popcnt(value); });",
            "    }",
            "     ",
            "    int find_first()",
            "    {",
            "        int pos = -1;",
            "",
            "        for(int bi = 0; bi < m; bi ++)",
            "        {",
            "            if(b[bi] == T(0))",
            "                continue;",
            "            ",
            "            pos = ctz(b[bi]) + bi * B;",
            "            break;",
            "        }",
            "",
            "        return pos;",
            "    }",
            "",
            "    int find_last()",
            "    {",
            "        int pos = -1;",
            "",
            "        for(int bi = m - 1; bi >= 0; bi --)",
            "        {",
            "            if(b[bi] == T(0))",
            "                continue;",
            "            ",
            "            pos = B - clz(b[bi]) - 1 + bi * B;",
            "            break;",
            "        }",
            "",
            "        return pos;",
            "    }",
            "",
            "    void range_process(int l, int r, auto block_brute, auto block_quick)",
            "    {",
            "        assert(0 <= l and l <= r and r < n);",
            " ",
            "        int bl = block_id(l), br = block_id(r);",
            " ",
            "        if(bl == br)",
            "            block_brute(l, r);",
            "        else",
            "        {",
            "            block_brute(l, (bl + 1) * B - 1);",
            "            for(int bi = bl + 1; bi < br; bi ++)",
            "                block_quick(bi);",
            "            block_brute(br * B, r);",
            "        }",
            "    }",
            " ",
            "    void range_set(int l, int r, bool val)",
            "    {",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            int bi = block_id(l);",
            "            T mask = range(l - bi * B + 1, r - bi * B + 1);",
            "            if(val)",
            "                b[bi] |= mask;",
            "            else",
            "                b[bi] &= ~mask;",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            b[bi] = (val ? ~T(0) : T(0));",
            "        };",
            "        range_process(l, r, block_brute, block_quick);",
            "    }",
            " ",
            "    int count(int l, int r)",
            "    {",
            "        int cnt = 0;",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            cnt += popcnt(submask(l, r));",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            cnt += popcnt(b[bi]);",
            "        };",
            "        range_process(l, r, block_brute, block_quick);",
            "        return cnt;",
            "    }",
            " ",
            "    int find_first (int l, int r)",
            "    {",
            "        int pos = -1;",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            for(int i = l; i <= r and pos == -1; i ++)",
            "                if(get(i))",
            "                    pos = i;    ",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            if(b[bi] == T(0) or pos != -1)",
            "                return;",
            " ",
            "            pos = ctz(b[bi]) + bi * B;",
            "        };",
            " ",
            "        range_process(l, r, block_brute, block_quick);",
            "        return pos;",
            "    }",
            "    ",
            "    int find_last(int l, int r)",
            "    {",
            "        int pos = -1;",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            for(int i = l; i <= r; i ++)",
            "                if(get(i))",
            "                    pos = i;    ",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            if(b[bi] == T(0))",
            "                return;",
            " ",
            "            pos = B - clz(b[bi]) - 1 + bi * B;",
            "        };",
            " ",
            "        range_process(l, r, block_brute, block_quick);",
            "        return pos;",
            "    }",
            "",
            "    friend std::ostream &operator<<(std::ostream &os, const bitset_chan &bitset)",
            "    {",
            "        for (int i = bitset.m - 1; i >= 0; --i)",
            "            os << std::bitset<B>(bitset.b[i]);",
            "        os << '\\\\n';",
            "        return os;",
            "    }",
            "};",
            "",
            "using bitset_chan64 = bitset_chan<uint64_t, bit_width(uint64_t())>;"
        ],
        "description": "Snippet for bitset (waifu version)"
    },
    "template_waifu_fast_segment_tree_lazy": {
        "prefix": "template_waifu_fast_segment_tree_lazy",
        "body": [
            "template <typename info, typename tag>",
            "class f_lazy_segment_tree_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<info> infos;",
            "    vector<tag> tags;",
            "    seg_tree::in_order_layout layout;",
            "",
            "    void apply(seg_tree::point a, const tag &t)",
            "    {",
            "        auto [l, r] = layout.get_node_bounds(a);",
            "        if (!t.apply_to(infos[a], l, r - 1))     //r - 1 to make inclusive",
            "        {",
            "            assert(a < n);",
            "            downdate_node(a);",
            "            apply(a.c(0), t);",
            "            apply(a.c(1), t);",
            "            update_node(a);",
            "            return;",
            "        }",
            "        if (a < n)",
            "        {",
            "            t.apply_to(tags[a]);",
            "        }",
            "    }",
            "",
            "    void downdate_node(seg_tree::point a)",
            "    {",
            "        if (!tags[a].empty())",
            "        {",
            "            apply(a.c(0), tags[a]);",
            "            apply(a.c(1), tags[a]);",
            "            tags[a] = tag();",
            "        }",
            "    }",
            "",
            "    void update_node(seg_tree::point a)",
            "    {",
            "        infos[a] = infos[a.c(0)].unite(infos[a.c(1)]);",
            "    }",
            "",
            "    f_lazy_segment_tree_chan() : f_lazy_segment_tree_chan(0) {}",
            "    f_lazy_segment_tree_chan(int n_) : f_lazy_segment_tree_chan(vector<info>(n_)) {}",
            "    f_lazy_segment_tree_chan(const vector<info> &a) : n(int(a.size()))",
            "    {",
            "        infos.resize(2 * n);",
            "        tags.resize(n);",
            "        layout = seg_tree::in_order_layout(n);",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            infos[layout.get_point(i)] = a[i];",
            "        }",
            "        for (int i = n - 1; i >= 1; i--)",
            "        {",
            "            update_node(seg_tree::point(i));",
            "        }",
            "    }",
            "",
            "    void modify(int l, int r, const tag &t)",
            "    {",
            "        ++ r;",
            "        auto rng = layout.get_range(l, r);",
            "        rng.for_parents_down([&](seg_tree::point a)",
            "                            { downdate_node(a); });",
            "        rng.for_each([&](seg_tree::point a)",
            "                     { apply(a, t); });",
            "        rng.for_parents_up([&](seg_tree::point a)",
            "                            { update_node(a); });",
            "    }",
            "",
            "    void set(int p, const info &v)",
            "    {",
            "        auto pt = layout.get_point(p);",
            "        pt.for_parents_down([&](seg_tree::point a)",
            "                            { downdate_node(a); });",
            "        infos[pt] = v;",
            "        pt.for_parents_up([&](seg_tree::point a)",
            "                          { update_node(a); });",
            "    }",
            "",
            "    info query(int l, int r)",
            "    {",
            "        ++ r;",
            "        auto rng = layout.get_range(l, r);",
            "        rng.for_parents_down([&](seg_tree::point a)",
            "                             { downdate_node(a); });",
            "        info res;",
            "        rng.for_each_l_to_r([&](seg_tree::point a)",
            "                            { res = res.unite(infos[a]); });",
            "        return res;",
            "    }",
            "",
            "    info get(int p)",
            "    {",
            "        auto pt = layout.get_point(p);",
            "        pt.for_parents_down([&](seg_tree::point a)",
            "                            { downdate_node(a); });",
            "        return infos[pt];",
            "    }",
            "",
            "    //returns max point r such that f(sum[l, r]) = true given that f is monotonic as r increases ",
            "    //if (r > n), then f(sum[l, n]) = true ",
            "    //if (r < l), then f(sum[l, l]) = false",
            "    template <typename F>",
            "    int max_right(int l, F f)",
            "    {",
            "        auto rng = layout.get_range(l, n);",
            "        rng.for_parents_down([&](seg_tree::point a) { downdate_node(a); });",
            "        ",
            "        int res = n;",
            "        info sum;",
            "        rng.for_each_l_to_r([&](seg_tree::point a)",
            "        {",
            "            if (res != n)",
            "            {",
            "                return;",
            "            }",
            "            auto new_sum = sum.unite(infos[a]);",
            "            if (f(new_sum)) ",
            "            {",
            "                sum = new_sum;",
            "                return;",
            "            }",
            "            while (a < n)",
            "            {",
            "                downdate_node(a);",
            "                new_sum = sum.unite(infos[a.c(0)]);",
            "                if (f(new_sum))",
            "                {",
            "                    sum = new_sum;",
            "                    a = a.c(1);",
            "                } ",
            "                else",
            "                {",
            "                    a = a.c(0);",
            "                }",
            "            }",
            "            res = layout.get_node_bounds(a)[0];",
            "        });",
            "        -- res;",
            "        return min(res, n);",
            "    }",
            "",
            "    //returns min point l such that f(sum[l, r]) = true given that f is monotonic as l decreases",
            "    //if (l == 0), then f(sum[0, n]) = true",
            "    //if (l > r), then f(sum[r, r]) = false",
            "    template <typename F>",
            "    int min_left(int r, F f)",
            "    {",
            "        ++ r;",
            "        auto rng = layout.get_range(0, r);",
            "        rng.for_parents_down([&](seg_tree::point a) { downdate_node(a); });",
            "        ",
            "        int res = 0;",
            "        info sum;",
            "        rng.for_each_r_to_l([&](seg_tree::point a)",
            "        {",
            "            if (res != 0) ",
            "            {",
            "                return;",
            "            }",
            "            auto new_sum = infos[a].unite(sum);",
            "            if (f(new_sum))",
            "            {",
            "                sum = new_sum;",
            "                return;",
            "            }",
            "            while (a < n)",
            "            {",
            "                downdate_node(a);",
            "                new_sum = infos[a.c(1)].unite(sum);",
            "                if (f(new_sum))",
            "                {",
            "                    sum = new_sum;",
            "                    a = a.c(0);",
            "                }",
            "                else",
            "                {",
            "                    a = a.c(1);",
            "                }",
            "            }",
            "            res = layout.get_node_bounds(a)[1];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for fast_segment_tree_lazy (waifu version)"
    },
    "template_waifu_persistent_segment_tree_simple": {
        "prefix": "template_waifu_persistent_segment_tree_simple",
        "body": [
            "template <typename info, typename info_ptr>",
            "class p_segment_tree_chan",
            "{",
            "public:",
            "    int n, r, U;",
            "    map<int, int> roots;",
            "    vector<info> infos;",
            "    vector<info_ptr> info_ptrs;",
            "",
            "    template<typename O>",
            "    void recurse(int root, int lb, int rb, bool update, O op)",
            "    {",
            "        auto rec = [&](int v, int l, int r, auto &&rec) -> void",
            "        {",
            "            if(l > r or v == 0)",
            "                return;",
            "",
            "            if(lb <= l and r <= rb)",
            "            {",
            "                op(v, l, r);",
            "                return;",
            "            }",
            "",
            "            int m = (l + r)/2;",
            "",
            "            if(m >= lb)",
            "            {",
            "                if(update)",
            "                {",
            "                    int old_lc = info_ptrs[v].lc;",
            "                    info_ptrs[v].lc = ++ U;",
            "                    infos[info_ptrs[v].lc] = infos[old_lc];",
            "                    info_ptrs[info_ptrs[v].lc] = info_ptrs[old_lc];",
            "                }",
            "                rec(info_ptrs[v].lc, l, m, rec);",
            "            }",
            "            if(m + 1 <= rb)",
            "            {",
            "                if(update)",
            "                {",
            "                    int old_rc = info_ptrs[v].rc;",
            "                    info_ptrs[v].rc = ++ U;",
            "                    infos[info_ptrs[v].rc] = infos[old_rc]; ",
            "                    info_ptrs[info_ptrs[v].rc] = info_ptrs[old_rc];",
            "                }",
            "                rec(info_ptrs[v].rc, m + 1, r, rec);",
            "            }",
            "            ",
            "            if(update)",
            "                infos[v] = infos[info_ptrs[v].lc].unite(infos[info_ptrs[v].rc]);",
            "        };",
            "        rec(root, 0, n - 1, rec);",
            "    };",
            "",
            "    p_segment_tree_chan() : p_segment_tree_chan(0, 0) {};",
            "    p_segment_tree_chan(int n, int r) : p_segment_tree_chan(n, r, vector<info> (r)) {};",
            "    p_segment_tree_chan(int n, int r, const vector<info> &a) : ",
            "    n(n), r(r), infos(r + 1), info_ptrs(r + 1), U(0)",
            "    {",
            "        auto build = [&](int v, int l, int r, auto &&build) -> void",
            "        {",
            "            if(!v or l > r)",
            "                return;",
            "",
            "            if(l == r)",
            "            {",
            "                infos[v] = info(a[l]);",
            "                return;",
            "            }",
            "            int m = (l + r)/2;",
            "            if(l <= m)",
            "            {",
            "                info_ptrs[v].lc = ++ U;",
            "                build(info_ptrs[v].lc, l, m, build);",
            "            }",
            "            if(m + 1 <= r)",
            "            {",
            "                info_ptrs[v].rc = ++ U;",
            "                build(info_ptrs[v].rc, m + 1, r, build);",
            "            }",
            "            infos[v] = infos[info_ptrs[v].lc].unite(infos[info_ptrs[v].rc]);",
            "        };",
            "        int root = ++ U;",
            "        roots[0] = root;",
            "        build(U, 0, n - 1, build);",
            "    };",
            "",
            "    pair<int, int> resolve_roots (int new_root, int old_root)",
            "    {",
            "        auto it = roots.find(old_root);",
            "        assert(it != roots.end());",
            "        old_root = (*it).second;",
            "",
            "        assert(roots.find(new_root) == roots.end());",
            "        roots[new_root] = ++ U;",
            "        new_root = U;",
            "        infos[new_root] = infos[old_root];",
            "        info_ptrs[new_root] = info_ptrs[old_root];",
            "",
            "        return {new_root, old_root};",
            "    };",
            "",
            "    void set(int new_root, int old_root, int p, const info &infonode)",
            "    {",
            "        tie(new_root, old_root) = resolve_roots(new_root, old_root);",
            "",
            "        recurse(new_root, p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infonode;",
            "        });",
            "    }",
            "    void add(int new_root, int old_root, int p, const info &infonode)",
            "    {",
            "        tie(new_root, old_root) = resolve_roots(new_root, old_root);",
            "",
            "        recurse(new_root, p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infos[v].unite(infonode);",
            "        });",
            "    }",
            "    info query(int root, int lb, int rb)",
            "    {",
            "        auto it = roots.find(root);",
            "        assert(it != roots.end());",
            "        root = (*it).second;",
            "        info res = info();",
            "        recurse(root, lb, rb, false, [&](int v, int l, int r)",
            "        {",
            "            res = res.unite(infos[v]);",
            "        });",
            "        return res;",
            "    }",
            "    info get(int root, int p)",
            "    {",
            "        auto it = roots.find(root);",
            "        assert(it != roots.end());",
            "        root = (*it).second;",
            "        info res = info();",
            "        recurse(root, p, p, false, [&](int v, int l, int r)",
            "        {",
            "            res = infos[v];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for persistent_segment_tree_simple (waifu version)"
    },
    "template_waifu_persistent_segment_tree_lazy": {
        "prefix": "template_waifu_persistent_segment_tree_lazy",
        "body": [
            "template <typename info, typename tag, typename info_ptr>",
            "class p_lazy_segment_tree_chan",
            "{",
            "public:",
            "    int n, r, U;",
            "    map<int, int> roots;",
            "    vector<info> infos;",
            "    vector<tag> tags;",
            "    vector<info_ptr> info_ptrs;",
            "",
            "    template<typename O>",
            "    void recurse(int root, int lb, int rb, bool update, O op)",
            "    {",
            "        auto rec = [&](int v, int l, int r, auto &&rec) -> void",
            "        {    ",
            "            if(l > r or v == 0)",
            "               return;",
            "            ",
            "            if(lb <= l and r <= rb)",
            "            {",
            "                propagate(v, l, r, update);",
            "                op(v, l, r);",
            "                return;",
            "            }",
            "",
            "            int m = (l + r)/2;",
            "",
            "            if(m >= lb)",
            "            {",
            "                if(update)",
            "                    info_ptrs[v].lc = make_node(info_ptrs[v].lc, true);",
            "                rec(info_ptrs[v].lc, l, m, rec);",
            "            }",
            "            else if(update)",
            "               propagate(info_ptrs[v].lc, l, m, update);",
            "",
            "            if(m + 1 <= rb)",
            "            {",
            "                if(update)",
            "                    info_ptrs[v].rc = make_node(info_ptrs[v].rc, true);",
            "                rec(info_ptrs[v].rc, m + 1, r, rec);",
            "            }",
            "            else if(update)",
            "               propagate(info_ptrs[v].rc, m + 1, r, update);",
            "            ",
            "            if(update)",
            "                infos[v] = infos[info_ptrs[v].lc].unite(infos[info_ptrs[v].rc]);",
            "        };",
            "        rec(root, 0, n - 1, rec);",
            "    };",
            "",
            "    p_lazy_segment_tree_chan() : p_lazy_segment_tree_chan(0) {};",
            "    p_lazy_segment_tree_chan(int n) : p_lazy_segment_tree_chan(n, vector<info> (n)) {};",
            "    p_lazy_segment_tree_chan(int n, const vector<info> &a) : ",
            "    n(n), r(4 * (n + 1) + 5), infos(r), tags(r), info_ptrs(r), U(0)",
            "    {",
            "        assert(n == a.size());",
            "        auto build = [&](int v, int l, int r, auto &&build) -> void",
            "        {",
            "            if(!v or l > r)",
            "                return;",
            "",
            "            if(l == r)",
            "            {",
            "                infos[v] = info(a[l]);",
            "                return;",
            "            }",
            "            int m = (l + r)/2;",
            "            if(l <= m)",
            "            {",
            "                info_ptrs[v].lc = ++ U;",
            "                build(info_ptrs[v].lc, l, m, build);",
            "            }",
            "            if(m + 1 <= r)",
            "            {",
            "                info_ptrs[v].rc = ++ U;",
            "                build(info_ptrs[v].rc, m + 1, r, build);",
            "            }",
            "            infos[v] = infos[info_ptrs[v].lc].unite(infos[info_ptrs[v].rc]);",
            "        };",
            "        int root = ++ U;",
            "        roots[0] = root;",
            "        build(U, 0, n - 1, build);",
            "    };",
            "",
            "    void propagate(int v, int l, int r, bool update)",
            "    {",
            "        if(!v or tags[v].empty())",
            "            return;",
            "        tags[v].apply_to(infos[v], l, r);",
            "        if(l != r)",
            "        {",
            "            if(info_ptrs[v].exp_create)",
            "            {",
            "                info_ptrs[v].exp_create = false;",
            "                info_ptrs[v].lc = make_node(info_ptrs[v].lc, true);",
            "                info_ptrs[v].rc = make_node(info_ptrs[v].rc, true);                ",
            "            }",
            "            tags[v].apply_to(tags[info_ptrs[v].lc]);",
            "            tags[v].apply_to(tags[info_ptrs[v].rc]);",
            "        }",
            "        tags[v] = tag();",
            "    }",
            "    int make_node (int old_node = 0, bool exp_create = false)",
            "    {",
            "        int new_node = ++ U;",
            "",
            "        if(U >= r)",
            "        {",
            "            r ++;",
            "            infos.resize(r);",
            "            info_ptrs.resize(r);",
            "            tags.resize(r);",
            "        }",
            "",
            "        infos[new_node] = infos[old_node];",
            "        info_ptrs[new_node] = info_ptrs[old_node];",
            "        info_ptrs[new_node].exp_create = exp_create;",
            "        tags[new_node] = tags[old_node];",
            "        return new_node;",
            "    }",
            "",
            "    pair<int, int> resolve_roots (int new_root, int old_root)",
            "    {",
            "        auto it = roots.find(old_root);",
            "        assert(it != roots.end());",
            "        old_root = (*it).second;",
            "",
            "        assert(roots.find(new_root) == roots.end());",
            "        int storev = new_root;",
            "        new_root = make_node(old_root, true);",
            "        roots[storev] = new_root;",
            "",
            "        return {new_root, old_root};",
            "    };",
            "",
            "    void modify(int new_root, int old_root, int lb, int rb, const tag &tagnode)",
            "    {",
            "        tie(new_root, old_root) = resolve_roots(new_root, old_root);",
            "        recurse(new_root, lb, rb, true, [&](int v, int l, int r)",
            "        {",
            "            tagnode.apply_to(tags[v]);",
            "            propagate(v, l, r, true);",
            "        });",
            "    }",
            "    void set(int new_root, int old_root, int p, const info &infonode)",
            "    {",
            "        tie(new_root, old_root) = resolve_roots(new_root, old_root);",
            "",
            "        recurse(new_root, p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infonode;",
            "        });",
            "    }",
            "    void add(int new_root, int old_root, int p, const info &infonode)",
            "    {",
            "        tie(new_root, old_root) = resolve_roots(new_root, old_root);",
            "",
            "        recurse(new_root, p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infos[v].unite(infonode);",
            "            propagate(v, l, r, true);",
            "        });",
            "    }",
            "    ",
            "    info query(int root, int lb, int rb)",
            "    {",
            "        auto it = roots.find(root);",
            "        assert(it != roots.end());",
            "        root = (*it).second;",
            "        info res = info();",
            "        recurse(root, lb, rb, false, [&](int v, int l, int r)",
            "        {",
            "            res = res.unite(infos[v]);",
            "        });",
            "        return res;",
            "    }",
            "    info get(int root, int p)",
            "    {",
            "        auto it = roots.find(root);",
            "        assert(it != roots.end());",
            "        root = (*it).second;",
            "        info res = info();",
            "        recurse(root, p, p, false, [&](int v, int l, int r)",
            "        {",
            "            res = infos[v];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for persistent_segment_tree_lazy (waifu version)"
    },
    "template_waifu_monoid_tag": {
        "prefix": "template_waifu_monoid_tag",
        "body": [
            "class tag_chan",
            "{",
            "public:",
            "    int add = 0;",
            "",
            "    tag_chan() : add(0) {};",
            "    tag_chan(int x) : add(x) {};",
            "",
            "    bool apply_to(monoid_chan &a, [[maybe_unused]] int l, [[maybe_unused]] int r) const",
            "    {",
            "        a.sum += add * (r - l + 1);",
            "        return true;",
            "    }",
            "    void apply_to(tag_chan &t) const",
            "    {",
            "        t.add += add;",
            "    }",
            "    bool empty() const",
            "    {",
            "        return add == 0;",
            "    }",
            "};"
        ],
        "description": "Snippet for monoid_tag (waifu version)"
    },
    "template_waifu_persistent_monoid_pointer": {
        "prefix": "template_waifu_persistent_monoid_pointer",
        "body": [
            "class p_node_pointer_chan",
            "{",
            "public:",
            "    int lc, rc;",
            "    bool exp_create;",
            "",
            "    p_node_pointer_chan() : lc(0), rc(0), exp_create(false) {};",
            "    p_node_pointer_chan(int l, int r) : lc(l), rc(r) {};",
            "};"
        ],
        "description": "Snippet for persistent_monoid_pointer (waifu version)"
    },
    "template_waifu_recursive_segment_tree_simple": {
        "prefix": "template_waifu_recursive_segment_tree_simple",
        "body": [
            "template <typename info>",
            "class r_segment_tree_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<info> infos;",
            "",
            "    template<typename O>",
            "    void recurse(int lb, int rb, bool update, O op)",
            "    {",
            "        auto rec = [&](int v, int l, int r, auto &&rec) -> void",
            "        {",
            "            if(l > r)",
            "                return;",
            "            ",
            "            if(lb <= l and r <= rb)",
            "            {",
            "                op(v, l, r);",
            "                return;",
            "            }",
            "            ",
            "            int m = (l + r)/2;",
            "            ",
            "            if(m >= lb)",
            "                rec(2 * v, l, m, rec);",
            "            if(m + 1 <= rb)",
            "                rec(2 * v + 1, m + 1, r, rec);",
            "            ",
            "            if(update)",
            "                infos[v] = infos[2 * v].unite(infos[2 * v + 1]);",
            "        };",
            "        rec(1, 0, n - 1, rec);",
            "    };",
            "",
            "    r_segment_tree_chan() : r_segment_tree_chan(0) {};",
            "    r_segment_tree_chan(int n) : r_segment_tree_chan(vector<info> (n)) {};",
            "    r_segment_tree_chan(const vector<info> &a) : ",
            "    n((int)a.size()), infos(4 * n + 5)",
            "    {",
            "        auto build = [&](int v, int l, int r, auto &&build) -> void",
            "        {",
            "            if(l > r)",
            "                return;",
            "            if(l == r)",
            "            {",
            "                infos[v] = info(a[l]);",
            "                return;",
            "            }",
            "            int m = (l + r)/2;",
            "            build(v * 2, l, m, build);",
            "            build(v * 2 + 1, m + 1, r, build);",
            "            infos[v] = infos[v * 2].unite(infos[v * 2 + 1]);",
            "        };",
            "        build(1, 0, n - 1, build);",
            "    };",
            "",
            "    void set(int p, const info &infonode)",
            "    {",
            "        recurse(p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infonode;",
            "        });",
            "    }",
            "    void add(int p, const info &infonode)",
            "    {",
            "        recurse(p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infos[v].unite(infonode);",
            "        });",
            "    }",
            "    info query(int lb, int rb)",
            "    {",
            "        info res = info();",
            "        recurse(lb, rb, false, [&](int v, int l, int r)",
            "        {",
            "            res = res.unite(infos[v]);",
            "        });",
            "        return res;",
            "    }",
            "    info get(int p)",
            "    {",
            "        info res = info();",
            "        recurse(p, p, false, [&](int v, int l, int r)",
            "        {",
            "            res = infos[v];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for recursive_segment_tree_simple (waifu version)"
    },
    "template_waifu_recursive_segment_tree_lazy": {
        "prefix": "template_waifu_recursive_segment_tree_lazy",
        "body": [
            "template <typename info, typename tag>",
            "class r_lazy_segment_tree_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<info> infos;",
            "    vector<tag> tags;",
            "",
            "    template<typename O>",
            "    void recurse(int lb, int rb, bool update, O op)",
            "    {",
            "        auto rec = [&](int v, int l, int r, auto &&rec) -> void",
            "        {",
            "            propagate(v, l, r);",
            "",
            "            if(l > r)",
            "                return;",
            "            ",
            "            if(lb <= l and r <= rb)",
            "            {",
            "                op(v, l, r);",
            "                return;",
            "            }",
            "            ",
            "            int m = (l + r)/2;",
            "            ",
            "            if(m >= lb)",
            "                rec(2 * v, l, m, rec);",
            "            else if(update)",
            "                propagate(2 * v, l, m);",
            "",
            "            if(m + 1 <= rb)",
            "                rec(2 * v + 1, m + 1, r, rec);",
            "            else if(update)",
            "                propagate(2 * v + 1, m + 1, r);",
            "            ",
            "            if(update)",
            "                infos[v] = infos[2 * v].unite(infos[2 * v + 1]);",
            "        };",
            "        rec(1, 0, n - 1, rec);",
            "    };",
            "",
            "    r_lazy_segment_tree_chan() : r_lazy_segment_tree_chan(0) {};",
            "    r_lazy_segment_tree_chan(int n) : r_lazy_segment_tree_chan(vector<info> (n)) {};",
            "    r_lazy_segment_tree_chan(const vector<info> &a) : ",
            "    n((int)a.size()), infos(4 * n + 5), tags(4 * n + 5)",
            "    {",
            "        auto build = [&](int v, int l, int r, auto &&build) -> void",
            "        {",
            "            if(l > r)",
            "                return;",
            "            if(l == r)",
            "            {",
            "                infos[v] = info(a[l]);",
            "                return;",
            "            }",
            "            int m = (l + r)/2;",
            "            build(v * 2, l, m, build);",
            "            build(v * 2 + 1, m + 1, r, build);",
            "            infos[v] = infos[v * 2].unite(infos[v * 2 + 1]);",
            "        };",
            "        build(1, 0, n - 1, build);",
            "    };",
            "",
            "    void propagate(int v, int l, int r)",
            "    {",
            "        if(tags[v].empty())",
            "            return;",
            "        tags[v].apply_to(infos[v], l, r);",
            "        if(l != r)",
            "        {",
            "            tags[v].apply_to(tags[2 * v]);",
            "            tags[v].apply_to(tags[2 * v  + 1]);",
            "        }",
            "        tags[v] = tag();",
            "    }",
            "",
            "    void modify(int lb, int rb, const tag &tagnode)",
            "    {",
            "        recurse(lb, rb, true, [&](int v, int l, int r)",
            "        {",
            "            tagnode.apply_to(tags[v]);",
            "            propagate(v, l, r);",
            "        });",
            "    }",
            "    void set(int p, const info &info)",
            "    {",
            "        recurse(p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = info;",
            "        });",
            "    }",
            "    void add(int p, const info &info)",
            "    {",
            "        recurse(p, p, true, [&](int v, int l, int r)",
            "        {",
            "            infos[v] = infos[v].unite(info);",
            "            propagate(v, l, r);",
            "        });",
            "    }",
            "    info query(int lb, int rb)",
            "    {",
            "        info res = info();",
            "        recurse(lb, rb, false, [&](int v, int l, int r)",
            "        {",
            "            res = res.unite(infos[v]);",
            "        });",
            "        return res;",
            "    }",
            "    info get(int p)",
            "    {",
            "        info res = info();",
            "        recurse(p, p, false, [&](int v, int l, int r)",
            "        {",
            "            res = infos[v];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for recursive_segment_tree_lazy (waifu version)"
    },
    "template_waifu_fast_segment_tree_layout": {
        "prefix": "template_waifu_fast_segment_tree_layout",
        "body": [
            "namespace seg_tree",
            "{",
            "    // Floor of log_2(a); index of highest 1-bit",
            "    inline int floor_log_2(int a)",
            "    {",
            "        return a ? bit_width(unsigned(a)) - 1 : -1;",
            "    }",
            "",
            "    class point",
            "    {",
            "    public:",
            "        int a;",
            "        point() : a(0) {}",
            "        explicit point(int a_) : a(a_) { assert(a >= -1); }",
            "",
            "        explicit operator bool() { return bool(a); }",
            "",
            "        // This is useful so you can directly do array indices",
            "        /* implicit */ operator int() const { return a; }",
            "",
            "        point c(bool z) const",
            "        {",
            "            return point((a << 1) | z);",
            "        }",
            "",
            "        point operator[](bool z) const",
            "        {",
            "            return c(z);",
            "        }",
            "",
            "        point p() const",
            "        {",
            "            return point(a >> 1);",
            "        }",
            "",
            "        friend std::ostream &operator<<(std::ostream &o, const point &p) { return o << int(p); }",
            "",
            "        template <typename F>",
            "        void for_each(F f) const",
            "        {",
            "            for (int v = a; v > 0; v >>= 1)",
            "            {",
            "                f(point(v));",
            "            }",
            "        }",
            "",
            "        template <typename F>",
            "        void for_parents_down(F f) const",
            "        {",
            "            // strictly greater than 0",
            "            for (int L = floor_log_2(a); L > 0; L--)",
            "            {",
            "                f(point(a >> L));",
            "            }",
            "        }",
            "",
            "        template <typename F>",
            "        void for_parents_up(F f) const",
            "        {",
            "            for (int v = a >> 1; v > 0; v >>= 1)",
            "            {",
            "                f(point(v));",
            "            }",
            "        }",
            "",
            "        point &operator++()",
            "        {",
            "            ++a;",
            "            return *this;",
            "        }",
            "        point operator++(int) { return point(a++); }",
            "        point &operator--()",
            "        {",
            "            --a;",
            "            return *this;",
            "        }",
            "        point operator--(int) { return point(a--); }",
            "    };",
            "",
            "    class range",
            "    {",
            "    public:",
            "        int a, b;",
            "        range() : a(1), b(1) {}",
            "        range(int a_, int b_) : a(a_), b(b_)",
            "        {",
            "            assert(1 <= a && a <= b && b <= 2 * a);",
            "        }",
            "        explicit range(std::array<int, 2> r) : range(r[0], r[1]) {}",
            "",
            "        explicit operator std::array<int, 2>() const",
            "        {",
            "            return {a, b};",
            "        }",
            "",
            "        const int &operator[](bool z) const",
            "        {",
            "            return z ? b : a;",
            "        }",
            "",
            "        friend std::ostream &operator<<(std::ostream &o, const range &r) { return o << \"[\" << r.a << \"..\" << r.b << \")\"; }",
            "",
            "        // Iterate over the range from outside-in.",
            "        //   Calls f(point a)",
            "        template <typename F>",
            "        void for_each(F f) const",
            "        {",
            "            for (int x = a, y = b; x < y; x >>= 1, y >>= 1)",
            "            {",
            "                if (x & 1)",
            "                    f(point(x++));",
            "                if (y & 1)",
            "                    f(point(--y));",
            "            }",
            "        }",
            "",
            "        // Iterate over the range from outside-in.",
            "        //   Calls f(point a, bool is_right)",
            "        template <typename F>",
            "        void for_each_with_side(F f) const",
            "        {",
            "            for (int x = a, y = b; x < y; x >>= 1, y >>= 1)",
            "            {",
            "                if (x & 1)",
            "                    f(point(x++), false);",
            "                if (y & 1)",
            "                    f(point(--y), true);",
            "            }",
            "        }",
            "",
            "        // Iterate over the range from left to right.",
            "        //    Calls f(point)",
            "        template <typename F>",
            "        void for_each_l_to_r(F f) const",
            "        {",
            "            int anc_depth = floor_log_2((a - 1) ^ b);",
            "            int anc_msk = (1 << anc_depth) - 1;",
            "            for (int v = (-a) & anc_msk; v; v &= v - 1)",
            "            {",
            "                int i = countr_zero(unsigned(v));",
            "                f(point(((a - 1) >> i) + 1));",
            "            }",
            "            for (int v = b & anc_msk; v;)",
            "            {",
            "                int i = floor_log_2(v);",
            "                f(point((b >> i) - 1));",
            "                v ^= (1 << i);",
            "            }",
            "        }",
            "",
            "        // Iterate over the range from right to left.",
            "        //    Calls f(point)",
            "        template <typename F>",
            "        void for_each_r_to_l(F f) const",
            "        {",
            "            int anc_depth = floor_log_2((a - 1) ^ b);",
            "            int anc_msk = (1 << anc_depth) - 1;",
            "            for (int v = b & anc_msk; v; v &= v - 1)",
            "            {",
            "                int i = countr_zero(unsigned(v));",
            "                f(point((b >> i) - 1));",
            "            }",
            "            for (int v = (-a) & anc_msk; v;)",
            "            {",
            "                int i = floor_log_2(v);",
            "                f(point(((a - 1) >> i) + 1));",
            "                v ^= (1 << i);",
            "            }",
            "        }",
            "",
            "        template <typename F>",
            "        void for_parents_down(F f) const",
            "        {",
            "            int x = a, y = b;",
            "            if ((x ^ y) > x)",
            "            {",
            "                x <<= 1, std::swap(x, y);",
            "            }",
            "            int dx = countr_zero(unsigned(x));",
            "            int dy = countr_zero(unsigned(y));",
            "            int anc_depth = floor_log_2((x - 1) ^ y);",
            "            for (int i = floor_log_2(x); i > dx; i--)",
            "            {",
            "                f(point(x >> i));",
            "            }",
            "            for (int i = anc_depth; i > dy; i--)",
            "            {",
            "                f(point(y >> i));",
            "            }",
            "        }",
            "",
            "        template <typename F>",
            "        void for_parents_up(F f) const",
            "        {",
            "            int x = a, y = b;",
            "            if ((x ^ y) > x)",
            "            {",
            "                x <<= 1, std::swap(x, y);",
            "            }",
            "            int dx = countr_zero(unsigned(x));",
            "            int dy = countr_zero(unsigned(y));",
            "            int anc_depth = floor_log_2((x - 1) ^ y);",
            "            for (int i = dx + 1; i <= anc_depth; i++)",
            "            {",
            "                f(point(x >> i));",
            "            }",
            "            for (int v = y >> (dy + 1); v; v >>= 1)",
            "            {",
            "                f(point(v));",
            "            }",
            "        }",
            "    };",
            "",
            "    class in_order_layout",
            "    {",
            "    public:",
            "        // Alias them in for convenience",
            "        using point = seg_tree::point;",
            "        using range = seg_tree::range;",
            "",
            "        int n, s;",
            "        in_order_layout() : n(0), s(0) {}",
            "        in_order_layout(int n_) : n(n_), s(n ? bit_ceil(unsigned(n)) : 0) {}",
            "",
            "        point get_point(int a) const",
            "        {",
            "            assert(0 <= a && a < n);",
            "            a += s;",
            "            return point(a >= 2 * n ? a - n : a);",
            "        }",
            "",
            "        range get_range(int a, int b) const",
            "        {",
            "            assert(0 <= a && a <= b && b <= n);",
            "            if (n == 0)",
            "                return range();",
            "            a += s, b += s;",
            "            return range((a >= 2 * n ? 2 * (a - n) : a), (b >= 2 * n ? 2 * (b - n) : b));",
            "        }",
            "",
            "        range get_range(std::array<int, 2> p) const",
            "        {",
            "            return get_range(p[0], p[1]);",
            "        }",
            "",
            "        int get_leaf_index(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(n <= a && a < 2 * n);",
            "            return (a < s ? a + n : a) - s;",
            "        }",
            "",
            "        std::array<int, 2> get_node_bounds(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(1 <= a && a < 2 * n);",
            "            int l = countl_zero(unsigned(a)) - countl_zero(unsigned(2 * n - 1));",
            "            int x = a << l, y = (a + 1) << l;",
            "            assert(s <= x && x < y && y <= 2 * s);",
            "            return {(x >= 2 * n ? (x >> 1) + n : x) - s, (y >= 2 * n ? (y >> 1) + n : y) - s};",
            "        }",
            "",
            "        int get_node_split(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(1 <= a && a < n);",
            "            int l = countl_zero(unsigned(2 * a + 1)) - countl_zero(unsigned(2 * n - 1));",
            "            int x = (2 * a + 1) << l;",
            "            assert(s <= x && x < 2 * s);",
            "            return (x >= 2 * n ? (x >> 1) + n : x) - s;",
            "        }",
            "",
            "        int get_node_size(point pt) const",
            "        {",
            "            auto bounds = get_node_bounds(pt);",
            "            return bounds[1] - bounds[0];",
            "        }",
            "    };",
            "",
            "    class circular_layout",
            "    {",
            "    public:",
            "        // Alias them in for convenience",
            "        using point = seg_tree::point;",
            "        using range = seg_tree::range;",
            "",
            "        int n;",
            "        circular_layout() : n(0) {}",
            "        circular_layout(int n_) : n(n_) {}",
            "",
            "        point get_point(int a) const",
            "        {",
            "            assert(0 <= a && a < n);",
            "            return point(n + a);",
            "        }",
            "",
            "        range get_range(int a, int b) const",
            "        {",
            "            assert(0 <= a && a <= b && b <= n);",
            "            if (n == 0)",
            "                return range();",
            "            return range(n + a, n + b);",
            "        }",
            "",
            "        range get_range(std::array<int, 2> p) const",
            "        {",
            "            return get_range(p[0], p[1]);",
            "        }",
            "",
            "        int get_leaf_index(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(n <= a && a < 2 * n);",
            "            return a - n;",
            "        }",
            "",
            "        // Returns {x,y} so that 0 <= x < n and 1 <= y <= n",
            "        // If the point is non-wrapping, then 0 <= x < y <= n",
            "        std::array<int, 2> get_node_bounds(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(1 <= a && a < 2 * n);",
            "            int l = countl_zero(unsigned(a)) - countl_zero(unsigned(2 * n - 1));",
            "            int s = bit_ceil(unsigned(n));",
            "            int x = a << l, y = (a + 1) << l;",
            "            assert(s <= x && x < y && y <= 2 * s);",
            "            return {(x >= 2 * n ? x >> 1 : x) - n, (y > 2 * n ? y >> 1 : y) - n};",
            "        }",
            "",
            "        // Returns the split point of the node, such that 1 <= s <= n.",
            "        int get_node_split(point pt) const",
            "        {",
            "            int a = int(pt);",
            "            assert(1 <= a && a < n);",
            "            return get_node_bounds(pt.c(0))[1];",
            "        }",
            "",
            "        int get_node_size(point pt) const",
            "        {",
            "            auto bounds = get_node_bounds(pt);",
            "            int r = bounds[1] - bounds[0];",
            "            return r > 0 ? r : r + n;",
            "        }",
            "    };",
            "}"
        ],
        "description": "Snippet for fast_segment_tree_layout (waifu version)"
    },
    "template_waifu_fast_segment_tree_simple": {
        "prefix": "template_waifu_fast_segment_tree_simple",
        "body": [
            "template <typename info>",
            "class f_segment_tree_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<info> infos;",
            "    seg_tree::in_order_layout layout;",
            "",
            "    void update_node(seg_tree::point a)",
            "    {",
            "        infos[a] = infos[a.c(0)].unite(infos[a.c(1)]);",
            "    }",
            "",
            "    f_segment_tree_chan(int n_) : f_segment_tree_chan(vector<info>(n_)) {}",
            "",
            "    f_segment_tree_chan(const vector<info> &a) : n(int(a.size()))",
            "    {",
            "        assert(n > 0);",
            "        infos.resize(2 * n);",
            "        layout = seg_tree::in_order_layout(n);",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            infos[layout.get_point(i)] = a[i];",
            "        }",
            "        for (int i = n - 1; i >= 1; i--)",
            "        {",
            "            infos[i] = infos[2 * i].unite(infos[2 * i + 1]);",
            "        }",
            "    }",
            "",
            "    void set(int p, const info &v)",
            "    {",
            "        auto pt = layout.get_point(p);",
            "        infos[pt] = v;",
            "        pt.for_parents_up([&](seg_tree::point a)",
            "                          { update_node(a); });",
            "    }",
            "",
            "    info query(int l, int r)",
            "    {",
            "        ++ r;",
            "        auto rng = layout.get_range(l, r);",
            "        info res;",
            "        rng.for_each_l_to_r([&](seg_tree::point a)",
            "                            { res = res.unite(infos[a]); });",
            "        return res;",
            "    }",
            "",
            "    info get(int p)",
            "    {",
            "        auto pt = layout.get_point(p);",
            "        return infos[pt];",
            "    }",
            "",
            "    //returns max `r` such that `f(sum[l, r]) = true` given that `f` is monotonic as `r` increases ",
            "    //if `(r > n)`, then `f(sum[l, n]) = true` ",
            "    //if `(r < l)`, then `f(sum[l, l]) = false`",
            "    template <typename F>",
            "    int max_right(int l, F f)",
            "    {",
            "        auto rng = layout.get_range(l, n);",
            "        int res = n;",
            "        info sum;",
            "        rng.for_each_l_to_r([&](seg_tree::point a)",
            "        {",
            "            if (res != n) ",
            "            {",
            "                return;",
            "            }",
            "            auto new_sum = sum.unite(infos[a]);",
            "            if (f(new_sum))",
            "            {",
            "                sum = new_sum;",
            "                return;",
            "            }",
            "            while (a < n) ",
            "            {",
            "                new_sum = sum.unite(infos[a.c(0)]);",
            "                if (f(new_sum)) ",
            "                {",
            "                    sum = new_sum;",
            "                    a = a.c(1);",
            "                }",
            "                else",
            "                {",
            "                    a = a.c(0);",
            "                }",
            "            }",
            "            res = layout.get_node_bounds(a)[0];",
            "        });",
            "        -- res;",
            "        return min(n, res);",
            "    }",
            "",
            "    //returns min point l such that f(sum[l, r]) = true given that f is monotonic as l decreases",
            "    //if (l == 0), then f(sum[0, n]) = true",
            "    //if (l > r), then f(sum[r, r]) = false",
            "    template <typename F>",
            "    int min_left(int r, F f)",
            "    {",
            "        ++ r;",
            "        auto rng = layout.get_range(0, r);",
            "        int res = 0;",
            "        info sum;",
            "        rng.for_each_r_to_l([&](seg_tree::point a)",
            "        {",
            "            if (res != 0) ",
            "            {",
            "                return;",
            "            }",
            "            ",
            "            auto new_sum = infos[a].unite(sum);",
            "            if (f(new_sum))",
            "            {",
            "                sum = new_sum;",
            "                return;",
            "            }",
            "            while (a < n)",
            "            {",
            "                new_sum = infos[a.c(1)].unite(sum);",
            "                if (f(new_sum)) ",
            "                {",
            "                    sum = new_sum;",
            "                    a = a.c(0);",
            "                }",
            "                else",
            "                {",
            "                    a = a.c(1);",
            "                }",
            "            }",
            "            res = layout.get_node_bounds(a)[1];",
            "        });",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Snippet for fast_segment_tree_simple (waifu version)"
    },
    "template_waifu_monoid": {
        "prefix": "template_waifu_monoid",
        "body": [
            "class monoid_chan",
            "{",
            "public:",
            "    int sum = 0;",
            "",
            "    monoid_chan() : sum(0) {};",
            "    monoid_chan(int x) : sum(x) {};",
            "",
            "    monoid_chan unite(monoid_chan b) const ",
            "    {",
            "        monoid_chan res(sum + b.sum);",
            "        return res;",
            "    }",
            "    static monoid_chan get_default([[maybe_unused]] int l, [[maybe_unused]] int r)",
            "    {",
            "        return monoid_chan();",
            "    }",
            "};"
        ],
        "description": "Snippet for monoid (waifu version)"
    },
    "template_waifu_dynamic_monoid": {
        "prefix": "template_waifu_dynamic_monoid",
        "body": [
            "class dynamic_monoid_chan",
            "{",
            "public:",
            "    dynamic_monoid_chan *left, *right;",
            "    int sum = 0;",
            "",
            "    dynamic_monoid_chan() : sum(0) {};",
            "    dynamic_monoid_chan(int x) : sum(x) {};",
            "",
            "    dynamic_monoid_chan unite(dynamic_monoid_chan b) const ",
            "    {",
            "        dynamic_monoid_chan res(sum + b.sum);",
            "        return res;",
            "    }",
            "    static dynamic_monoid_chan get_default([[maybe_unused]] int l, [[maybe_unused]] int r)",
            "    {",
            "        return dynamic_monoid_chan();",
            "    }",
            "",
            "    dynamic_monoid_chan grow()",
            "    {",
            "        if(left == nullptr)",
            "        {",
            "            left = new dynamic_monoid_chan();",
            "            right = new dynamic_monoid_chan();",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet for dynamic_monoid (waifu version)"
    },
    "template_waifu_splay": {
        "prefix": "template_waifu_splay",
        "body": [
            "/*",
            "general ideas:",
            "- Can do a dfs to an arbitrary node in O(log(n)) time, if you always splay it afterwards",
            "- For single node modifications, we generally splay the node first and then do what we want",
            "- BST property is maintained throughout (key can be redundant a lot of times)",
            "*/",
            "",
            "namespace splay_chan",
            "{",
            "    //common: push, splay, pull",
            "    bool is_root(node* u)",
            "    {",
            "        if(u == nullptr)",
            "            return false;",
            "        return (u->p == nullptr);",
            "    }",
            "",
            "    void rotate(node* u)",
            "    {",
            "        auto p = u->p;",
            "        assert(p != nullptr);",
            "",
            "        p->push();",
            "        u->push();",
            "",
            "        u->p = p->p;",
            "        p->p = u;",
            "",
            "        if(u->p != nullptr)",
            "        {",
            "            if(u->p->l == p)",
            "                u->p->l = u;",
            "            if(u->p->r == p)",
            "                u->p->r = u;",
            "        }",
            "",
            "        if(u == p->l)",
            "        {",
            "            p->l = u->r;",
            "            if(u->r != nullptr)",
            "                u->r->p = p;",
            "            u->r = p;",
            "        }",
            "        else",
            "        {",
            "            p->r = u->l;",
            "            if(u->l != nullptr)",
            "                u->l->p = p;",
            "            u->l = p;",
            "        }",
            "",
            "        p->pull();",
            "        u->pull();",
            "    }",
            "",
            "    void splay(node *u)",
            "    {",
            "        if(u == nullptr)",
            "            return;",
            "        while(!is_root(u))",
            "        {",
            "            auto p = u->p;",
            "            if(!is_root(p))",
            "            {",
            "                if((p->l == u) ^ (p->p->l == p))",
            "                    rotate(u);",
            "                else",
            "                    rotate(p);",
            "            }",
            "            rotate(u);",
            "        }",
            "    }",
            "",
            "    pair<node*, int> access(node* u, const function<int(node*)> &go_to)",
            "    {",
            "        if(u == nullptr)",
            "            return {u, 0};",
            "        splay(u);",
            "        int d = 0;",
            "",
            "        while(1)",
            "        {",
            "            u->push();",
            "            d = go_to(u);",
            "            if(d == 0)",
            "                break;",
            "            node *v = (d == -1 ? u->l : u->r);",
            "            if(v == nullptr)",
            "                break;",
            "            u = v;      ",
            "        }",
            "",
            "        splay(u);",
            "        return {u, d};",
            "    }",
            "",
            "    node* get_leftmost(node* u)",
            "    {",
            "        return access(u, [&](node*) {return -1;}).first;",
            "    }",
            "",
            "    node* get_rightmost(node* u)",
            "    {",
            "        return access(u, [&](node*) {return 1;}).first;",
            "    }",
            "",
            "    node* get_kth(node* u, int k)        // 0-indexed",
            "    {",
            "        pair<node*, int> p = access(u, [&](node* u)",
            "        {",
            "            if(u->l != nullptr)",
            "            {",
            "                if(u->l->siz > k)",
            "                    return -1;",
            "                k -= u->l->siz;",
            "            }",
            "            if(k == 0)",
            "                return 0;",
            "            -- k;",
            "            return 1;",
            "        });",
            "",
            "        auto v = p.first;",
            "        v->push();",
            "        splay(v);",
            "",
            "        return (p.second == 0 ? v : nullptr); ",
            "    }",
            "",
            "    int get_position(node *u)        // 0 -indexed",
            "    {",
            "        splay(u);",
            "        return (u->l == nullptr ? 0 : u->l->siz);",
            "    }",
            "",
            "    node* get_root(node* u)",
            "    {",
            "        splay(u);",
            "        return u;",
            "    }",
            "",
            "    pair<node*, node*> split(node* u, const function<bool(node*)> &IsRight)",
            "    {",
            "        if(u == nullptr)",
            "            return {nullptr, nullptr};",
            "        ",
            "        pair<node*, int> p = access(u, [&](node* u) {return IsRight(u) ? -1 : 1;});",
            "        ",
            "        //if p.second == 1, we have found the greatest node which should be in the left subtree",
            "        //if p.second == -1, we have found the smallest node which should be in the right subtree",
            "        //then in both cases, we splayed this node and its now the root",
            "",
            "        u = p.first;",
            "        u->push();",
            "        splay(u);",
            "",
            "        if(p.second == -1)",
            "        {",
            "            node* v = u->l;",
            "            if(v == nullptr)",
            "                return {nullptr, u};",
            "            u->l = nullptr;",
            "            v->p = nullptr;",
            "            u->pull();",
            "            return {v, u};",
            "        }",
            "        else",
            "        {",
            "            node* v = u->r;",
            "            if(v == nullptr)",
            "                return {u, nullptr};",
            "            u->r = nullptr;",
            "            v->p = nullptr;",
            "            u->pull();",
            "            return {u, v};",
            "        }",
            "",
            "        return {nullptr, nullptr};",
            "    }",
            "",
            "    node* merge(node* u, node* v)       //all in u <= all in v",
            "    {",
            "        if(u == nullptr)",
            "            return v;",
            "        if(v == nullptr)",
            "            return u;",
            "        ",
            "        u = get_rightmost(u);",
            "        u->push();",
            "        ",
            "        splay(u);",
            "",
            "        assert(u->r == nullptr);",
            "        u->r = v;",
            "        v->p = u;",
            "        u->pull();",
            "",
            "        return u;",
            "    }",
            "",
            "    node *insert(node *r, node *v, const function<bool(node *)> &go_left)",
            "    {",
            "        //returns new root",
            "        pair<node *, node *> p = split(r, go_left);",
            "        return merge(p.first, merge(v, p.second));",
            "    }",
            "",
            "    node *remove(node *u)",
            "    { ",
            "        // returns the new root",
            "        splay(u);",
            "        u->push();",
            "        node *x = u->l;",
            "        node *y = u->r;",
            "        u->l = u->r = nullptr;",
            "        if(x != nullptr)",
            "            x->p = nullptr;",
            "        if(y != nullptr) ",
            "            y->p = nullptr;",
            "        node *z = merge(x, y);",
            "        ",
            "        u->p = nullptr;",
            "        u->push();",
            "        u->pull(); // now u might be reusable...",
            "        ",
            "        return z;",
            "    }",
            "",
            "    //untested",
            "    node *next(node *v)",
            "    {",
            "        splay(v);",
            "        v->push();",
            "        //find leftmost node in subtree of right child of node v",
            "        if (v->r == nullptr)",
            "            return nullptr;",
            "        v = v->r;",
            "        while (v->l != nullptr)",
            "        {",
            "            v->push();",
            "            v = v->l;",
            "        }",
            "        splay(v);",
            "        return v;",
            "    }",
            "",
            "    //untested",
            "    node *prev(node *v)",
            "    {",
            "        splay(v);",
            "        v->push();",
            "        //find rightmost node in subtree of left child of v",
            "        if (v->l == nullptr)",
            "            return nullptr;",
            "        v = v->l;",
            "        while (v->r != nullptr)",
            "        {",
            "            v->push();",
            "            v = v->r;",
            "        }",
            "        splay(v);",
            "        return v;",
            "    }",
            "",
            "    //0-indexed",
            "    //`operate(0, node*)` is to operate with single node",
            "    //`operate(1, node*)` is to operate on subtree of node",
            "    template<typename O>",
            "    node* query(node* u, int l, int r, O operate)",
            "    {",
            "        u = get_kth(u, l);",
            "        assert(u != nullptr);",
            "        assert(l <= r and r < u->siz);",
            "",
            "        int remaining = (r - l + 1);",
            "        ",
            "        -- remaining;",
            "        operate(0, u);",
            "        u->push();",
            "",
            "        if(u->r != nullptr)",
            "            u = u->r;",
            "",
            "        while(remaining > 0)",
            "        {",
            "            u->push();",
            "",
            "            if(u->l != nullptr)",
            "            {",
            "                if(u->l->siz >= remaining)",
            "                {",
            "                    u = u->l;",
            "                    continue;",
            "                }",
            "                remaining -= u->l->siz;",
            "                operate(1, u->l);",
            "            }",
            "",
            "            if(remaining > 0)",
            "            {",
            "                -- remaining;",
            "                operate(0, u);",
            "            }",
            "",
            "            if(u->r == nullptr)",
            "                break;",
            "            u = u->r;",
            "        }",
            "",
            "        u->push();",
            "        splay(u);",
            "        u->pull();",
            "",
            "        return u;",
            "    }",
            "",
            "    //0-indexed",
            "    //`operate(0, node*)` is to operate with single node",
            "    //`operate(1, node*)` is to operate on subtree of node",
            "    template<typename O>",
            "    node* modify(node* u, int l, int r, O operate)",
            "    {",
            "        u = get_kth(u, l);",
            "        assert(u != nullptr);",
            "        assert(l <= r and r < u->siz);",
            "",
            "        int remaining = (r - l + 1);",
            "        ",
            "        -- remaining;",
            "        operate(0, u);",
            "        u->push();",
            "",
            "        auto dfs = [&](auto &&dfs) -> void",
            "        {",
            "            if(remaining == 0)",
            "                return;",
            "            ",
            "            node* cur = u;",
            "            u->push();",
            "",
            "            if(u->l != nullptr)",
            "            {",
            "                if(u->l->siz >= remaining)",
            "                {",
            "                    u = u->l;",
            "                    dfs(dfs);",
            "",
            "                    cur->pull();",
            "                    return;",
            "                }",
            "                ",
            "                remaining -= u->l->siz;",
            "                operate(1, u->l);",
            "                u->pull();          //left child might have been updated",
            "            }",
            "",
            "            if(remaining > 0)",
            "            {",
            "                -- remaining;",
            "                operate(0, u);",
            "            }",
            "",
            "            if(u->r == nullptr)",
            "            {",
            "                cur->pull();",
            "                return;",
            "            }",
            "",
            "            u = u->r;",
            "            dfs(dfs);",
            "",
            "            cur->pull();",
            "            return;",
            "        };",
            "",
            "        if(u->r != nullptr)",
            "            u = u->r;",
            "        ",
            "        node* cur = u;",
            "        dfs(dfs);",
            "        cur->pull();",
            "",
            "        u->push();",
            "        splay(u);",
            "        u->pull();",
            "",
            "        return u;",
            "    }",
            "};",
            "using namespace splay_chan;"
        ],
        "description": "Snippet for splay (waifu version)"
    },
    "template_waifu_bst_node": {
        "prefix": "template_waifu_bst_node",
        "body": [
            "class node",
            "{",
            "public:",
            "//tree info",
            "    node *l, *r, *p;",
            "    //self",
            "    int key;",
            "    //subtree aggregate",
            "    int siz;",
            "",
            "//monoid info",
            "    //self",
            "    int64_t val;",
            "",
            "    //subtree Aggregates",
            "    int64_t sum;",
            "",
            "    //lazy propagation",
            "    int64_t add;",
            "",
            "    node()",
            "    {",
            "        p = l = r = nullptr;",
            "        key = siz = val = sum = add = 0;",
            "    }",
            "",
            "    //current attributes are already updated, update child attributes so that a pull would result in the correct aggregate",
            "    void push()",
            "    {",
            "        if(l != nullptr)",
            "            l->sum += add * l->siz, l->val += add, l->add += add;",
            "        if(r != nullptr)",
            "            r->sum += add * r->siz, r->val += add, r->add += add;",
            "        add = 0;",
            "    }",
            "    void pull()",
            "    {",
            "        siz = sum = 0;",
            "        if(l != nullptr)",
            "            siz += l->siz, sum += l->sum;",
            "        siz += 1, sum += val;",
            "        if(r != nullptr)",
            "            siz += r->siz, sum += r->sum;",
            "    }",
            "};"
        ],
        "description": "Snippet for bst_node (waifu version)"
    }
}